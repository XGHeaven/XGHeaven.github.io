
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="XGHeaven&#39;s Blog">
    <title>标签: CSS - XGHeaven&#39;s Blog</title>
    <meta name="author" content="XGHeaven">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta property="og:type" content="blog">
<meta property="og:title" content="XGHeaven&#39;s Blog">
<meta property="og:url" content="https://blog.xgheaven.com/tags/CSS/index.html">
<meta property="og:site_name" content="XGHeaven&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="XGHeaven">
<meta name="twitter:card" content="summary">
<meta name="twitter:creator" content="@XGHeaven">
    
    
        
    
    
        <meta property="og:image" content="https://www.gravatar.com/avatar/f34474afe04544ffbe944a804f0ae762?s=640"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-mhhgzztqkaub4zd4cl8bd83f7mgh9j6njnhilft4hamhrjsliqyzwo2cfzdk.min.css">

    <!--STYLES END-->
    
    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-71388235-1']);
        _gaq.push(['_trackPageview']);
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>

    
    <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?9894361f828b64144ac1f2ac0c58c300";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/%20">XGHeaven&#39;s Blog</a>
    </h1>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="https://www.gravatar.com/avatar/f34474afe04544ffbe944a804f0ae762?s=90"/>
        
        </a>
    
</header>
            <!-- Define author's picture -->


    

<nav id="sidebar" data-behavior="1">
    
        <div class="sidebar-profile">
            <a href="/#about">
                    <img class="sidebar-profile-picture" src="https://www.gravatar.com/avatar/f34474afe04544ffbe944a804f0ae762?s=110"/>
            </a>
            <span class="sidebar-profile-name">XGHeaven</span>
        </div>
    
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/%20"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                    <span class="sidebar-button-desc">首页</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-categories"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                    <span class="sidebar-button-desc">分类</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-tags"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                    <span class="sidebar-button-desc">标签</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-archives"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                    <span class="sidebar-button-desc">归档</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="#about"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                    <span class="sidebar-button-desc">关于</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/friend-link"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-link"></i>
                    <span class="sidebar-button-desc">友情链接</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://github.com/XGHeaven" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                    <span class="sidebar-button-desc">GitHub</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://twitter.com/xgheaven" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-twitter"></i>
                    <span class="sidebar-button-desc">Twitter</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://facebook.com/xgheaven" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-facebook"></i>
                    <span class="sidebar-button-desc">Facebook</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://www.linkedin.com/xgheaven/" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-linkedin"></i>
                    <span class="sidebar-button-desc">LinkedIn</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="mailto:xgheaven@gmail.com" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                    <span class="sidebar-button-desc">邮箱</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/atom.xml"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                    <span class="sidebar-button-desc">RSS</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/changelog"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-line-chart"></i>
                    <span class="sidebar-button-desc">Changelog</span>
                </a>
        </li>
        
    </ul>
    
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    

<section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2020/04/02/the-core-of-how-to-implement-resize-observer-polyfill/">
                            实现 Resize Observer Polyfill 的有趣之处
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" content="Thu Apr 02 2020 00:00:00 GMT+0800">
	
		    4月 02, 2020
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Frontend/">Frontend</a>


    
</div>
            </div>
            
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-Primer-on-Element-Resize"><span class="toc-text">A Primer on Element Resize</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#overflow-amp-underflow"><span class="toc-text">overflow &amp; underflow</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E5%A4%A7%E5%A4%A7"><span class="toc-text">大大大</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E4%B8%80%E7%82%B9"><span class="toc-text">小一点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bomb%EF%BC%81%E6%92%9E%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-text">bomb！撞在一起</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E7%9C%8B%E7%9A%84%E8%A7%81%E6%88%91%EF%BC%8C%E5%8F%88%E7%9C%8B%E4%B8%8D%E8%A7%81%E6%88%91%E4%BA%86%EF%BC%8C%E5%81%B7%E5%81%B7%E6%91%B8%E6%91%B8%E6%90%9E%E7%82%B9%E4%BA%8B%E6%83%85"><span class="toc-text">你看的见我，又看不见我了，偷偷摸摸搞点事情</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ResizeObserver"><span class="toc-text">ResizeObserver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%98%E6%9C%89%E5%88%AB%E7%9A%84%E5%8A%9E%E6%B3%95%E4%B9%88%EF%BC%9F"><span class="toc-text">还有别的办法么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-text">结语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Refs"><span class="toc-text">Refs</span></a></li></ol>
<h2 id="A-Primer-on-Element-Resize"><a href="#A-Primer-on-Element-Resize" class="headerlink" title="A Primer on Element Resize"></a>A Primer on Element Resize</h2><p>监听元素尺寸的变化一直以来，都是一个很常见的需求，但是又不那么容易去实现。因为浏览器都有实现针对窗口变化的监听，而却没有针对元素变化的监听。这个常常发生在一些内部元素大小变化的情况。</p>
<p>比如飞书 Admin 的管理页面，当左侧侧边栏收起或者展开的时候，右侧的宽度会发生变化，而浏览器的窗口并没有变化。</p>
<img src="/2020/04/02/the-core-of-how-to-implement-resize-observer-polyfill/550d3ed7-0294-45ac-bdca-984f9374001f.png" class="">
<p>如果我们从实际角度出发，监听元素的变动其实大部分是为了监听因为窗口变化而导致的大小变化，此时最简单的方案就是直接监听浏览器窗口的 resize 事件，这个就不细说了。</p>
<p>其次针对上文说道的情况，社区有很多的实现方案，但很多基于 JQuery 实现的，而且性能较差，因为是使用计数器去拉取元素宽度。不过会有很多优化方案，比如当点击某些可能会导致宽度发生变化的时候才启动定时器去检查，并且检查一段时间发现没有变化的时候，就停止检查。但是不管怎样，性能都是不太好的。</p>
<h2 id="overflow-amp-underflow"><a href="#overflow-amp-underflow" class="headerlink" title="overflow &amp; underflow"></a><code>overflow</code> &amp; <code>underflow</code></h2><p>于是，社区中有另外一种检测方案，那就是基于事件检测，用的就是 <code>overflow</code> 和 <code>underflow</code> 事件。不知道这两个事件是什么的，可以去看 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/overflow_event">MDN</a> 或者这篇<a target="_blank" rel="noopener" href="http://www.backalleycoder.com/2013/03/14/oft-overlooked-overflow-and-underflow-events/">博客</a>。</p>
<p>简单来讲，就是当内容超出外部容器的时候，会触发 <code>overflow</code> 事件，当内容又小于容器宽度的时候，会触发 <code>underflow</code> 事件。</p>
<p>那怎么检测呢？也很简单，先从扩大变化检测说起</p>
<p>假设有这样一个容器，长度宽度为 100px，内部有一个元素，长宽分别为 101px，也就是比父容器各大 1px。那么如果你将外部容器扩大的一瞬间，长宽至少会增加一个像素，也就是说至少比内部元素大，≥ 101px，此时会触发 <code>underflow</code> 事件。扩大检测就实现完成了，在检测完成之后重置内部元素大小依旧比外部容器大即可。</p>
<p>同理缩小检测也很简单，外部容器不变，内部元素宽度和父容器一直，当缩小的时候，父容器肯定会小于内部元素，于是触发 <code>overflow</code>。缩小检测也完成了，再重置宽度即可。</p>
<p>看似一切美好，但实际上，这两个事件的兼容到现在都巨差无比。但别担心，还有别的办法</p>
<h2 id="大大大"><a href="#大大大" class="headerlink" title="大大大"></a>大大大</h2><p>我们现在考虑下扩大的时候，如果父容器有滚动条，有一样东西是会发生变化的。那就是可滚动区域的大小——这不是废话么。别急，先想想可滚动区域变化的话，什么也会跟着变化呢？</p>
<p>没错，就是父元素的 <code>scrollTop</code> 和 <code>scrollLeft</code>。具体怎么讲呢，这边我们先考虑 <code>scrollTop</code> 的情况。</p>
<p>假设有这样一个容器（绿色），高宽为 100px，内部有一个元素（红色），高 200px，宽 100px，也就是比容器固定大 100px。容器滚动到最底部，此时容器的 <code>scrollTop: 100px</code>，如左图所示。如果此时容器扩大 10px，很明显随着滚动区域的变大，<code>scrollTop</code> 也会自动变化成 90px，如右图。</p>
<img src="/2020/04/02/the-core-of-how-to-implement-resize-observer-polyfill/dd646477-b0d5-4764-8700-19b4babfdf17.png" class="">
<p>那么问题来了，<code>scrollTop</code> 怎么监听呢？</p>
<p>神奇就神奇在这里，因为元素尺寸的变化而导致 <code>scrollTop</code> 的变化竟然会触发容器的 <code>scroll</code> 事件，而且这个事件触发还是跨平台的，兼容性甚至可以下探到 ie7</p>
<h2 id="小一点"><a href="#小一点" class="headerlink" title="小一点"></a>小一点</h2><p>这个时候你会发现，想要变小一点，那么问题就麻烦了。你会发现上面那个方式，你不管怎么搞，都无法让他在缩小的时候触发 <code>scrollTop</code> 的改变。</p>
<p>但是换个思路来考虑，你会发现另外一种让 <code>scrollTop</code> 发生改变的情况。依旧从上面那个方式来讲，如果容器缩小了 10px，那么内容至少要缩小 11px 才能导致滚动发生变化，那么我们会想到什么呢？</p>
<p>百分比对不对？这里假设设置内容高度为 200%，就可以做到当容器缩小 10px 的时候，内部元素可以缩小 20px，也就是 200px(100px <em> 200%) ⇒ 180px(90px </em> 200%)。如图所示</p>
<img src="/2020/04/02/the-core-of-how-to-implement-resize-observer-polyfill/fca3d400-0c33-48c2-b6d3-34562e07f5e7.png" class="">
<h2 id="bomb！撞在一起"><a href="#bomb！撞在一起" class="headerlink" title="bomb！撞在一起"></a>bomb！撞在一起</h2><p>把上面两个结合起来，就可以实现监听 resize 事件了。但实际上使用需要处理一些样式问题，不过这个问题很简单，不单独说了。</p>
<img src="/2020/04/02/the-core-of-how-to-implement-resize-observer-polyfill/55c70adf-27e4-4502-bb19-53f147ac1ee2.png" class="">
<p>如果前面你能看懂，那么到这里你心中有没有考虑一个情况，就是在重置的时候，会导致 <code>scrollTop/Left</code> 又发生了修改，从而又导致的 <code>scroll</code> 事件的触发，而这个怎么消除呢？</p>
<p>有这么两种办法：</p>
<ol>
<li><p>通过检测元素是否发生变动，如果有变动那么就是因为元素缩放导致的，而如果没有缩放，那么就是通过重置导致的。</p>
</li>
<li><p>通过 raf，在同一帧内，先触发因为元素变动导致的 <code>scroll</code>，再触发因为重置导致的事件，然后将对事件的处理统一推迟到下一阵开始的时间。从而消除循环事件</p>
<img src="/2020/04/02/the-core-of-how-to-implement-resize-observer-polyfill/0389557f-89b9-4ffa-9e2b-83f4b76508a4.png" class="">
</li>
</ol>
<h2 id="你看的见我，又看不见我了，偷偷摸摸搞点事情"><a href="#你看的见我，又看不见我了，偷偷摸摸搞点事情" class="headerlink" title="你看的见我，又看不见我了，偷偷摸摸搞点事情"></a>你看的见我，又看不见我了，偷偷摸摸搞点事情</h2><p>众所周知，当你给一个元素设置 <code>display:none;</code> 的时候，元素不会渲染，同理也不会监听外部容器尺寸的变化。那么这就给了被监听元素可乘之机，他可以让 DOM 先隐藏，然后再改变大小，再显示 DOM，此时尺寸就乱了，于是就无法很好的监听 resize 了。</p>
<p>不过，也不是没有办法。</p>
<p>当 DOM 显示在浏览器的时候，会执行一个操作——播放动画</p>
<p>而动画事件是可以被监听到的，于是骚操作来了，给 DOM 元素添加一个 1ms 的动画，然后监听动画开始的事件，然后重置并检测大小变化。</p>
<h2 id="ResizeObserver"><a href="#ResizeObserver" class="headerlink" title="ResizeObserver"></a>ResizeObserver</h2><p>这么通用的需求，怎么能逃过 w3c 的双眼，于是就推出了 <a target="_blank" rel="noopener" href="https://drafts.csswg.org/resize-observer/#resize-observer-interface">ResizeObserver</a>，方便做 resize 的监听。</p>
<p>而这个 api 所能做的远比我们想象的强大很多：</p>
<ul>
<li><p>能够监听不同 <code>box-sizing</code> 的变化，比如 <code>border-box</code>/<code>content-box</code></p>
</li>
<li><p>能够监听元素挂载和卸载</p>
</li>
<li><p>能够监听非容器类型的 DOM，比如 <code>input</code> <code>canvas</code> 等等</p>
</li>
</ul>
<p>正好说到了这个，顺便讲下一个有意思的事情。自古监听，从来没逃过循环计算的问题，大家熟悉的 angular 脏检查的次数限制，而 <code>ResizeObserver</code> 是怎么解决这个问题的呢。</p>
<p>这里先说明几个概念：</p>
<ul>
<li><p><code>observer</code> 每一个 <code>ResizeObserver</code> 实例</p>
</li>
<li><p><code>observation</code> 当 observer 实例调用 observe 方法之后创建的每一个监听，每个 <code>observer</code> 可能包含多个 <code>observation</code> </p>
</li>
<li><p><code>target</code> 被监听的 DOM 元素</p>
</li>
<li><p><code>depth</code> 深度，表示一个 DOM 元素距离根元素的距离，在网页中，也就是距离 html 标签的距离。</p>
</li>
</ul>
<p>在每一次 Event Loop 中，会检查每一个 <code>observation</code> 的 <code>target</code> 的 <code>depth</code> ，并取一个最小值。然后顺便检查有那些 <code>observation</code> 产生了变化，并创建对应的 <code>entity</code> ，最后作为参数传给 <code>observer</code> 的回调。当上面这一操作之后，就完成了一轮检测，然后会再重复一遍这样的操作，只不过这次有个要求，不仅仅要求 <code>observation</code> 有变化，还要要求对应的 <code>depth</code> 比上次检查的最小值还要大，才可以创建 <code>entity</code>。就这样一直一直循环检测跑下去，直到没有任何东西被检测到发生变化。</p>
<p>用一点通俗的话来说，除了第一轮的检查外，其他的每一轮检查都要求元素的高度要大于在上一轮检查元素的高度最小值，从而保证每一次检查，深度都会越来越大，直到达到最小的根节点，进而检查结束。</p>
<p>不过也许你会好奇，难道有些元素就会被跳过不检查么？其实不会的，对于那些深度小于上一次的最小深度的 <code>observation</code> 会自动到下一个 Event Loop 的时机去检查。</p>
<p>以上内容确实有点绕，我自己写的再看第二遍都看不懂了，原本好像补一个图仔细讲讲，但是发现上图也讲不清，算了弃疗，大家有兴趣的看看 Spec 吧。还有就是兼容性有点差，微软家的和苹果家的都不支持，摊手</p>
<h2 id="还有别的办法么？"><a href="#还有别的办法么？" class="headerlink" title="还有别的办法么？"></a>还有别的办法么？</h2><p>当然有了，还有我们 <code>IntersectionObserver</code> 呀。</p>
<p>怎么用？和最上面使用 scroll 的差不多，但是要略微简单一些，其实也没简单多少，因为该 api 判断的是相交的面积，也就是不能通过一个哨兵来判断，而是一个方向需要有一个哨兵。</p>
<p>至于兼容性么，除了 IE 不支持，其他都支持，这就很完美了么，对吧。（诡异的双眼，实际上坑很多，不建议尝试）</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文没有特别深入的去讲解一些细节，只是讲了一下我觉得有意思的地方，如果你觉得哪里不清楚或者想了解更多，可以尝试去看源码。/<em> 我又没说包教包会 </em>/</p>
<p>另外，我也是没懂为啥各大浏览器厂商这次这么一致，针对容器大小变化导致的 <code>scrollTop</code> 变化会触发 <code>scroll</code> 事件。可能是我太年轻了吧，这种上古事件的在各大浏览器之间的爱情纠葛我实在是无从考证。</p>
<p>另外，上面说 HC 很多，要多多推荐人，我也不喜欢专门打广告这种事情，但……杭州 Lark 部门招人，前端后端设计产品，应该（因为我也不确定，逃）是都要的。另外我觉得字节跳动是个好公司，如果你有其他部门或者其他城市的部门想要内推或者了解详情的，我也可以帮忙引荐下，只要进了字节我觉得就是对字节最大的贡献，不一定要来我们部门的，滑稽脸。</p>
<h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><ul>
<li><a target="_blank" rel="noopener" href="https://webkit.org/blog/9997/resizeobserver-in-webkit/">ResizeObserver in Webkit</a></li>
</ul>

                    
                        

                    
                    
                        <p>
                            <a href="/2020/04/02/the-core-of-how-to-implement-resize-observer-polyfill/#post-footer" class="postShorten-excerpt_link link">
                                注释和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/11/18/hindsight-fe-what-usage-of-position-sticky/">
                            【后知后觉系列】Css Position: Sticky 属性以及某些场景的使用
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" content="Sun Nov 18 2018 00:00:00 GMT+0800">
	
		    11月 18, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/%E5%90%8E%E7%9F%A5%E5%90%8E%E8%A7%89/">后知后觉</a>


    
</div>
            </div>
            
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#position-sticky-%E8%BF%99%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F"><span class="toc-text">position: sticky 这究竟是一个什么鬼？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF"><span class="toc-text">正确的使用姿势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E6%A0%97%E5%AD%90-%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%97%E8%A1%A8%E5%A4%B4%E9%83%A8"><span class="toc-text">举个栗子 - 通讯录列表头部</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E6%80%9D%E8%80%83"><span class="toc-text">拓展思考</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E5%B7%B2%E7%BB%8F%E8%A2%AB%E5%9B%BA%E5%AE%9A%EF%BC%9F"><span class="toc-text">如何检测是否已经被固定？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%A3%E8%83%BD%E4%B8%8D%E8%83%BD%E5%AE%9E%E7%8E%B0%E8%A1%A8%E6%A0%BC%E5%A4%B4-%E5%88%97%E5%9B%BA%E5%AE%9A%E5%91%A2%EF%BC%9F"><span class="toc-text">那能不能实现表格头&#x2F;列固定呢？</span></a></li></ol></li></ol>
<blockquote>
<p>不知何时，曾经我们认为的东西便会被打破，如果我们不坚持着去学习，那么我们终将会被社会所淘汰。于是我决定写《后知后觉系列》来记录一下我曾经跟不上的知识和关键点，内容不一定复杂，内容含量不一定高，也许别人已经写过一个一样的教程了，但是希望你能从我的笔记中获取你认为重要的东西，在纷繁复杂的工作中留下一个真正极客的世界，希望某一天这些东西都能够运用到工作当中。——XGHeaven</p>
</blockquote>
<blockquote>
<p>记得先看一下目录，找到你喜欢好奇的内容去针对性阅读，毕竟我不是来写教程的。</p>
</blockquote>
<h2 id="position-sticky-这究竟是一个什么鬼？"><a href="#position-sticky-这究竟是一个什么鬼？" class="headerlink" title="position: sticky 这究竟是一个什么鬼？"></a>position: sticky 这究竟是一个什么鬼？</h2><p>最近公司在用 Regular 封装一个表格组件，需要实现固定表头的功能。这个是几乎所有的组件库都会实现的一个效果，所以实现方式有很多种：</p>
<ol>
<li><p>因为 thead/tr 的 position 属性是无效的，所以需要单独用 div 创建一个表头。然后设置这个表头的 <code>position: absolute</code>，同时 <code>top: 0</code>。同时这种模式下，需要用户指定每一列的宽度，保证自制的表头和下面原生的表格一一对应起来。如果不指定的话，也可以等待 dom 渲染完成之后，再测量宽度。比如 Ant Design 就是使用的这种方式。</p>
</li>
<li><p>因为上面那种方案的难点在于无法很好的保证自制表头和原生表格宽度的一致性，所以我们组的大佬提出了使用原生 thead，监听 scroll 事件，设置 <code>transform</code> 属性使得表头进行偏移，从而实现 fixHeader 的问题，这种方式解决了第一个的问题，但是需要手动监听 scroll 事件，在快速滚动的情况下，可能会有一定的性能问题。而且不够优雅。如果后面的表格内容中有 <code>position: relative</code> 的元素，会覆盖到表头。</p>
</li>
</ol>
<p>不管是哪种方式，我总感觉不是很完美，于是我就在思考，除了手动更新的方式，难道就没有一些比较好的方式去做。然后我就去翻看了 github 的固定表头的方式，顿时豁然开朗。于是就延伸出了这篇文章，<code>position: sticky</code> 属性。</p>
<p><strong>Pay Attention</strong>：后面所讲的内容就不怎么和表格固定表头相关，如果你对表格固定表头或者固定列有一定问题，可以查看网易考拉的这篇文章 <a target="_blank" rel="noopener" href="https://blog.kaolafed.com/2017/12/25/%E4%B8%80%E8%B5%B7%E6%9D%A5%E8%81%8A%E8%81%8Atable%E7%BB%84%E4%BB%B6%E7%9A%84%E5%9B%BA%E5%AE%9A%E5%88%97/">《一起来聊聊table组件的固定列》</a>。</p>
<p>当第一眼看到这个熟悉的时候，第一句话就是“我 CA”，这 TMD 是什么鬼属性，position 什么时候有了这个属性。于是去看了 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position">MDN</a> 的介绍，可以理解为，这个属性是<strong>实现固定顶部最简单的实现方式</strong>。</p>
<p>他其实是一种 <code>position:relative</code> 和 <code>position: fixed</code> 的结合体，一定要配合 <code>top/right/bottom/left</code> 的属性一起才有作用，设置对应方向的最小值。当大于最小值的时候，他就像 <code>relative</code> 一样，作为文档流的一部分，并且 <code>top/right/bottom/left</code> 属性也会失效。否则当小于设置的值的时候表现的像 <code>fixed</code>，只不过这个 <code>fixed</code> 不再现对于窗口，而是相对于最近的可滚动块级元素。</p>
<p>如果你看过其他关于 sticky 的文章，大部分都会以黏贴的意思来解释他，那么很明显，确实也是这个意思，如果你觉得看了其他教程能够清楚的话，那么可以不用看我这篇了，如果你没看懂的话，可以来我这里看看。</p>
<p>废话少说，我们先来看一下如何正确使用 sticky。</p>
<h2 id="正确的使用姿势"><a href="#正确的使用姿势" class="headerlink" title="正确的使用姿势"></a>正确的使用姿势</h2><blockquote>
<p>以下的代码预览请使用最新 Chrome 查看，或者支持 position: sticky 的浏览器查看。部分网站不支持 iframe，可以去我的 Blog 查看</p>
</blockquote>
<ol>
<li><p><code>position: sticky</code> 只相对于第一个有滚动的父级块元素（scrolling mechanism，通过 overflow 设置为 <code>overflow/scroll/auto/overlay</code> 的元素），而不是父级块元素。</p>
<!-- unsupported embed -->
</li>
<li><p><code>position: sticky</code> 只有当设置对应的方向(top/right/bottom/left)，才会有作用，并且可以互相叠加，可以同时设置四个方向。</p>
</li>
<li><p>即使设置了 <code>position: sticky</code>，也只能显示在父级块元素的内容区域，他无法超出这个区域，除非你设置了负数的值。</p>
</li>
<li><p><code>position: sticky</code> 并不会触发 BFC，简单来讲就是计算高度的时候不会计算 float 元素。</p>
</li>
<li><p>当设置了 <code>position: sticky</code> 之后，内部的定位会相对于这个元素</p>
<!-- unsupported embed -->
</li>
<li><p>虽然 <code>position: sticky</code> 表现的像 <code>relative</code> 或者 <code>fixed</code>，所以也是可以通过 <code>z-index</code> 设置他们的层级。当这个元素的后面的兄弟节点会覆盖这个元素的时候，可以通过 <code>z-index</code> 调节层级。</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/xgheaven/pen/LXodKa/">position: sticky 通过 z-index 调节层级</a> by Bradley Xu (<a target="_blank" rel="noopener" href="https://codepen.io/xgheaven">@xgheaven</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
</li>
</ol>
<p>当你懂了这几个之后，其实这个属性就用起来就很简单了。</p>
<h2 id="举个栗子-通讯录列表头部"><a href="#举个栗子-通讯录列表头部" class="headerlink" title="举个栗子 - 通讯录列表头部"></a>举个栗子 - 通讯录列表头部</h2><p>no code no bb，直接上代码。</p>
<!-- unsupported embed -->
<h2 id="拓展思考"><a href="#拓展思考" class="headerlink" title="拓展思考"></a>拓展思考</h2><h3 id="如何检测是否已经被固定？"><a href="#如何检测是否已经被固定？" class="headerlink" title="如何检测是否已经被固定？"></a>如何检测是否已经被固定？</h3><p>最常见的需求就是，当还在文档流当中的时候，正常显示，但是当固定住的时候，添加一些阴影或者修改高度等操作。要想实现这个效果，第一反应可能就是手动监听 <code>scroll</code> 事件，判断位置，这当然是没有问题的，但是随之而来的确实性能的损耗。</p>
<p>最好的方式是使用 IntersectionObserver，这是一个可以监听一个元素是否显示在视窗之内的 API，具体内容见阮老师的<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html">《IntersectionObserver API 使用教程》</a>。基本原理就是在一段滚动的头部和尾部分别添加两个岗哨，然后通过判断这两个岗哨的出现和消失的时机，来判断元素是否已经被固定。</p>
<p>例子<a target="_blank" rel="noopener" href="https://ebidel.github.io/demos/sticky-position-event.html">详见此处</a></p>
<h3 id="那能不能实现表格头-列固定呢？"><a href="#那能不能实现表格头-列固定呢？" class="headerlink" title="那能不能实现表格头/列固定呢？"></a>那能不能实现表格头/列固定呢？</h3><p>–理想很丰满，显示很骨感，因为 thead/tbody 对 position 无爱，所以也就不支持 sticky 属性，所以我们还是要单独创建一个头部。–</p>
<p>后来经过网友提醒，自己又去研究了一下，发现还是有办法做到固定表头和列的。</p>
<p>首先针对 Firefox，它本身就支持 thead/tbody 的 position 属性，所以可以直接通过对 thead/tbody 设置 position 来实现。而对于 Chrome 浏览器来讲，可以通过设置 thead 内的 th 来实现。具体见 Demo.</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/xgheaven/pen/RqmMQm/">position sticky 通过设置 td 来实现固定表头</a> by Bradley Xu (<a target="_blank" rel="noopener" href="https://codepen.io/xgheaven">@xgheaven</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p><strong>然后好像就没有了</strong>，谢谢观看水水的《后知后觉系列》</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/11/18/hindsight-fe-what-usage-of-position-sticky/#post-footer" class="postShorten-excerpt_link link">
                                注释和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">第 1 页 共 1 页</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2024 XGHeaven. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="https://www.gravatar.com/avatar/f34474afe04544ffbe944a804f0ae762?s=110"/>
        
            <h4 id="about-card-name">XGHeaven</h4>
        
            <h5 id="about-card-bio"><p>一个弱弱的码农</p>
</h5>
        
        
            <h5 id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>杭州电子科技大学学生一枚</p>

            </h5>
        
        
            <h5 id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                Weifang Shandong, China
            </h5>
        
    </div>
</div>

        
<div id="cover" style="background-image:url('/static/images/20170217-TombRaider.jpg');"></div>
    </body>
    <!--SCRIPTS-->

<script src="/assets/js/scrip-z6xcdnzggiy56kzp83ux5nnbwra1acrauxruz3kdi3u5xladb6jh4n3ylebm.min.js"></script>

<!--SCRIPTS END-->



</html>
