
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="XGHeaven&#39;s Blog">
    <title>分类: 小程序 - XGHeaven&#39;s Blog</title>
    <meta name="author" content="XGHeaven">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta property="og:type" content="blog">
<meta property="og:title" content="XGHeaven&#39;s Blog">
<meta property="og:url" content="https://blog.xgheaven.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/index.html">
<meta property="og:site_name" content="XGHeaven&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="XGHeaven">
<meta name="twitter:card" content="summary">
<meta name="twitter:creator" content="@XGHeaven">
    
    
        
    
    
        <meta property="og:image" content="https://www.gravatar.com/avatar/f34474afe04544ffbe944a804f0ae762?s=640"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-mhhgzztqkaub4zd4cl8bd83f7mgh9j6njnhilft4hamhrjsliqyzwo2cfzdk.min.css">

    <!--STYLES END-->
    
    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-71388235-1']);
        _gaq.push(['_trackPageview']);
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>

    
    <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?9894361f828b64144ac1f2ac0c58c300";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/%20">XGHeaven&#39;s Blog</a>
    </h1>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="https://www.gravatar.com/avatar/f34474afe04544ffbe944a804f0ae762?s=90"/>
        
        </a>
    
</header>
            <!-- Define author's picture -->


    

<nav id="sidebar" data-behavior="1">
    
        <div class="sidebar-profile">
            <a href="/#about">
                    <img class="sidebar-profile-picture" src="https://www.gravatar.com/avatar/f34474afe04544ffbe944a804f0ae762?s=110"/>
            </a>
            <span class="sidebar-profile-name">XGHeaven</span>
        </div>
    
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/%20"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                    <span class="sidebar-button-desc">首页</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-categories"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                    <span class="sidebar-button-desc">分类</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-tags"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                    <span class="sidebar-button-desc">标签</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-archives"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                    <span class="sidebar-button-desc">归档</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="#about"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                    <span class="sidebar-button-desc">关于</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/friend-link"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-link"></i>
                    <span class="sidebar-button-desc">友情链接</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://github.com/XGHeaven" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                    <span class="sidebar-button-desc">GitHub</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://twitter.com/xgheaven" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-twitter"></i>
                    <span class="sidebar-button-desc">Twitter</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://facebook.com/xgheaven" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-facebook"></i>
                    <span class="sidebar-button-desc">Facebook</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://www.linkedin.com/xgheaven/" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-linkedin"></i>
                    <span class="sidebar-button-desc">LinkedIn</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="mailto:xgheaven@gmail.com" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                    <span class="sidebar-button-desc">邮箱</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/atom.xml"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                    <span class="sidebar-button-desc">RSS</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/changelog"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-line-chart"></i>
                    <span class="sidebar-button-desc">Changelog</span>
                </a>
        </li>
        
    </ul>
    
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    

<section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2023/06/14/use-dom-to-improve-double-performance-in-mini-program/">
                            返璞归真「DOM」兼容接口的引入让飞书小程序性能获得 2 倍以上的提升
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" content="Wed Jun 14 2023 00:00:00 GMT+0800">
	
		    6月 14, 2023
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">小程序</a>


    
</div>
            </div>
            
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>小程序，作为新一代的应用开发方式，虽然在业务上已经证明了巨大的价值，但是在开发者友好性上却非常的差，例如框架难用，调试困难，跨平台兼容性差。本文便是在尝试提高针对视图的开发者友好性和兼容性，同时进一步提升性能。</p>
<p>为了能够更好的理解本文，需要您最好了解以下内容：</p>
<ul>
<li><p>有小程序相关的经验，能够理解基本小程序的架构、基本的框架使用方式、主流的跨端三方框架等</p>
</li>
<li><p>有前端相关的经验，能够理解什么是 DOM 接口，以及如何操作 DOM 接口</p>
</li>
</ul>
<p>本文将不再赘述过多的基础概念内容。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>目前本人任职飞书开放平台小程序组，负责小程序相关的运行时的工作内容。由于飞书对小程序有着一些特殊的需求：</p>
<ol>
<li><p>飞书大量官方应用都是通过小程序承载的，这些应用对运行体验和开发效率有着远比外界更高的要求。而且由于是官方应用，且只服务于飞书，所以他们对于小程序的跨端兼容性要求并不高。这也给了我们更大的灵活性去设计更好的方案。</p>
</li>
<li><p>飞书是一个面向全球 B 端的市场，先不论国内是否每个 B 端企业都能有精力去开发小程序，单论海外市场对小程序的认知就非常浅薄。所以如何尽可能的降低小程序的认知学习门槛，降低接入成本，就显得尤为重要。在国内可以通过类似于 Taro 的框架，但是海外这部分的学习成本依旧很高，所以需要有新的方式去降低这部分的成本。</p>
</li>
</ol>
<p>正是因为如此，我们这边决定不再以兼容社区小程序的方案为首要目标，而是转为提高开发者的开发体验和运行性能为主目标去进行设计和优化。</p>
<h1 id="现有架构的「病区」"><a href="#现有架构的「病区」" class="headerlink" title="现有架构的「病区」"></a>现有架构的「病区」</h1><p>小程序在诞生之后，其实做了很多的设定，有的设定是合适的，但更多的设定在逐渐的发展过程中变得不再合适，而后人却依旧沿着这个思路和方向去做。接下来，让我们重新思考一下这些设定：</p>
<h2 id="为什么会诞生-XXML-的视图开发方案？"><a href="#为什么会诞生-XXML-的视图开发方案？" class="headerlink" title="为什么会诞生 XXML 的视图开发方案？"></a>为什么会诞生 XXML 的视图开发方案？</h2><blockquote>
<p><code>XXML</code> 在这里是对通过模板开发小程序的一种开发范式（也可以叫开发框架或者 DSL）的统称。因为不同宿主内对应的模板文件的后缀不同，但都有 <code>ML</code> 而因此得名。例如微信是 <code>.wxml</code> ，支付宝是 <code>.axml</code>，而飞书和抖音则为 <code>.ttml</code>。</p>
</blockquote>
<p>在我的认知中，小程序最开始并不是为资深的前端开发而设计的，相反，他是为了客户端乃至一些没有开发经验的人所设计。</p>
<p>所以借鉴了 Vue 这类非常容易入门的社区框架，再结合上小程序自身的需求所定制了一套 DSL。这套 DSL 针对从来没有写过前端的人来说，确实算是非常友好的，几乎不需要学习就可以上手。</p>
<p>其实让开发者更容易的入门上手算是小程序最开始的目标。例如，一开始是不提供 CLI 工具只提供了可视化的 IDE。如果小程序的受众是不懂开发的人，那其实没问题。</p>
<p>但最终事与愿违，开发小程序最多的人其实就是资深的前端开发，在前端开发的视角来看，这套 DSL 可以用一坨屎来形容。而小程序又必须要要用这套 DSL 去开发，就导致每一个写过小程序的人必须吃一次这个屎。</p>
<h2 id="XXML-会带来什么问题？"><a href="#XXML-会带来什么问题？" class="headerlink" title="XXML 会带来什么问题？"></a>XXML 会带来什么问题？</h2><p>虽然以微信为首的厂商做了很多能力去补救，尽可能在保证较低入手门槛的情况下，不断丰富能力，提高对前端开发人员的友好程度。但最开始的设计就不是面向这部分人群，即使后面修补的再多也无济于事了。这其中所带来的的问题随着小程序的发展而愈发严重：</p>
<ul>
<li><p>由于这套框架的实现是内置在基础库内，其能力和功能的实现必然有滞后性，同时灵活度差。一旦框架概念落后，开发者将不得不继续咬牙学习落后内容。</p>
</li>
<li><p>虽然最开始借鉴自 JS 和 Web，但最终却无法的很好的利用开源社区的能力，几乎所有都要重造轮子。国内已经发展了这么多年，社区才将将都造完稳定的轮子，如果将这一套推向海外，那成本根本无法估量。</p>
</li>
<li><p>规范缺乏一致性。由于 XXML 本身其实是一个业务开发框架，但又作为唯一开发方式，非常容易变得越来越臃肿和随意，可能一个实习生随便定出的接口都将会影响整个社区，能力的实现也缺乏一致性。例如 <code>Page</code> 和 <code>Component</code> 的生命周期就非常不一样。</p>
</li>
<li><p>为了解决 XXML 这些问题，降低开发者的开发成本，在社区中诞生了许许多多的三方跨端框架。导致开发小程序的人不仅仅要懂得如何写原生的 XXML，更要懂得如何使用这些跨端框架，学习成本陡增。</p>
</li>
<li><p>Taro 这类模拟一套 DOM 接口来嫁接社区框架的做法，最终会让运行架构变成 <code>React =&gt; Taro DOM =&gt; TTML =&gt; DOM</code> 这种有点脱裤子放屁的方式。</p>
</li>
</ul>
<h2 id="小程序的视图开发一定要使用-XXML-么？"><a href="#小程序的视图开发一定要使用-XXML-么？" class="headerlink" title="小程序的视图开发一定要使用 XXML 么？"></a>小程序的视图开发一定要使用 XXML 么？</h2><p>一个支持通用应用的宿主，可以提供一套它认为合适的模板 DSL 去生成渲染树，但一定也需要提供一套更加灵活的方式去生成渲染树。例如：</p>
<ul>
<li><p>安卓默认使用 XML 作为模板，去渲染内容。但如果不满足使用，同时可以使用命令的操作方式去构建一个渲染树。iOS 也是用类似的逻辑</p>
</li>
<li><p>Flutter 定义了一套类似于 React 的 Weight 渲染框架。但依旧暴露了底层的 RenderObject 方便开发者绕过 Weight 直接去构建渲染树。</p>
</li>
</ul>
<p>而小程序，却选择了只提供 XXML，并没有提供其他的方式。如果小程序面向的特定需求场景，这倒也无可厚非，可实际上小程序面向的却是通用需求场景。</p>
<p>于是飞书内部在思考，如果我们一定要再提供一套通用的 DSL，会是什么？React、Vue 这类前端框架么？如果提供了，又会面临和 XXML 类似的局面。</p>
<p>其实在 Web 领域中，早就给出了答案，那么就是 DOM。不管是 React 还是 Vue 还是其他的框架，底层都是基于 DOM 接口所存在的。如果我们能够在小程序提供一套底层的 DOM 接口，那么 XXML 所带来的问题是不是就全都迎刃而解了呢？</p>
<h2 id="为什么之前不提供-DOM-接口？"><a href="#为什么之前不提供-DOM-接口？" class="headerlink" title="为什么之前不提供 DOM 接口？"></a>为什么之前不提供 DOM 接口？</h2><p>当我们想明白这个点之后，其实就会更加好奇，为什么这么简单的想法为啥一开始乃至后续的人都没做过呢？</p>
<p>我猜测最开始不这么做的原因有这么几个，但我觉得都不是很成立，或者说在飞书的场景中很难成立（如果大家有不同的想法和意见，随时可以和我沟通交流）。</p>
<blockquote>
<p>Q: 无法完整实现，成本高。<br>双线程无法实现完整的 DOM 接口，且在逻辑层实现一套 DOM 接口的成本过高。</p>
</blockquote>
<p>确实，如果想要一比一的复刻 DOM 接口，有些依赖渲染能力的接口确实无法实现。但如果只是实现一套子集，能够满足主流框架的使用，那么成本和难度并不高。比如 Taro 就是这么做的，社区也证明了其可行性。</p>
<blockquote>
<p>Q: 首屏性能差。<br>如果实现 DOM 接口，就必须要等待逻辑层完整渲染并操作完 DOM 接口之后，渲染层才能渲染，那么将失去双线程逻辑层和渲染层并行运行的优势。</p>
</blockquote>
<p>我觉得这个是一个屁股决定脑袋的事情。在 90% 的场景中，渲染层就是需要等待逻辑层计算完毕之后才能渲染的。就像是你不能说为了前端页面首屏速度快，要求所有网站都用 SSR 吧。</p>
<p>另外，首屏其实分为 FP 和 TTI 的，和 SSR 场景类似，XXML 可以做到 FP 快，但是 TTI 并不如 DOM 快的。飞书场景更在乎的是 TTI 而非 FP，所以影响不大。</p>
<p>再说，用了 DOM 接口之后自然是有对应的优化策略和方式的。</p>
<blockquote>
<p>Q: DOM 指令的通讯压力大。<br>如果采用 DOM 接口，那么逻辑层往渲染层发送的将是 DOM 指令，如果我要渲染 100 个普通的 view，这部分体积明显比直接发送 data 要大。</p>
</blockquote>
<p>没错，某些场景下，DOM 指令的数量确实是会比 data 体积大。</p>
<p>但是在飞书的业务场景中，通常都会有着重度的逻辑以及大量国际化文案，这部分会导致 data 的体积飞涨。而且并不是所有的开发都有合理使用 data 的能力的，有些人就喜欢啥都往 data 里面塞，这更加会加剧其体积的膨胀。</p>
<p>所以对于飞书来说，这个的影响其实并不大。</p>
<blockquote>
<p>Q: 觉得 TTML 就够用了</p>
</blockquote>
<p>懂的都懂，不多说了</p>
<blockquote>
<p>Q: 不希望对外认知上小程序就是前端，所以在一定程度上屏蔽了前端所用的东西。</p>
</blockquote>
<p>我觉得这其实是微信小程序的烟雾弹，让大家觉得小程序技术很厉害，它底层是 Native 实现，只是借鉴了前端的一些概念而已。</p>
<p>但实际上缺恰恰相反，从设计开始，就是在 Web 上面打补丁实现的，只是借鉴了一点点 Native 中的概念。</p>
<p>所以如果相信了这个烟雾弹，那么才是将自己埋入深坑。</p>
<blockquote>
<p>Q: 不希望利用 DOM 接口实现太多灵活的动态更新能力。<br>例如审核之后通过 API 更改 UI 界面。</p>
</blockquote>
<p>这个也是我见过最多的说法了，也是最站不住脚的说法。<br>XXML 本身就无法避免动态更新，更别说 DOM 了。</p>
<blockquote>
<p>Q: DOM 接口就不会有实现上的兼容问题了么？</p>
</blockquote>
<p>这是个好问题，虽然 DOM 接口本身是有标准的，但实现上其实各家都会遇见的不一样。</p>
<p>这个自然没有完美的解决方案，但是我觉得以兼容主流框架而不是提供完整兼容的 DOM 接口为目标是更加合理的。不管各家接口实现成什么样子，只要能兼容前端框架就是对的。</p>
<p>至此，其实我们可以看到，DOM 接口本身的引入并不存在什么实质性的阻碍。</p>
<p>而且最重要的事，DOM 本身是作为 XXML 的一种补充开发能力所引入的，每个开发者可以根据自己的架构特点选择 XXML 甚至的 DOM 来作为开发方式。</p>
<h2 id="提供-DOM-接口能带来哪些好处？"><a href="#提供-DOM-接口能带来哪些好处？" class="headerlink" title="提供 DOM 接口能带来哪些好处？"></a>提供 DOM 接口能带来哪些好处？</h2><p>最后的最后，我们其实要明白，如果要提供 DOM 接口，将会带来那些好处呢？</p>
<ul>
<li><p>能够几乎无缝的兼容市面上主流的前端框架，目前测试下来支持的有 <code>Vue</code> <code>Svelte</code> <code>React18</code>。极大的降低开发者的学习和开发成本。</p>
</li>
<li><p>可以提供极致的性能优化，做到非常细粒度的组件更新。</p>
</li>
<li><p>和前端主流开发方式对齐，不再分割与割裂，提高开发效率和降低接入成本。</p>
</li>
<li><p>针对三方的跨端框架，可以降低其兼容难度和运行时的体积，提高执行效率。</p>
</li>
</ul>
<p>最关键最关键的是，终于可以抛弃掉 XXML 这套恶心的东西了。没有难用的数据绑定，支持传递函数，不需要考虑 data 内数据是否是视图需要的，自定义组件之间的时序能够得到天然的保障，能够支持 CSS-In-JS 等等。</p>
<p>社区中很多优秀的方案都可以拿来使用，总之，就是优雅，优雅，还是优雅。</p>
<h1 id="全新架构"><a href="#全新架构" class="headerlink" title="全新架构"></a>全新架构</h1><p>在理解了上文所讲述的内容之后，就该讲解下我们为了实现上面的功能所做的全新架构了：</p>
<img src="/2023/06/14/use-dom-to-improve-double-performance-in-mini-program/2810ea5d-ab90-4fb8-8f26-fa101d2b26b8.png">
<p>最简单的理解，就是在新架构中，渲染层和逻辑层之间的通讯不再发送 data 了，而是通过逻辑层实现的一套 DOM 接口，将其转换成 DOM 的操作指令。</p>
<p>如果说渲染的操作是 <code>fn(data)</code> 的过程，那么以前这个过程是在渲染层完成，而新架构下，这个操作将在逻辑层完成。</p>
<p>在新架构中，依旧保留了对原先 XXML 的兼容性，开发者可以通过 <code>renderingModel</code> 控制。控制以 Page 为粒度，保证在开发中可以做到渐进式迁移。另外，DOM 接口与 XXML 只能二选一，两者无法在一个 Page 上同时开启。</p>
<blockquote>
<p>我并不认为提供 Page 级别的控制在技术设计上是一个好方案，但这个方案确实是可以最大程度上提供更好的兼容性，方便开发者渐进式的替换。</p>
</blockquote>
<h2 id="Document-结构"><a href="#Document-结构" class="headerlink" title="Document 结构"></a>Document 结构</h2><p>当开启 DOM 的渲染模型之后，整个小程序的文档模型都将与 Web 有着极其类似的结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> <span class="comment">&lt;!-- document.documentElement 一般不会用到这个 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="comment">&lt;!-- document.head --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 可以在这里利用 meta 标签配置一些全局内容 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span> <span class="comment">&lt;!-- document.body --&gt;</span></span><br><span class="line">	  <span class="tag">&lt;<span class="name">page</span> <span class="attr">route</span>=<span class="string">"xxx"</span>&gt;</span> <span class="comment">&lt;!-- Page 实例所对应的渲染节点 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">view</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">page</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">page</span> <span class="attr">route</span>=<span class="string">"xxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">page</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>例如每一个 Page 都对应着 <code>document.body</code> 内的一个 <code>&lt;page/&gt;</code> 元素。页面栈也与 <code>document.body.childNodes</code> 保持一致，页面栈的进出相当于 page 元素的插入和剥离。</p>
<p>当然，这里只是一个类比，实际上会有些许的不同，本文不再展开（其实就是我还没设计好，这是个预期模型）。</p>
<h2 id="小程序内置组件"><a href="#小程序内置组件" class="headerlink" title="小程序内置组件"></a>小程序内置组件</h2><p>小程序内置组件在 DOM 接口下名字、属性、使用方式依旧保持不变，并且遵守 Web 的通用规范。提供了对应的 DOM Interface 方便开发者直接操作和使用。例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tagName 都是和 XXML 内保持一致</span></span><br><span class="line"><span class="keyword">const</span> view = <span class="built_in">document</span>.createElement(<span class="string">'view'</span>)</span><br><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>)</span><br><span class="line"><span class="keyword">const</span> picker = <span class="built_in">document</span>.createElement(<span class="string">'picker'</span>)</span><br><span class="line"><span class="keyword">const</span> pickerView = <span class="built_in">document</span>.createElement(<span class="string">'picker-view'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性名字也与原先的保持一致，只不过当用作属性的时候，需要将其转换成驼峰的格式。</span></span><br><span class="line">button.openType = <span class="string">'share'</span></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">button.setAttribute(<span class="string">'open-type'</span>, <span class="string">'share'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原先组件的使用方式依旧不变，例如 picker-view 下面需要插入 picker-view-column</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">	pickerView.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'picker-view-column'</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当需要赋值非字符串类型的值的时候，尽量使用 property 的方式</span></span><br><span class="line">picker.range = [[<span class="string">'a'</span>, <span class="string">'b'</span>], [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 attribute 可能会得到预期以外的行为，不推荐使用</span></span><br><span class="line">picker.setAttribute(<span class="string">'range'</span>, [...])</span><br></pre></td></tr></table></figure>
<p>或许有人会问，为什么使用了 DOM 接口缺不能使用前端的组件呢？</p>
<p>这是因为小程序的组件体系确实是比较特殊的，目前暂时没有很好的办法去兼容。但是在未来，可能会选择开放部分 Web 的组件，例如 <code>div</code> <code>span</code> <code>svg</code> 等。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><blockquote>
<p>目前该方案还在内部开发阶段，外部没有全量发布。下文中提到的所有接口都属于不稳定接口，在没有正式对外前，只能作为参考。</p>
</blockquote>
<p>可能看完上面之后大家依旧会是一头雾水，我这里通过一个简单的 DEMO 来让大家有更加清晰的认识。</p>
<ol>
<li>打开飞书开发者工具中的新框架开关</li>
</ol>
<img src="/2023/06/14/use-dom-to-improve-double-performance-in-mini-program/81901ab6-dc9d-4c37-be46-4185af09f593.png">
<ol>
<li>在要开启 DOM 接口的 Page 所对应的 JSON 中添加 <code>renderingModel</code> 为 <code>dom</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"renderingModel"</span>: <span class="string">"dom"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>此时可以在 Page 的 <code>onLoad</code> 生命周期内通过 <code>this.pageElement</code> 获取到 Page 的元素实例了，可以将其理解为前端开发中的 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code> 元素。后续就可以按照前端开发流程去操作这个元素了</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  onLoad() &#123;</span><br><span class="line">    <span class="keyword">const</span> root = <span class="keyword">this</span>.pageElement</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以直接控制页面渲染</span></span><br><span class="line">    <span class="keyword">const</span> view = <span class="built_in">document</span>.createElement(<span class="string">'view'</span>) <span class="comment">// 这里不能使用 Web 组件，只能使用小程序组件</span></span><br><span class="line">    view.style = <span class="string">'color: blue;'</span> <span class="comment">// style 只能设置不能读取，读取到的值是不准确的</span></span><br><span class="line">    view.className = <span class="string">'root'</span></span><br><span class="line">    view.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Hello world'</span>))</span><br><span class="line">    root.appendChild(view)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者使用主流前端框架进行渲染</span></span><br><span class="line">    React.createRoot(root).render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>) <span class="comment">// JSX 小程序不支持，需要进行转换，这里只是举例</span></span><br><span class="line">    <span class="comment">// 或</span></span><br><span class="line">    Vue.createApp(App).mount(root)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li>其他的例如样式、API 等与普通小程序无异。样式依旧通过 XXSS 使用，API 则继续可以使用 <code>tt</code> 如果在飞书内的话。</li>
</ol>
<h1 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h1><p>性能自然是为什么要引入 DOM 最重要的一个因素了，让我们来看一下性能对比测试</p>
<h2 id="测试方式"><a href="#测试方式" class="headerlink" title="测试方式"></a>测试方式</h2><p>仓库：<a href="https://github.com/XGHeaven/perf-gadget-dom-vs-framework" target="_blank" rel="noopener">https://github.com/XGHeaven/perf-gadget-dom-vs-framework</a></p>
<p>使用 Vue3 的框架，Demo 使用 <a href="https://github.com/mdn/todo-vue" target="_blank" rel="noopener">mdn/todo-vue</a>，在此基础上使用了 Taro 将代码分别编译到飞书、微信、支付宝。</p>
<ul>
<li><p><code>taro-wx</code> Taro 编译到微信，微信版本为 <code>8.0.35</code></p>
</li>
<li><p><code>taro-alipay</code> Taro 编译到支付宝，开启 2.0 lib，支付宝版本为 <code>10.3.80</code></p>
</li>
<li><p><code>taro-tt</code> Taro 编译到抖音(Tiktok)，抖音版本为 <code>25.5.0</code></p>
</li>
<li><p><code>taro-lark</code> Taro 编译到飞书，飞书版本为 <code>6.5.3</code></p>
</li>
<li><p><code>dom-lark</code> Vue 源码直接编译到飞书新架构 DOM 接口上，飞书版本为 <code>6.5.3</code></p>
</li>
</ul>
<p>每一个测试项目，有 5 次的预热运行，之后会再运行 10 次，取其平均值。同时每次运行之间都会相隔一段时间，保证系统有时机去做别的事情，从而尽可能避免影响到测试结果。</p>
<blockquote>
<p>之所以选择 Taro 而非 XXML 原生写法或者其他跨端框架，其一是因为更加接近于开发者的使用体验，因为不可能有人会选择直接去操作 DOM。其二是因为 Taro 已经是最快的跨端框架了，再比较其他的没有什么太多的意义。</p>
</blockquote>
<p>除此以外，其他的内容基本一致：</p>
<ul>
<li><p>测试设备为华为 P40 Pro，麒麟 990 处理器，鸿蒙 OS 3.0 系统。</p>
</li>
<li><p>Taro 框架统一经过 build:xx 命令后运行，Vue 直接通过 Vite 编译后运行</p>
</li>
<li><p>运行方式都是打开对应平台的开发者工具并上传之后，在后台生成对应的二维码扫码预览，避免被认为是开发状态从而添加对结果有影响的能力。</p>
</li>
</ul>
<p>由于 Taro 框架以及飞书新架构的情况下，组件的 <code>mounted</code> 生命周期只能保证在逻辑层侧完成了渲染，不能保证此时组件更新指令已经发送到渲染层，我们需要寻找一个全新的方式去衡量什么时候组件真正渲染上屏。</p>
<p>幸运的是，<code>image</code> 组件有一个特性，当图片被渲染出来并成功加载之后，会触发 <code>load</code> 事件，当此事件触发的时候，可以认为组件已经正确被渲染到屏幕上了。此时，我们只需要在某次更新组件的最后一个组件内，插入一个高宽为 0 的 <code>image</code> 组件作为渲染标记，当事件被触发时，就可以测量出整体的渲染时间。</p>
<p>虽然图片加载会占用一定的时间，但资源本身就是离线保存在代码包内，加载速度很快，且这并不影响最终结果的相对大小。</p>
<blockquote>
<p>Taro 默认关闭资源内联功能，避免 Taro 将小资源文件内联成 base64 字符串从而增大通讯成本。</p>
</blockquote>
<h2 id="测试内容"><a href="#测试内容" class="headerlink" title="测试内容"></a>测试内容</h2><p>这里还需要再补充几点：</p>
<ul>
<li><p>不测试应用首屏的性能，由于首屏开始的时间点不同宿主下测量会是不一样的，所以我只在私下里在飞书上通过录屏测试过 Uniapp 对比 DOM，差不多 DOM 可以快 300ms。如果采用 Taro 理论上差距会缩小，但是依旧是快的。</p>
</li>
<li><p>而且首屏性能主要由 JS Parse 和 Execution 的时间组成，这两部分分别由包体积和渲染性能决定，可以分别对比这两项测试从而大体可以得出首屏的性能。</p>
</li>
<li><p>不包含纯静态内容，因为测试使用的是 Taro 框架，其会在逻辑层搞一套虚拟 DOM，会导致最终发送给渲染层的数据量其实基本一致，测试的意义不大。如果有需要，后续可以对比 DOM 和 XXML 的在纯静态内容上的速度差异。</p>
</li>
</ul>
<h3 id="列表组件渲染"><a href="#列表组件渲染" class="headerlink" title="列表组件渲染"></a>列表组件渲染</h3><p>渲染 100 个 Todo 项，记录对应的耗时</p>
<ul>
<li><p>mounted 耗时，指从组件 created 到 mounted 所花费的时间</p>
</li>
<li><p>完整渲染耗时，指从组件 created 到渲染层上屏渲染完毕（图片 onload 触发）所花费的时间</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>目标</th>
<th>mounted 耗时</th>
<th>完整渲染耗时</th>
</tr>
</thead>
<tbody>
<tr>
<td>taro-wx</td>
<td>141.3 (156%)</td>
<td>1457.4 (443%)</td>
</tr>
<tr>
<td>taro-alipay</td>
<td>141.1 (156%)</td>
<td>387.2 (177%)</td>
</tr>
<tr>
<td>taro-tt</td>
<td>148.5 (165%)</td>
<td>608.7 (185%)</td>
</tr>
<tr>
<td>taro-lark</td>
<td>140.8 (156%)</td>
<td>620.6 (188%)</td>
</tr>
<tr>
<td>dom-lark</td>
<td>89.9 (100%)</td>
<td>328.9 (100%)</td>
</tr>
</tbody>
</table>
<h3 id="列表组件内部更新"><a href="#列表组件内部更新" class="headerlink" title="列表组件内部更新"></a>列表组件内部更新</h3><p>将 Todo 项内的每一个 checked 进行反转，记录耗时</p>
<table>
<thead>
<tr>
<th>目标</th>
<th>完整渲染耗时</th>
</tr>
</thead>
<tbody>
<tr>
<td>taro-wx</td>
<td>1374.5 (2220%)</td>
</tr>
<tr>
<td>taro-alipay</td>
<td>138.7 (224%)</td>
</tr>
<tr>
<td>taro-tt</td>
<td>205.3 (331%)</td>
</tr>
<tr>
<td>taro-lark</td>
<td>231.7 (374%)</td>
</tr>
<tr>
<td>dom-lark</td>
<td>61.9 (100%)</td>
</tr>
</tbody>
</table>
<h3 id="体积比较"><a href="#体积比较" class="headerlink" title="体积比较"></a>体积比较</h3><ul>
<li><p>核心逻辑，只包含样式、JS、XXML、SJS 的大小，不包含图片文件，json 等</p>
</li>
<li><p>整包大小，包含图片资源、JS、CSS等整个包的大小</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>目标</th>
<th>核心逻辑</th>
<th>整包大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>taro-wx</td>
<td>308K (452%)</td>
<td>336K (323%)</td>
</tr>
<tr>
<td>taro-alipay</td>
<td>256K (376%)</td>
<td>276K (265%)</td>
</tr>
<tr>
<td>taro-tt</td>
<td>248K (364%)</td>
<td>272K (261%)</td>
</tr>
<tr>
<td>taro-lark</td>
<td>248K (364%)</td>
<td>272K (261%)</td>
</tr>
<tr>
<td>dom-lark</td>
<td>68K (100%)</td>
<td>104K (100%)</td>
</tr>
</tbody>
</table>
<h3 id="测试解读"><a href="#测试解读" class="headerlink" title="测试解读"></a>测试解读</h3><ul>
<li><p>微信不知为何，性能表现非常差，我也不再倾向于继续和它进行对比，否则数据会非常夸张。</p>
</li>
<li><p>采用 DOM 接口的开发方式，可以简化掉繁重的 Taro runtime 的实现，从而在速度和体积上获取一定的优势。</p>
</li>
<li><p>相比飞书自身，各种情况下速度至少可以提高一倍以上，体积可以降低到原先的 30%。</p>
</li>
<li><p>相比支付宝，体积上依旧保持优势，渲染速度上的优势略低一些，平均不超过 50% 的提升。但这个问题主要是飞书对内置组件（<code>checkbox</code>、<code>button</code>）实现的性能较差，如果飞书对这部分进行优化后，相信可以获得更好的优势。</p>
</li>
</ul>
<h1 id="新框架会面临那些问题"><a href="#新框架会面临那些问题" class="headerlink" title="新框架会面临那些问题"></a>新框架会面临那些问题</h1><p>虽然新架构的 DOM 接口在上面的测试和预期中会带来很多的优势，但这并不意味着一点问题都没有。</p>
<ul>
<li><p>新架构虽然保留了对 XXML 的兼容性，但依旧会产生一定的 Break Chagne，具体可以看<a href="https://open.feishu.cn/document/uYjL24iN/uEjMuEjMuEjM/new-framework/breaking-changes" target="_blank" rel="noopener">飞书官方文档</a>。</p>
</li>
<li><p>由于双线程的架构，在逻辑层模拟的那一层 DOM 无法实现任何和渲染结果相关的 API，例如 <code>getComutedStyle</code> 。还包括 querySelector 依旧要通过原先的异步方式获取。</p>
</li>
<li><p>由于 DOM 接口某些能力实现难度较高，例如 <code>innerHTML</code> <code>css parser</code> 等，目前与这些相关的能力只有写入没有读取的能力，如果一定要读取，将无法保证一致性。</p>
</li>
<li><p>目前样式还不支持动态插入，后续会支持在 <code>&lt;page&gt;</code> 或者 <code>&lt;head&gt;</code> 内动态插入 <code>&lt;style&gt;</code> 标签来实现。</p>
</li>
<li><p>首屏性能。这个上文也说过，后续会有很多办法去优化和实现的，但优先级不高</p>
</li>
</ul>
<p>对我来说，我觉得整体瑕不掩瑜，未来可期。</p>
<h1 id="未来规划与设计"><a href="#未来规划与设计" class="headerlink" title="未来规划与设计"></a>未来规划与设计</h1><ul>
<li><p>目前新框架能力的开启和 DOM 接口的使用还在内测状态，对外的时间暂时无法确定</p>
</li>
<li><p>未来 DOM 接口还有许多的优化方向，例如如何降低 DOM 指令的数量，降低一些重复字符串的发送等等</p>
</li>
<li><p>由于 DOM 接口在一些非 Web 标准组件中和前端框架有一些冲突，例如 React 无法很好的支持 <code>picker</code> 这类需要针对某些属性设置一个对象的情况。后续会推出一些兼容手段去解决这些问题。</p>
</li>
<li><p>主流的前端组件组（例如 antd/element/ud）都无法很好的运行在这个上面。一方面是因为这些组件库多多少少都依赖了前端的一些接口，而小程序没有；另一方面，组件库使用的也都是 Web 的标签元素，而不是小程序的组件。后续会尝试推出一定的解决方案去处理这个问题，能够让社区做较少的修改就可以兼容。</p>
</li>
<li><p>会考虑以飞书官方的身份推出一套适配于 DOM 接口的主流前端组件库，根据情况会选择是否需要添加 WebComponent 能力的支持。</p>
</li>
<li><p>未来飞书小程序的规划都是尽可能的向前端标准实现，未来可能会逐渐添加例如 <code>fetch</code> <code>navigator</code> 在内的 BOM 接口能力支持。</p>
</li>
</ul>
<h1 id="为什么要写这篇文章"><a href="#为什么要写这篇文章" class="headerlink" title="为什么要写这篇文章"></a>为什么要写这篇文章</h1><ul>
<li><p>希望能促进小程序的前进。<br>小程序业务上的成功并不是其可以恶心开发者的理由，也不应该放弃对其优化的决心。我希望我这一篇有点颠覆传统小程序风格的优化文章，能够探索更多的思路和想法。</p>
</li>
<li><p>寻求合作。<br>由于 DOM 接口的特性，需要更多社区的配合才能将这个发挥到极致，例如 Taro/Uniapp 等三方框架，Vant 等小程序原生组件库等等。</p>
</li>
<li><p>沟通交流，拓展思路。<br>希望能够得到更多人对这件事情的想法和思路，也希望能够得到更多的输入。</p>
</li>
</ul>

                    
                        

                    
                    
                        <p>
                            <a href="/2023/06/14/use-dom-to-improve-double-performance-in-mini-program/#post-footer" class="postShorten-excerpt_link link">
                                注释和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2021/01/02/the-quick-start-about-develop-nfc-in-mini-program/">
                            NFC 开发相关知识入门（小程序）
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" content="Sat Jan 02 2021 00:00:00 GMT+0800">
	
		    1月 02, 2021
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">小程序</a>


    
</div>
            </div>
            
                <div class="postShorten-thumbnailimg postShorten-thumbnailimg--bottom">
                    <img alt="" itemprop="image" src="https://blog.xgheaven.com/2021/01/02/the-quick-start-about-develop-nfc-in-mini-program/cover.jpeg"/>
                </div>
                
            
            
                <div class="postShorten-content" itemprop="articleBody">
                    <blockquote>
<p>本文主要是以「飞书」小程序为准，兼容「微信」小程序，如果没有了解过「飞书」的同学，可以<a href="https://www.feishu.cn/" target="_blank" rel="noopener">点击此处</a>去官网了解</p>
</blockquote>
<h2 id="什么是-NFC"><a href="#什么是-NFC" class="headerlink" title="什么是 NFC"></a>什么是 NFC</h2><p><strong>近距离无线通信</strong>（英语：Near-field communication，NFC），又简称<strong>近距离通信</strong>或<strong>近场通信</strong>，是一套通信协议，让两个电子设备（其中一个通常是移动设备，例如智能手机）在相距几厘米之内进行通信。</p>
<p>近场通信技术由非接触式射频识别（RFID）演变而来，由飞利浦半导体（现恩智浦半导体，缩写 NXP）、诺基亚和索尼共同于2004年研制开发，其基础是RFID及互连技术。近场通信是一种短距高频的无线电技术，在13.56MHz频率运行于20厘米距离内。其传输速度有106 Kbit/秒、212 Kbit/秒或者424 Kbit/秒三种。</p>
<p>NFC 其实在刚诞生的时候我就一直在关注，但是不仅仅应用少，而且搭载的设备也少，甚至小米还出现过前一代搭载 NFC 后一代却不搭载的神奇情况。除此之外，使用起来也是特别复杂，想当初，要用 NFC 去实现刷公交卡，你需要去换一个特殊的 SIM 卡才能够支持（当初不理解，现在想来大概率是因为安全问题）。</p>
<p>在现在，随着安卓厂商的不懈努力，现在不论是应用还是设备的安装率都已经逐渐普及开来。从最初 NFC 也就能在支付宝中扫银行卡快速输入卡号，到现在的公交刷卡、X Pay，甚至传输文件，华为甚至给这个东西换了个名字叫做一碰系统（率感无语）。</p>
<p>除此之外，还能推进智能化的发展。比如以后家庭中加入了一个新设备，那么不再需要繁杂的联网过程，直接扫一下机器身上的 NFC 识别码就可以直接将设备加入到家庭网络中。或者说华为路由器上的一碰连接 Wifi 我觉得就是一个极好的应用。当家里来客人的时候，就不再需要一个人一个人的输入密码了。</p>
<h2 id="NFC-技术一览"><a href="#NFC-技术一览" class="headerlink" title="NFC 技术一览"></a>NFC 技术一览</h2><h3 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a><strong>运行模式</strong></h3><p>NFC 现在主要有三种运行模式，分别是<strong>卡模拟模式</strong>（Card Emulation Mode）、<strong>主机模拟模式</strong>（Host Emulation Mode）、<strong>读卡写卡模式</strong>（Reader/Writer Mode）、<strong>P2P 模式</strong>（P2P Mode）</p>
<p><strong>卡模拟模式</strong></p>
<ul>
<li><p>NFC手机可以模拟成为一张非接触卡，通过 POS 机（非接触读卡器）的 RF 来供电，即使 NFC 手机没电也可以工作。</p>
</li>
<li><p>现在很常见的比如 Apple Pay，BYD NFC 钥匙，都是能够实现在断电情况下的刷卡</p>
</li>
</ul>
<img src="/2021/01/02/the-quick-start-about-develop-nfc-in-mini-program/7d10579f-6855-49b3-adca-4a1d4ffe1b6e.png">
<p><strong>主机模拟模式</strong></p>
<ul>
<li><p>该模式与卡模拟模式很类似，只不过卡模拟无需供电或者说无需 App 的参与就可以完成，但是主机模拟模式是不行的，他是通过将所有的消息转发给应用，由应用去决定该模拟什么内容，也就说该返回什么内容</p>
</li>
<li><p>现阶段很多支付钱包，比如云闪付、京东闪付等等都是通过该模式实现的。</p>
</li>
</ul>
<img src="/2021/01/02/the-quick-start-about-develop-nfc-in-mini-program/32aa547c-ce6a-40e1-8b2c-454dba2caa87.png">
<p><strong>读卡写卡模式</strong></p>
<ul>
<li><p>NFC手机可以通过触碰NFC标签（Tag），从中读取非接触标签中的内容，采集数据并发送到对应的应用进行处理。</p>
</li>
<li><p>最常见的应用其实就是华为的一碰系列，除此之外，支付宝支持直接读取信用卡、储蓄卡的卡号。</p>
</li>
</ul>
<img src="/2021/01/02/the-quick-start-about-develop-nfc-in-mini-program/2a9b4dd4-545c-43c5-8b37-104f9ea93403.png">
<p><strong>P2P 模式</strong></p>
<ul>
<li><p>两个NFC设备可以近距离内互相连接，直接传递数据，实现点对点数据传输。</p>
</li>
<li><p>例如协助快速建立蓝牙连接、交换手机名片和数据通信等。</p>
</li>
<li><p>最常见的是手机互传、Android Beam。</p>
</li>
</ul>
<img src="/2021/01/02/the-quick-start-about-develop-nfc-in-mini-program/6830ab77-4423-45d4-a4f2-30703d8ace5a.png">
<h3 id="协议标准类型"><a href="#协议标准类型" class="headerlink" title="协议标准类型"></a><strong>协议标准类型</strong></h3><p>因为 NFC 的发展过程的原因，曾经出现过多个协议，甚至每家公司都有不同的协议内容。但现在主要是有一下几个协议标准：</p>
<p><strong>ISO / IEC</strong></p>
<p>主要定义了一下几个协议：</p>
<ul>
<li><p>ISO/IEC 18092 / ECMA-340— (NFCIP-1)</p>
<p>Near Field Communication Interface and Protocol-1</p>
</li>
<li><p>ISO/IEC 21481 / ECMA-352— (NFCIP-2)</p>
<p>Near Field Communication Interface and Protocol-2</p>
</li>
</ul>
<p>除此以外，还有一个协议标准很常用，是 ISO-14443 协议，其实这个协议是 RFID 的协议，和上面的唯一区别就是上面的多了一些其他模式的标准，比如点对点模式。</p>
<p>ISO-14443 协议有两个子类，分别是 Type-A 和 Type-B，这两个在 Android 也被称为 NFC-A 和 NFC-B。</p>
<p>但不幸的是，这些协议也不能免费看，要花钱的</p>
<p><strong>NFC Forum</strong></p>
<p><a href="https://nfc-forum.org/" target="_blank" rel="noopener">NFC Forum</a> 是一个在 2004 年创建的非盈利行业协会，其成员来自NFC生态系统的各个部分。另外我主要关注了下国内公司，比较知名的有小米、中国移动通讯。</p>
<p>但是你想要从该组织获取任何关于 NFC 相关的技术标准，首先你的公司要成为该组织的成员才行，因为字节根本不在该组织，所以没法从这里获得一手的信息。</p>
<p>不过办法也是有的，该协会的创办者 NXP 公司网站上是有相关的数据资源，后文的参考此资源。</p>
<p><strong>其他</strong></p>
<p>不用管.jpg</p>
<h3 id="沟通协议"><a href="#沟通协议" class="headerlink" title="沟通协议"></a><strong>沟通协议</strong></h3><p>以 NFC-A 为例</p>
<img src="/2021/01/02/the-quick-start-about-develop-nfc-in-mini-program/f4d39ae5-9c5e-4f4e-8b22-9cbc17cedd14.png">
<p>整个 NFC 卡片其实内部就是一个有限状态机，根据当前不同的状态需要不同的操作。这个图看起来很复杂，其实主要额外包含了两个操作：</p>
<ul>
<li><p>密码校验</p>
<ul>
<li><p>这个是说 NFC 卡是经过加密的，只有在密码校验通过之后，才能够进行相关的操作。</p>
</li>
<li><p>有一点特殊的是，NFC 的密码长度其实是固定的，即 32 位，4 个字节。</p>
</li>
</ul>
</li>
<li><p>防冲突</p>
<ul>
<li><p>之所有有这个设计，是因为在使用过程中，可能会出现同时扫描到多个 NFC 设备的情况，此时就需要通过 READY1/READY2 两个状态来选择正确的 NFC 设备进行操作。</p>
</li>
<li><p>每个卡片都有一个唯一 UID，长度为 7 字节，而每次操作只能选择 4 个字节，所以不得不拆分成两个状态两步去操作。</p>
</li>
</ul>
</li>
</ul>
<p>当没有上面两个操作的时候，可以简单的执行 IDLE -&gt; ACTIVE -&gt; HALT 的状态流程，也就是说连接、操作（也就是读写）、关闭。</p>
<h3 id="存储设计"><a href="#存储设计" class="headerlink" title="存储设计"></a><strong>存储设计</strong></h3><p>NFC 在存储上设计了页的概念，一个页表示 4 个字节，以页为最小单位进行操作。所以 NFC 卡片的存储容量其实都是 4 的整数倍。</p>
<p>这里以 NTAG213 180 字节的存储结构为例</p>
<img src="/2021/01/02/the-quick-start-about-develop-nfc-in-mini-program/d818bba2-d78d-48eb-aae8-94d54e0ed449.png">
<p>这里只需要关注两点：</p>
<ul>
<li><p>用户数据存储的空间是从第四页开始</p>
</li>
<li><p>用户可存储空间其实只有 144 字节</p>
</li>
</ul>
<p>只需要记住这两点，在开发 NFC 需求的时候，不要去修改非用户空间的数据，不要存储过长的内容。</p>
<h2 id="设备准备"><a href="#设备准备" class="headerlink" title="设备准备"></a>设备准备</h2><p>在有了上面的基础之后，别急你还是不能开始开发 NFC，因为你还缺少至关重要的一个东西，设备</p>
<p>遗憾的是，不是所有的设备都有 NFC 硬件的，也不是说有了 NFC 硬件就能用的</p>
<ul>
<li><p>苹果设备只有升级到 iOS 13 以上才能具有开发 NFC 读卡器的能力，不能写入，除此之外，几乎没有其他的 NFC 能力可以使用。机圈也会叫做阉割版 NFC。（暂时没有能力去调研 NFC 的能力一定是需要硬件支持还是说只是软件限制）</p>
</li>
<li><p>安卓设备理论上可以使用几乎所有的 NFC 能力，机圈内叫全功能 NFC，包括读卡、写卡、卡模拟、P2P 等模式。但是不同的手机有着不同的操作系统的限制，所以要选择一个合适的操作系统（原生安卓、类原生安卓是最推荐的）。</p>
</li>
</ul>
<p>所以，请准备好一台安卓手机！</p>
<h2 id="NFC-卡片"><a href="#NFC-卡片" class="headerlink" title="NFC 卡片"></a>NFC 卡片</h2><p>在有了设备之后，还要选择正确的 NFC 卡片，因为不是任意一个 NFC 卡片都是可以用的，比如工牌、银行卡等等。这是因为 NFC 卡片是带有加密的，在操作之前必须要通过验证才能操作，所以建议去淘宝买一些可读可写无加密的 NFC 贴纸用于测试。</p>
<p>不过你在淘宝上买的可能是写着 NTAG213 的型号，其实这个是 NXP 出的一款设备，但是支持兼容 ISO NFC-A 协议以及 NFC Forum Type 2 协议，所以大家可以放心使用。</p>
<p>当然了，你也可能看到 NTAG215/NTAG216，这两个都没有任何区别，只是存储空间不同而已。</p>
<img src="/2021/01/02/the-quick-start-about-develop-nfc-in-mini-program/9593b7a1-4bec-492e-8d87-ebf66c65e8b2.png">
<h2 id="小程序-API"><a href="#小程序-API" class="headerlink" title="小程序 API"></a>小程序 API</h2><p>此时在有了上述的基础知识后，别急，还要了解下小程序的 API 才能更好的开发。</p>
<p>就目前来说，所有与 NFC 相关的操作都被封装到了 <code>NfcAdaptar</code> 类中，通过 <code>tt.getNFCAdaptar()</code> 获取 <code>nfcAfaptar</code> 对象。</p>
<blockquote>
<p>具体的 API 参数细节请参考「<a href="https://open.feishu.cn/document/uYjL24iN/ugTN4YjL4UDO24CO1gjN" target="_blank" rel="noopener">飞书开放平台</a>」</p>
</blockquote>
<h3 id="NFC-整体流程"><a href="#NFC-整体流程" class="headerlink" title="NFC 整体流程"></a><strong>NFC 整体流程</strong></h3><ul>
<li><p>注册 NFC 发现事件回调 <code>nfcAdaptar.onDiscovered</code></p>
</li>
<li><p>开启 NFC 扫描 <code>nfcAdaptar.startDiscovered</code></p>
</li>
<li><p>NFC 卡片贴近设备</p>
</li>
<li><p>触发回调，通过回调可以获得 NFC 支持的协议</p>
<ul>
<li>回调参数内的 techs 字段可以用于判断当前卡片支持的协议</li>
</ul>
</li>
<li><p>根据协议去读写 NFC 卡片内容 <code>nfcAdaptar.getNfcA()</code></p>
</li>
<li><p>关闭 NFC 扫描，关闭事件监听 <code>nfcAdaptar.offDiscovered</code> / <code>nfcAdaptar.stopDiscovered()</code></p>
</li>
</ul>
<p>可以发现这个流程非常容易理解，也非常容易操作。那么接下来我们看下重头戏</p>
<h3 id="读写-NFC-卡片"><a href="#读写-NFC-卡片" class="headerlink" title="读写 NFC 卡片"></a><strong>读写 NFC 卡片</strong></h3><p>这里以 NFC-A 协议为主</p>
<p>通过 <code>nfcAdaptar.getNfcA()</code> 获取操作 NFC-A 卡片的操作类实例 nfca，流程如下</p>
<ul>
<li><p>连接卡片 <code>nfca.connect()</code></p>
</li>
<li><p>读写卡片 <code>nfca.transceive()</code></p>
</li>
<li><p>读写完成之后关闭连接 <code>nfca.close()</code></p>
</li>
</ul>
<p>关键点来了，NFC 卡片的读写不和其他的 IO 设备类似，有专门的 read 和 write 函数。对 NFC 来说，通过给 NFC 卡片发送不同的指令来做到完成不用的操作。</p>
<p>这些指令都在 NTAG213 文档中有写，这里简单列一下常用的数据</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>代码</th>
<th>功能</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read</td>
<td>0x30</td>
<td>一次读取四个页的数据</td>
<td><code>&lt;Addr:1B&gt;</code></td>
</tr>
<tr>
<td>Write</td>
<td>0xA2</td>
<td>一次写入一个页的数据</td>
<td><code>&lt;Addr:1B&gt; &lt;Data:4B&gt;</code></td>
</tr>
<tr>
<td>Fast Read</td>
<td>0x3A</td>
<td>一次读取多个页的数据</td>
<td><code>&lt;StartAddr:1B&gt; &lt;StopAddr:1B&gt;</code></td>
</tr>
</tbody>
</table>
<p>比如我要读取第四页的数据，可以写如下代码</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nfca.transceive(&#123;</span><br><span class="line">    data: <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0x30</span>, <span class="number">0x04</span>]).buffer, <span class="comment">// 必须要传入 ArrayBuffer</span></span><br><span class="line">    success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// res.data 是 ArrayBuffer，转成数组方便查看</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(res.data))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>根据协议，其实还要传 <a href="CRC:2B" target="_blank" rel="noopener">CRC:2B</a>，也就是校验位，不过这个操作已经由 Android 去做掉了，所以就不需要传了，也不需要去了解校验算法</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此，NFC 开发算是入门了，不过这里要注意不同的 NFC 卡片不同的协议会有不同的读写方式，这里要根据你们各自具体的卡片来看。而且有的还有密码保护，还需要额外再走校验的逻辑。</p>
<h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><ul>
<li><p><a href="https://blog.csdn.net/xiaozy115/article/details/103171143" target="_blank" rel="noopener">NFC 简介 - CSDN</a></p>
</li>
<li><p><a href="https://bitexperts.com/Question/Detail/3360/difference-between-iso-14443-and-iso-18092-i-e-rfid-vs-nfc" target="_blank" rel="noopener">Difference between ISO 14443 and ISO 18092, i.e. RFID vs NFC</a></p>
</li>
<li><p><a href="https://www.nxp.com.cn/docs/en/data-sheet/NTAG213_215_216.pdf" target="_blank" rel="noopener">NTAG213 协议文档</a></p>
</li>
</ul>

                    
                        

                    
                    
                        <p>
                            <a href="/2021/01/02/the-quick-start-about-develop-nfc-in-mini-program/#post-footer" class="postShorten-excerpt_link link">
                                注释和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">第 1 页 共 1 页</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2023 XGHeaven. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="https://www.gravatar.com/avatar/f34474afe04544ffbe944a804f0ae762?s=110"/>
        
            <h4 id="about-card-name">XGHeaven</h4>
        
            <h5 id="about-card-bio"><p>一个弱弱的码农</p>
</h5>
        
        
            <h5 id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>杭州电子科技大学学生一枚</p>

            </h5>
        
        
            <h5 id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                Weifang Shandong, China
            </h5>
        
    </div>
</div>

        
<div id="cover" style="background-image:url('/static/images/20170217-TombRaider.jpg');"></div>
    </body>
    <!--SCRIPTS-->

<script src="/assets/js/scrip-z6xcdnzggiy56kzp83ux5nnbwra1acrauxruz3kdi3u5xladb6jh4n3ylebm.min.js"></script>

<!--SCRIPTS END-->



</html>
