<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XGHeaven&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.xgheaven.com/"/>
  <updated>2023-09-16T15:51:09.894Z</updated>
  <id>https://blog.xgheaven.com/</id>
  
  <author>
    <name>XGHeaven</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>返璞归真「DOM」兼容接口的引入让飞书小程序性能获得 2 倍以上的提升</title>
    <link href="https://blog.xgheaven.com/2023/06/14/use-dom-to-improve-double-performance-in-mini-program/"/>
    <id>https://blog.xgheaven.com/2023/06/14/use-dom-to-improve-double-performance-in-mini-program/</id>
    <published>2023-06-13T16:00:00.000Z</published>
    <updated>2023-09-16T15:51:09.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>小程序，作为新一代的应用开发方式，虽然在业务上已经证明了巨大的价值，但是在开发者友好性上却非常的差，例如框架难用，调试困难，跨平台兼容性差。本文便是在尝试提高针对视图的开发者友好性和兼容性，同时进一步提升性能。</p><p>为了能够更好的理解本文，需要您最好了解以下内容：</p><ul><li><p>有小程序相关的经验，能够理解基本小程序的架构、基本的框架使用方式、主流的跨端三方框架等</p></li><li><p>有前端相关的经验，能够理解什么是 DOM 接口，以及如何操作 DOM 接口</p></li></ul><p>本文将不再赘述过多的基础概念内容。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>目前本人任职飞书开放平台小程序组，负责小程序相关的运行时的工作内容。由于飞书对小程序有着一些特殊的需求：</p><ol><li><p>飞书大量官方应用都是通过小程序承载的，这些应用对运行体验和开发效率有着远比外界更高的要求。而且由于是官方应用，且只服务于飞书，所以他们对于小程序的跨端兼容性要求并不高。这也给了我们更大的灵活性去设计更好的方案。</p></li><li><p>飞书是一个面向全球 B 端的市场，先不论国内是否每个 B 端企业都能有精力去开发小程序，单论海外市场对小程序的认知就非常浅薄。所以如何尽可能的降低小程序的认知学习门槛，降低接入成本，就显得尤为重要。在国内可以通过类似于 Taro 的框架，但是海外这部分的学习成本依旧很高，所以需要有新的方式去降低这部分的成本。</p></li></ol><p>正是因为如此，我们这边决定不再以兼容社区小程序的方案为首要目标，而是转为提高开发者的开发体验和运行性能为主目标去进行设计和优化。</p><h1 id="现有架构的「病区」"><a href="#现有架构的「病区」" class="headerlink" title="现有架构的「病区」"></a>现有架构的「病区」</h1><p>小程序在诞生之后，其实做了很多的设定，有的设定是合适的，但更多的设定在逐渐的发展过程中变得不再合适，而后人却依旧沿着这个思路和方向去做。接下来，让我们重新思考一下这些设定：</p><h2 id="为什么会诞生-XXML-的视图开发方案？"><a href="#为什么会诞生-XXML-的视图开发方案？" class="headerlink" title="为什么会诞生 XXML 的视图开发方案？"></a>为什么会诞生 XXML 的视图开发方案？</h2><blockquote><p><code>XXML</code> 在这里是对通过模板开发小程序的一种开发范式（也可以叫开发框架或者 DSL）的统称。因为不同宿主内对应的模板文件的后缀不同，但都有 <code>ML</code> 而因此得名。例如微信是 <code>.wxml</code> ，支付宝是 <code>.axml</code>，而飞书和抖音则为 <code>.ttml</code>。</p></blockquote><p>在我的认知中，小程序最开始并不是为资深的前端开发而设计的，相反，他是为了客户端乃至一些没有开发经验的人所设计。</p><p>所以借鉴了 Vue 这类非常容易入门的社区框架，再结合上小程序自身的需求所定制了一套 DSL。这套 DSL 针对从来没有写过前端的人来说，确实算是非常友好的，几乎不需要学习就可以上手。</p><p>其实让开发者更容易的入门上手算是小程序最开始的目标。例如，一开始是不提供 CLI 工具只提供了可视化的 IDE。如果小程序的受众是不懂开发的人，那其实没问题。</p><p>但最终事与愿违，开发小程序最多的人其实就是资深的前端开发，在前端开发的视角来看，这套 DSL 可以用一坨屎来形容。而小程序又必须要要用这套 DSL 去开发，就导致每一个写过小程序的人必须吃一次这个屎。</p><h2 id="XXML-会带来什么问题？"><a href="#XXML-会带来什么问题？" class="headerlink" title="XXML 会带来什么问题？"></a>XXML 会带来什么问题？</h2><p>虽然以微信为首的厂商做了很多能力去补救，尽可能在保证较低入手门槛的情况下，不断丰富能力，提高对前端开发人员的友好程度。但最开始的设计就不是面向这部分人群，即使后面修补的再多也无济于事了。这其中所带来的的问题随着小程序的发展而愈发严重：</p><ul><li><p>由于这套框架的实现是内置在基础库内，其能力和功能的实现必然有滞后性，同时灵活度差。一旦框架概念落后，开发者将不得不继续咬牙学习落后内容。</p></li><li><p>虽然最开始借鉴自 JS 和 Web，但最终却无法的很好的利用开源社区的能力，几乎所有都要重造轮子。国内已经发展了这么多年，社区才将将都造完稳定的轮子，如果将这一套推向海外，那成本根本无法估量。</p></li><li><p>规范缺乏一致性。由于 XXML 本身其实是一个业务开发框架，但又作为唯一开发方式，非常容易变得越来越臃肿和随意，可能一个实习生随便定出的接口都将会影响整个社区，能力的实现也缺乏一致性。例如 <code>Page</code> 和 <code>Component</code> 的生命周期就非常不一样。</p></li><li><p>为了解决 XXML 这些问题，降低开发者的开发成本，在社区中诞生了许许多多的三方跨端框架。导致开发小程序的人不仅仅要懂得如何写原生的 XXML，更要懂得如何使用这些跨端框架，学习成本陡增。</p></li><li><p>Taro 这类模拟一套 DOM 接口来嫁接社区框架的做法，最终会让运行架构变成 <code>React =&gt; Taro DOM =&gt; TTML =&gt; DOM</code> 这种有点脱裤子放屁的方式。</p></li></ul><h2 id="小程序的视图开发一定要使用-XXML-么？"><a href="#小程序的视图开发一定要使用-XXML-么？" class="headerlink" title="小程序的视图开发一定要使用 XXML 么？"></a>小程序的视图开发一定要使用 XXML 么？</h2><p>一个支持通用应用的宿主，可以提供一套它认为合适的模板 DSL 去生成渲染树，但一定也需要提供一套更加灵活的方式去生成渲染树。例如：</p><ul><li><p>安卓默认使用 XML 作为模板，去渲染内容。但如果不满足使用，同时可以使用命令的操作方式去构建一个渲染树。iOS 也是用类似的逻辑</p></li><li><p>Flutter 定义了一套类似于 React 的 Weight 渲染框架。但依旧暴露了底层的 RenderObject 方便开发者绕过 Weight 直接去构建渲染树。</p></li></ul><p>而小程序，却选择了只提供 XXML，并没有提供其他的方式。如果小程序面向的特定需求场景，这倒也无可厚非，可实际上小程序面向的却是通用需求场景。</p><p>于是飞书内部在思考，如果我们一定要再提供一套通用的 DSL，会是什么？React、Vue 这类前端框架么？如果提供了，又会面临和 XXML 类似的局面。</p><p>其实在 Web 领域中，早就给出了答案，那么就是 DOM。不管是 React 还是 Vue 还是其他的框架，底层都是基于 DOM 接口所存在的。如果我们能够在小程序提供一套底层的 DOM 接口，那么 XXML 所带来的问题是不是就全都迎刃而解了呢？</p><h2 id="为什么之前不提供-DOM-接口？"><a href="#为什么之前不提供-DOM-接口？" class="headerlink" title="为什么之前不提供 DOM 接口？"></a>为什么之前不提供 DOM 接口？</h2><p>当我们想明白这个点之后，其实就会更加好奇，为什么这么简单的想法为啥一开始乃至后续的人都没做过呢？</p><p>我猜测最开始不这么做的原因有这么几个，但我觉得都不是很成立，或者说在飞书的场景中很难成立（如果大家有不同的想法和意见，随时可以和我沟通交流）。</p><blockquote><p>Q: 无法完整实现，成本高。<br>双线程无法实现完整的 DOM 接口，且在逻辑层实现一套 DOM 接口的成本过高。</p></blockquote><p>确实，如果想要一比一的复刻 DOM 接口，有些依赖渲染能力的接口确实无法实现。但如果只是实现一套子集，能够满足主流框架的使用，那么成本和难度并不高。比如 Taro 就是这么做的，社区也证明了其可行性。</p><blockquote><p>Q: 首屏性能差。<br>如果实现 DOM 接口，就必须要等待逻辑层完整渲染并操作完 DOM 接口之后，渲染层才能渲染，那么将失去双线程逻辑层和渲染层并行运行的优势。</p></blockquote><p>我觉得这个是一个屁股决定脑袋的事情。在 90% 的场景中，渲染层就是需要等待逻辑层计算完毕之后才能渲染的。就像是你不能说为了前端页面首屏速度快，要求所有网站都用 SSR 吧。</p><p>另外，首屏其实分为 FP 和 TTI 的，和 SSR 场景类似，XXML 可以做到 FP 快，但是 TTI 并不如 DOM 快的。飞书场景更在乎的是 TTI 而非 FP，所以影响不大。</p><p>再说，用了 DOM 接口之后自然是有对应的优化策略和方式的。</p><blockquote><p>Q: DOM 指令的通讯压力大。<br>如果采用 DOM 接口，那么逻辑层往渲染层发送的将是 DOM 指令，如果我要渲染 100 个普通的 view，这部分体积明显比直接发送 data 要大。</p></blockquote><p>没错，某些场景下，DOM 指令的数量确实是会比 data 体积大。</p><p>但是在飞书的业务场景中，通常都会有着重度的逻辑以及大量国际化文案，这部分会导致 data 的体积飞涨。而且并不是所有的开发都有合理使用 data 的能力的，有些人就喜欢啥都往 data 里面塞，这更加会加剧其体积的膨胀。</p><p>所以对于飞书来说，这个的影响其实并不大。</p><blockquote><p>Q: 觉得 TTML 就够用了</p></blockquote><p>懂的都懂，不多说了</p><blockquote><p>Q: 不希望对外认知上小程序就是前端，所以在一定程度上屏蔽了前端所用的东西。</p></blockquote><p>我觉得这其实是微信小程序的烟雾弹，让大家觉得小程序技术很厉害，它底层是 Native 实现，只是借鉴了前端的一些概念而已。</p><p>但实际上缺恰恰相反，从设计开始，就是在 Web 上面打补丁实现的，只是借鉴了一点点 Native 中的概念。</p><p>所以如果相信了这个烟雾弹，那么才是将自己埋入深坑。</p><blockquote><p>Q: 不希望利用 DOM 接口实现太多灵活的动态更新能力。<br>例如审核之后通过 API 更改 UI 界面。</p></blockquote><p>这个也是我见过最多的说法了，也是最站不住脚的说法。<br>XXML 本身就无法避免动态更新，更别说 DOM 了。</p><blockquote><p>Q: DOM 接口就不会有实现上的兼容问题了么？</p></blockquote><p>这是个好问题，虽然 DOM 接口本身是有标准的，但实现上其实各家都会遇见的不一样。</p><p>这个自然没有完美的解决方案，但是我觉得以兼容主流框架而不是提供完整兼容的 DOM 接口为目标是更加合理的。不管各家接口实现成什么样子，只要能兼容前端框架就是对的。</p><p>至此，其实我们可以看到，DOM 接口本身的引入并不存在什么实质性的阻碍。</p><p>而且最重要的事，DOM 本身是作为 XXML 的一种补充开发能力所引入的，每个开发者可以根据自己的架构特点选择 XXML 甚至的 DOM 来作为开发方式。</p><h2 id="提供-DOM-接口能带来哪些好处？"><a href="#提供-DOM-接口能带来哪些好处？" class="headerlink" title="提供 DOM 接口能带来哪些好处？"></a>提供 DOM 接口能带来哪些好处？</h2><p>最后的最后，我们其实要明白，如果要提供 DOM 接口，将会带来那些好处呢？</p><ul><li><p>能够几乎无缝的兼容市面上主流的前端框架，目前测试下来支持的有 <code>Vue</code> <code>Svelte</code> <code>React18</code>。极大的降低开发者的学习和开发成本。</p></li><li><p>可以提供极致的性能优化，做到非常细粒度的组件更新。</p></li><li><p>和前端主流开发方式对齐，不再分割与割裂，提高开发效率和降低接入成本。</p></li><li><p>针对三方的跨端框架，可以降低其兼容难度和运行时的体积，提高执行效率。</p></li></ul><p>最关键最关键的是，终于可以抛弃掉 XXML 这套恶心的东西了。没有难用的数据绑定，支持传递函数，不需要考虑 data 内数据是否是视图需要的，自定义组件之间的时序能够得到天然的保障，能够支持 CSS-In-JS 等等。</p><p>社区中很多优秀的方案都可以拿来使用，总之，就是优雅，优雅，还是优雅。</p><h1 id="全新架构"><a href="#全新架构" class="headerlink" title="全新架构"></a>全新架构</h1><p>在理解了上文所讲述的内容之后，就该讲解下我们为了实现上面的功能所做的全新架构了：</p><img src="/2023/06/14/use-dom-to-improve-double-performance-in-mini-program/2810ea5d-ab90-4fb8-8f26-fa101d2b26b8.png"><p>最简单的理解，就是在新架构中，渲染层和逻辑层之间的通讯不再发送 data 了，而是通过逻辑层实现的一套 DOM 接口，将其转换成 DOM 的操作指令。</p><p>如果说渲染的操作是 <code>fn(data)</code> 的过程，那么以前这个过程是在渲染层完成，而新架构下，这个操作将在逻辑层完成。</p><p>在新架构中，依旧保留了对原先 XXML 的兼容性，开发者可以通过 <code>renderingModel</code> 控制。控制以 Page 为粒度，保证在开发中可以做到渐进式迁移。另外，DOM 接口与 XXML 只能二选一，两者无法在一个 Page 上同时开启。</p><blockquote><p>我并不认为提供 Page 级别的控制在技术设计上是一个好方案，但这个方案确实是可以最大程度上提供更好的兼容性，方便开发者渐进式的替换。</p></blockquote><h2 id="Document-结构"><a href="#Document-结构" class="headerlink" title="Document 结构"></a>Document 结构</h2><p>当开启 DOM 的渲染模型之后，整个小程序的文档模型都将与 Web 有着极其类似的结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> <span class="comment">&lt;!-- document.documentElement 一般不会用到这个 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="comment">&lt;!-- document.head --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 可以在这里利用 meta 标签配置一些全局内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span> <span class="comment">&lt;!-- document.body --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">page</span> <span class="attr">route</span>=<span class="string">"xxx"</span>&gt;</span> <span class="comment">&lt;!-- Page 实例所对应的渲染节点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">page</span> <span class="attr">route</span>=<span class="string">"xxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">page</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>例如每一个 Page 都对应着 <code>document.body</code> 内的一个 <code>&lt;page/&gt;</code> 元素。页面栈也与 <code>document.body.childNodes</code> 保持一致，页面栈的进出相当于 page 元素的插入和剥离。</p><p>当然，这里只是一个类比，实际上会有些许的不同，本文不再展开（其实就是我还没设计好，这是个预期模型）。</p><h2 id="小程序内置组件"><a href="#小程序内置组件" class="headerlink" title="小程序内置组件"></a>小程序内置组件</h2><p>小程序内置组件在 DOM 接口下名字、属性、使用方式依旧保持不变，并且遵守 Web 的通用规范。提供了对应的 DOM Interface 方便开发者直接操作和使用。例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tagName 都是和 XXML 内保持一致</span></span><br><span class="line"><span class="keyword">const</span> view = <span class="built_in">document</span>.createElement(<span class="string">'view'</span>)</span><br><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>)</span><br><span class="line"><span class="keyword">const</span> picker = <span class="built_in">document</span>.createElement(<span class="string">'picker'</span>)</span><br><span class="line"><span class="keyword">const</span> pickerView = <span class="built_in">document</span>.createElement(<span class="string">'picker-view'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性名字也与原先的保持一致，只不过当用作属性的时候，需要将其转换成驼峰的格式。</span></span><br><span class="line">button.openType = <span class="string">'share'</span></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">button.setAttribute(<span class="string">'open-type'</span>, <span class="string">'share'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原先组件的使用方式依旧不变，例如 picker-view 下面需要插入 picker-view-column</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">pickerView.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'picker-view-column'</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当需要赋值非字符串类型的值的时候，尽量使用 property 的方式</span></span><br><span class="line">picker.range = [[<span class="string">'a'</span>, <span class="string">'b'</span>], [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 attribute 可能会得到预期以外的行为，不推荐使用</span></span><br><span class="line">picker.setAttribute(<span class="string">'range'</span>, [...])</span><br></pre></td></tr></table></figure><p>或许有人会问，为什么使用了 DOM 接口缺不能使用前端的组件呢？</p><p>这是因为小程序的组件体系确实是比较特殊的，目前暂时没有很好的办法去兼容。但是在未来，可能会选择开放部分 Web 的组件，例如 <code>div</code> <code>span</code> <code>svg</code> 等。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><blockquote><p>目前该方案还在内部开发阶段，外部没有全量发布。下文中提到的所有接口都属于不稳定接口，在没有正式对外前，只能作为参考。</p></blockquote><p>可能看完上面之后大家依旧会是一头雾水，我这里通过一个简单的 DEMO 来让大家有更加清晰的认识。</p><ol><li>打开飞书开发者工具中的新框架开关</li></ol><img src="/2023/06/14/use-dom-to-improve-double-performance-in-mini-program/81901ab6-dc9d-4c37-be46-4185af09f593.png"><ol><li>在要开启 DOM 接口的 Page 所对应的 JSON 中添加 <code>renderingModel</code> 为 <code>dom</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"renderingModel"</span>: <span class="string">"dom"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>此时可以在 Page 的 <code>onLoad</code> 生命周期内通过 <code>this.pageElement</code> 获取到 Page 的元素实例了，可以将其理解为前端开发中的 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code> 元素。后续就可以按照前端开发流程去操作这个元素了</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  onLoad() &#123;</span><br><span class="line">    <span class="keyword">const</span> root = <span class="keyword">this</span>.pageElement</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以直接控制页面渲染</span></span><br><span class="line">    <span class="keyword">const</span> view = <span class="built_in">document</span>.createElement(<span class="string">'view'</span>) <span class="comment">// 这里不能使用 Web 组件，只能使用小程序组件</span></span><br><span class="line">    view.style = <span class="string">'color: blue;'</span> <span class="comment">// style 只能设置不能读取，读取到的值是不准确的</span></span><br><span class="line">    view.className = <span class="string">'root'</span></span><br><span class="line">    view.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Hello world'</span>))</span><br><span class="line">    root.appendChild(view)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者使用主流前端框架进行渲染</span></span><br><span class="line">    React.createRoot(root).render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>) <span class="comment">// JSX 小程序不支持，需要进行转换，这里只是举例</span></span><br><span class="line">    <span class="comment">// 或</span></span><br><span class="line">    Vue.createApp(App).mount(root)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>其他的例如样式、API 等与普通小程序无异。样式依旧通过 XXSS 使用，API 则继续可以使用 <code>tt</code> 如果在飞书内的话。</li></ol><h1 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h1><p>性能自然是为什么要引入 DOM 最重要的一个因素了，让我们来看一下性能对比测试</p><h2 id="测试方式"><a href="#测试方式" class="headerlink" title="测试方式"></a>测试方式</h2><p>仓库：<a href="https://github.com/XGHeaven/perf-gadget-dom-vs-framework" target="_blank" rel="noopener">https://github.com/XGHeaven/perf-gadget-dom-vs-framework</a></p><p>使用 Vue3 的框架，Demo 使用 <a href="https://github.com/mdn/todo-vue" target="_blank" rel="noopener">mdn/todo-vue</a>，在此基础上使用了 Taro 将代码分别编译到飞书、微信、支付宝。</p><ul><li><p><code>taro-wx</code> Taro 编译到微信，微信版本为 <code>8.0.35</code></p></li><li><p><code>taro-alipay</code> Taro 编译到支付宝，开启 2.0 lib，支付宝版本为 <code>10.3.80</code></p></li><li><p><code>taro-tt</code> Taro 编译到抖音(Tiktok)，抖音版本为 <code>25.5.0</code></p></li><li><p><code>taro-lark</code> Taro 编译到飞书，飞书版本为 <code>6.5.3</code></p></li><li><p><code>dom-lark</code> Vue 源码直接编译到飞书新架构 DOM 接口上，飞书版本为 <code>6.5.3</code></p></li></ul><p>每一个测试项目，有 5 次的预热运行，之后会再运行 10 次，取其平均值。同时每次运行之间都会相隔一段时间，保证系统有时机去做别的事情，从而尽可能避免影响到测试结果。</p><blockquote><p>之所以选择 Taro 而非 XXML 原生写法或者其他跨端框架，其一是因为更加接近于开发者的使用体验，因为不可能有人会选择直接去操作 DOM。其二是因为 Taro 已经是最快的跨端框架了，再比较其他的没有什么太多的意义。</p></blockquote><p>除此以外，其他的内容基本一致：</p><ul><li><p>测试设备为华为 P40 Pro，麒麟 990 处理器，鸿蒙 OS 3.0 系统。</p></li><li><p>Taro 框架统一经过 build:xx 命令后运行，Vue 直接通过 Vite 编译后运行</p></li><li><p>运行方式都是打开对应平台的开发者工具并上传之后，在后台生成对应的二维码扫码预览，避免被认为是开发状态从而添加对结果有影响的能力。</p></li></ul><p>由于 Taro 框架以及飞书新架构的情况下，组件的 <code>mounted</code> 生命周期只能保证在逻辑层侧完成了渲染，不能保证此时组件更新指令已经发送到渲染层，我们需要寻找一个全新的方式去衡量什么时候组件真正渲染上屏。</p><p>幸运的是，<code>image</code> 组件有一个特性，当图片被渲染出来并成功加载之后，会触发 <code>load</code> 事件，当此事件触发的时候，可以认为组件已经正确被渲染到屏幕上了。此时，我们只需要在某次更新组件的最后一个组件内，插入一个高宽为 0 的 <code>image</code> 组件作为渲染标记，当事件被触发时，就可以测量出整体的渲染时间。</p><p>虽然图片加载会占用一定的时间，但资源本身就是离线保存在代码包内，加载速度很快，且这并不影响最终结果的相对大小。</p><blockquote><p>Taro 默认关闭资源内联功能，避免 Taro 将小资源文件内联成 base64 字符串从而增大通讯成本。</p></blockquote><h2 id="测试内容"><a href="#测试内容" class="headerlink" title="测试内容"></a>测试内容</h2><p>这里还需要再补充几点：</p><ul><li><p>不测试应用首屏的性能，由于首屏开始的时间点不同宿主下测量会是不一样的，所以我只在私下里在飞书上通过录屏测试过 Uniapp 对比 DOM，差不多 DOM 可以快 300ms。如果采用 Taro 理论上差距会缩小，但是依旧是快的。</p></li><li><p>而且首屏性能主要由 JS Parse 和 Execution 的时间组成，这两部分分别由包体积和渲染性能决定，可以分别对比这两项测试从而大体可以得出首屏的性能。</p></li><li><p>不包含纯静态内容，因为测试使用的是 Taro 框架，其会在逻辑层搞一套虚拟 DOM，会导致最终发送给渲染层的数据量其实基本一致，测试的意义不大。如果有需要，后续可以对比 DOM 和 XXML 的在纯静态内容上的速度差异。</p></li></ul><h3 id="列表组件渲染"><a href="#列表组件渲染" class="headerlink" title="列表组件渲染"></a>列表组件渲染</h3><p>渲染 100 个 Todo 项，记录对应的耗时</p><ul><li><p>mounted 耗时，指从组件 created 到 mounted 所花费的时间</p></li><li><p>完整渲染耗时，指从组件 created 到渲染层上屏渲染完毕（图片 onload 触发）所花费的时间</p></li></ul><table><thead><tr><th>目标</th><th>mounted 耗时</th><th>完整渲染耗时</th></tr></thead><tbody><tr><td>taro-wx</td><td>141.3 (156%)</td><td>1457.4 (443%)</td></tr><tr><td>taro-alipay</td><td>141.1 (156%)</td><td>387.2 (177%)</td></tr><tr><td>taro-tt</td><td>148.5 (165%)</td><td>608.7 (185%)</td></tr><tr><td>taro-lark</td><td>140.8 (156%)</td><td>620.6 (188%)</td></tr><tr><td>dom-lark</td><td>89.9 (100%)</td><td>328.9 (100%)</td></tr></tbody></table><h3 id="列表组件内部更新"><a href="#列表组件内部更新" class="headerlink" title="列表组件内部更新"></a>列表组件内部更新</h3><p>将 Todo 项内的每一个 checked 进行反转，记录耗时</p><table><thead><tr><th>目标</th><th>完整渲染耗时</th></tr></thead><tbody><tr><td>taro-wx</td><td>1374.5 (2220%)</td></tr><tr><td>taro-alipay</td><td>138.7 (224%)</td></tr><tr><td>taro-tt</td><td>205.3 (331%)</td></tr><tr><td>taro-lark</td><td>231.7 (374%)</td></tr><tr><td>dom-lark</td><td>61.9 (100%)</td></tr></tbody></table><h3 id="体积比较"><a href="#体积比较" class="headerlink" title="体积比较"></a>体积比较</h3><ul><li><p>核心逻辑，只包含样式、JS、XXML、SJS 的大小，不包含图片文件，json 等</p></li><li><p>整包大小，包含图片资源、JS、CSS等整个包的大小</p></li></ul><table><thead><tr><th>目标</th><th>核心逻辑</th><th>整包大小</th></tr></thead><tbody><tr><td>taro-wx</td><td>308K (452%)</td><td>336K (323%)</td></tr><tr><td>taro-alipay</td><td>256K (376%)</td><td>276K (265%)</td></tr><tr><td>taro-tt</td><td>248K (364%)</td><td>272K (261%)</td></tr><tr><td>taro-lark</td><td>248K (364%)</td><td>272K (261%)</td></tr><tr><td>dom-lark</td><td>68K (100%)</td><td>104K (100%)</td></tr></tbody></table><h3 id="测试解读"><a href="#测试解读" class="headerlink" title="测试解读"></a>测试解读</h3><ul><li><p>微信不知为何，性能表现非常差，我也不再倾向于继续和它进行对比，否则数据会非常夸张。</p></li><li><p>采用 DOM 接口的开发方式，可以简化掉繁重的 Taro runtime 的实现，从而在速度和体积上获取一定的优势。</p></li><li><p>相比飞书自身，各种情况下速度至少可以提高一倍以上，体积可以降低到原先的 30%。</p></li><li><p>相比支付宝，体积上依旧保持优势，渲染速度上的优势略低一些，平均不超过 50% 的提升。但这个问题主要是飞书对内置组件（<code>checkbox</code>、<code>button</code>）实现的性能较差，如果飞书对这部分进行优化后，相信可以获得更好的优势。</p></li></ul><h1 id="新框架会面临那些问题"><a href="#新框架会面临那些问题" class="headerlink" title="新框架会面临那些问题"></a>新框架会面临那些问题</h1><p>虽然新架构的 DOM 接口在上面的测试和预期中会带来很多的优势，但这并不意味着一点问题都没有。</p><ul><li><p>新架构虽然保留了对 XXML 的兼容性，但依旧会产生一定的 Break Chagne，具体可以看<a href="https://open.feishu.cn/document/uYjL24iN/uEjMuEjMuEjM/new-framework/breaking-changes" target="_blank" rel="noopener">飞书官方文档</a>。</p></li><li><p>由于双线程的架构，在逻辑层模拟的那一层 DOM 无法实现任何和渲染结果相关的 API，例如 <code>getComutedStyle</code> 。还包括 querySelector 依旧要通过原先的异步方式获取。</p></li><li><p>由于 DOM 接口某些能力实现难度较高，例如 <code>innerHTML</code> <code>css parser</code> 等，目前与这些相关的能力只有写入没有读取的能力，如果一定要读取，将无法保证一致性。</p></li><li><p>目前样式还不支持动态插入，后续会支持在 <code>&lt;page&gt;</code> 或者 <code>&lt;head&gt;</code> 内动态插入 <code>&lt;style&gt;</code> 标签来实现。</p></li><li><p>首屏性能。这个上文也说过，后续会有很多办法去优化和实现的，但优先级不高</p></li></ul><p>对我来说，我觉得整体瑕不掩瑜，未来可期。</p><h1 id="未来规划与设计"><a href="#未来规划与设计" class="headerlink" title="未来规划与设计"></a>未来规划与设计</h1><ul><li><p>目前新框架能力的开启和 DOM 接口的使用还在内测状态，对外的时间暂时无法确定</p></li><li><p>未来 DOM 接口还有许多的优化方向，例如如何降低 DOM 指令的数量，降低一些重复字符串的发送等等</p></li><li><p>由于 DOM 接口在一些非 Web 标准组件中和前端框架有一些冲突，例如 React 无法很好的支持 <code>picker</code> 这类需要针对某些属性设置一个对象的情况。后续会推出一些兼容手段去解决这些问题。</p></li><li><p>主流的前端组件组（例如 antd/element/ud）都无法很好的运行在这个上面。一方面是因为这些组件库多多少少都依赖了前端的一些接口，而小程序没有；另一方面，组件库使用的也都是 Web 的标签元素，而不是小程序的组件。后续会尝试推出一定的解决方案去处理这个问题，能够让社区做较少的修改就可以兼容。</p></li><li><p>会考虑以飞书官方的身份推出一套适配于 DOM 接口的主流前端组件库，根据情况会选择是否需要添加 WebComponent 能力的支持。</p></li><li><p>未来飞书小程序的规划都是尽可能的向前端标准实现，未来可能会逐渐添加例如 <code>fetch</code> <code>navigator</code> 在内的 BOM 接口能力支持。</p></li></ul><h1 id="为什么要写这篇文章"><a href="#为什么要写这篇文章" class="headerlink" title="为什么要写这篇文章"></a>为什么要写这篇文章</h1><ul><li><p>希望能促进小程序的前进。<br>小程序业务上的成功并不是其可以恶心开发者的理由，也不应该放弃对其优化的决心。我希望我这一篇有点颠覆传统小程序风格的优化文章，能够探索更多的思路和想法。</p></li><li><p>寻求合作。<br>由于 DOM 接口的特性，需要更多社区的配合才能将这个发挥到极致，例如 Taro/Uniapp 等三方框架，Vant 等小程序原生组件库等等。</p></li><li><p>沟通交流，拓展思路。<br>希望能够得到更多人对这件事情的想法和思路，也希望能够得到更多的输入。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;小程序，作为新一代的应用开发方式，虽然在业务上已经证明了巨大的价值，但是在开发者友好性上却非常的差，例如框架难用，调试困难，跨平台兼容性差。
      
    
    </summary>
    
      <category term="小程序" scheme="https://blog.xgheaven.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="https://blog.xgheaven.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="DOM" scheme="https://blog.xgheaven.com/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>NFC 开发相关知识入门（小程序）</title>
    <link href="https://blog.xgheaven.com/2021/01/02/the-quick-start-about-develop-nfc-in-mini-program/"/>
    <id>https://blog.xgheaven.com/2021/01/02/the-quick-start-about-develop-nfc-in-mini-program/</id>
    <published>2021-01-01T16:00:00.000Z</published>
    <updated>2023-09-16T15:51:09.886Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要是以「飞书」小程序为准，兼容「微信」小程序，如果没有了解过「飞书」的同学，可以<a href="https://www.feishu.cn/" target="_blank" rel="noopener">点击此处</a>去官网了解</p></blockquote><h2 id="什么是-NFC"><a href="#什么是-NFC" class="headerlink" title="什么是 NFC"></a>什么是 NFC</h2><p><strong>近距离无线通信</strong>（英语：Near-field communication，NFC），又简称<strong>近距离通信</strong>或<strong>近场通信</strong>，是一套通信协议，让两个电子设备（其中一个通常是移动设备，例如智能手机）在相距几厘米之内进行通信。</p><p>近场通信技术由非接触式射频识别（RFID）演变而来，由飞利浦半导体（现恩智浦半导体，缩写 NXP）、诺基亚和索尼共同于2004年研制开发，其基础是RFID及互连技术。近场通信是一种短距高频的无线电技术，在13.56MHz频率运行于20厘米距离内。其传输速度有106 Kbit/秒、212 Kbit/秒或者424 Kbit/秒三种。</p><p>NFC 其实在刚诞生的时候我就一直在关注，但是不仅仅应用少，而且搭载的设备也少，甚至小米还出现过前一代搭载 NFC 后一代却不搭载的神奇情况。除此之外，使用起来也是特别复杂，想当初，要用 NFC 去实现刷公交卡，你需要去换一个特殊的 SIM 卡才能够支持（当初不理解，现在想来大概率是因为安全问题）。</p><p>在现在，随着安卓厂商的不懈努力，现在不论是应用还是设备的安装率都已经逐渐普及开来。从最初 NFC 也就能在支付宝中扫银行卡快速输入卡号，到现在的公交刷卡、X Pay，甚至传输文件，华为甚至给这个东西换了个名字叫做一碰系统（率感无语）。</p><p>除此之外，还能推进智能化的发展。比如以后家庭中加入了一个新设备，那么不再需要繁杂的联网过程，直接扫一下机器身上的 NFC 识别码就可以直接将设备加入到家庭网络中。或者说华为路由器上的一碰连接 Wifi 我觉得就是一个极好的应用。当家里来客人的时候，就不再需要一个人一个人的输入密码了。</p><h2 id="NFC-技术一览"><a href="#NFC-技术一览" class="headerlink" title="NFC 技术一览"></a>NFC 技术一览</h2><h3 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a><strong>运行模式</strong></h3><p>NFC 现在主要有三种运行模式，分别是<strong>卡模拟模式</strong>（Card Emulation Mode）、<strong>主机模拟模式</strong>（Host Emulation Mode）、<strong>读卡写卡模式</strong>（Reader/Writer Mode）、<strong>P2P 模式</strong>（P2P Mode）</p><p><strong>卡模拟模式</strong></p><ul><li><p>NFC手机可以模拟成为一张非接触卡，通过 POS 机（非接触读卡器）的 RF 来供电，即使 NFC 手机没电也可以工作。</p></li><li><p>现在很常见的比如 Apple Pay，BYD NFC 钥匙，都是能够实现在断电情况下的刷卡</p></li></ul><img src="/2021/01/02/the-quick-start-about-develop-nfc-in-mini-program/7d10579f-6855-49b3-adca-4a1d4ffe1b6e.png"><p><strong>主机模拟模式</strong></p><ul><li><p>该模式与卡模拟模式很类似，只不过卡模拟无需供电或者说无需 App 的参与就可以完成，但是主机模拟模式是不行的，他是通过将所有的消息转发给应用，由应用去决定该模拟什么内容，也就说该返回什么内容</p></li><li><p>现阶段很多支付钱包，比如云闪付、京东闪付等等都是通过该模式实现的。</p></li></ul><img src="/2021/01/02/the-quick-start-about-develop-nfc-in-mini-program/32aa547c-ce6a-40e1-8b2c-454dba2caa87.png"><p><strong>读卡写卡模式</strong></p><ul><li><p>NFC手机可以通过触碰NFC标签（Tag），从中读取非接触标签中的内容，采集数据并发送到对应的应用进行处理。</p></li><li><p>最常见的应用其实就是华为的一碰系列，除此之外，支付宝支持直接读取信用卡、储蓄卡的卡号。</p></li></ul><img src="/2021/01/02/the-quick-start-about-develop-nfc-in-mini-program/2a9b4dd4-545c-43c5-8b37-104f9ea93403.png"><p><strong>P2P 模式</strong></p><ul><li><p>两个NFC设备可以近距离内互相连接，直接传递数据，实现点对点数据传输。</p></li><li><p>例如协助快速建立蓝牙连接、交换手机名片和数据通信等。</p></li><li><p>最常见的是手机互传、Android Beam。</p></li></ul><img src="/2021/01/02/the-quick-start-about-develop-nfc-in-mini-program/6830ab77-4423-45d4-a4f2-30703d8ace5a.png"><h3 id="协议标准类型"><a href="#协议标准类型" class="headerlink" title="协议标准类型"></a><strong>协议标准类型</strong></h3><p>因为 NFC 的发展过程的原因，曾经出现过多个协议，甚至每家公司都有不同的协议内容。但现在主要是有一下几个协议标准：</p><p><strong>ISO / IEC</strong></p><p>主要定义了一下几个协议：</p><ul><li><p>ISO/IEC 18092 / ECMA-340— (NFCIP-1)</p><p>Near Field Communication Interface and Protocol-1</p></li><li><p>ISO/IEC 21481 / ECMA-352— (NFCIP-2)</p><p>Near Field Communication Interface and Protocol-2</p></li></ul><p>除此以外，还有一个协议标准很常用，是 ISO-14443 协议，其实这个协议是 RFID 的协议，和上面的唯一区别就是上面的多了一些其他模式的标准，比如点对点模式。</p><p>ISO-14443 协议有两个子类，分别是 Type-A 和 Type-B，这两个在 Android 也被称为 NFC-A 和 NFC-B。</p><p>但不幸的是，这些协议也不能免费看，要花钱的</p><p><strong>NFC Forum</strong></p><p><a href="https://nfc-forum.org/" target="_blank" rel="noopener">NFC Forum</a> 是一个在 2004 年创建的非盈利行业协会，其成员来自NFC生态系统的各个部分。另外我主要关注了下国内公司，比较知名的有小米、中国移动通讯。</p><p>但是你想要从该组织获取任何关于 NFC 相关的技术标准，首先你的公司要成为该组织的成员才行，因为字节根本不在该组织，所以没法从这里获得一手的信息。</p><p>不过办法也是有的，该协会的创办者 NXP 公司网站上是有相关的数据资源，后文的参考此资源。</p><p><strong>其他</strong></p><p>不用管.jpg</p><h3 id="沟通协议"><a href="#沟通协议" class="headerlink" title="沟通协议"></a><strong>沟通协议</strong></h3><p>以 NFC-A 为例</p><img src="/2021/01/02/the-quick-start-about-develop-nfc-in-mini-program/f4d39ae5-9c5e-4f4e-8b22-9cbc17cedd14.png"><p>整个 NFC 卡片其实内部就是一个有限状态机，根据当前不同的状态需要不同的操作。这个图看起来很复杂，其实主要额外包含了两个操作：</p><ul><li><p>密码校验</p><ul><li><p>这个是说 NFC 卡是经过加密的，只有在密码校验通过之后，才能够进行相关的操作。</p></li><li><p>有一点特殊的是，NFC 的密码长度其实是固定的，即 32 位，4 个字节。</p></li></ul></li><li><p>防冲突</p><ul><li><p>之所有有这个设计，是因为在使用过程中，可能会出现同时扫描到多个 NFC 设备的情况，此时就需要通过 READY1/READY2 两个状态来选择正确的 NFC 设备进行操作。</p></li><li><p>每个卡片都有一个唯一 UID，长度为 7 字节，而每次操作只能选择 4 个字节，所以不得不拆分成两个状态两步去操作。</p></li></ul></li></ul><p>当没有上面两个操作的时候，可以简单的执行 IDLE -&gt; ACTIVE -&gt; HALT 的状态流程，也就是说连接、操作（也就是读写）、关闭。</p><h3 id="存储设计"><a href="#存储设计" class="headerlink" title="存储设计"></a><strong>存储设计</strong></h3><p>NFC 在存储上设计了页的概念，一个页表示 4 个字节，以页为最小单位进行操作。所以 NFC 卡片的存储容量其实都是 4 的整数倍。</p><p>这里以 NTAG213 180 字节的存储结构为例</p><img src="/2021/01/02/the-quick-start-about-develop-nfc-in-mini-program/d818bba2-d78d-48eb-aae8-94d54e0ed449.png"><p>这里只需要关注两点：</p><ul><li><p>用户数据存储的空间是从第四页开始</p></li><li><p>用户可存储空间其实只有 144 字节</p></li></ul><p>只需要记住这两点，在开发 NFC 需求的时候，不要去修改非用户空间的数据，不要存储过长的内容。</p><h2 id="设备准备"><a href="#设备准备" class="headerlink" title="设备准备"></a>设备准备</h2><p>在有了上面的基础之后，别急你还是不能开始开发 NFC，因为你还缺少至关重要的一个东西，设备</p><p>遗憾的是，不是所有的设备都有 NFC 硬件的，也不是说有了 NFC 硬件就能用的</p><ul><li><p>苹果设备只有升级到 iOS 13 以上才能具有开发 NFC 读卡器的能力，不能写入，除此之外，几乎没有其他的 NFC 能力可以使用。机圈也会叫做阉割版 NFC。（暂时没有能力去调研 NFC 的能力一定是需要硬件支持还是说只是软件限制）</p></li><li><p>安卓设备理论上可以使用几乎所有的 NFC 能力，机圈内叫全功能 NFC，包括读卡、写卡、卡模拟、P2P 等模式。但是不同的手机有着不同的操作系统的限制，所以要选择一个合适的操作系统（原生安卓、类原生安卓是最推荐的）。</p></li></ul><p>所以，请准备好一台安卓手机！</p><h2 id="NFC-卡片"><a href="#NFC-卡片" class="headerlink" title="NFC 卡片"></a>NFC 卡片</h2><p>在有了设备之后，还要选择正确的 NFC 卡片，因为不是任意一个 NFC 卡片都是可以用的，比如工牌、银行卡等等。这是因为 NFC 卡片是带有加密的，在操作之前必须要通过验证才能操作，所以建议去淘宝买一些可读可写无加密的 NFC 贴纸用于测试。</p><p>不过你在淘宝上买的可能是写着 NTAG213 的型号，其实这个是 NXP 出的一款设备，但是支持兼容 ISO NFC-A 协议以及 NFC Forum Type 2 协议，所以大家可以放心使用。</p><p>当然了，你也可能看到 NTAG215/NTAG216，这两个都没有任何区别，只是存储空间不同而已。</p><img src="/2021/01/02/the-quick-start-about-develop-nfc-in-mini-program/9593b7a1-4bec-492e-8d87-ebf66c65e8b2.png"><h2 id="小程序-API"><a href="#小程序-API" class="headerlink" title="小程序 API"></a>小程序 API</h2><p>此时在有了上述的基础知识后，别急，还要了解下小程序的 API 才能更好的开发。</p><p>就目前来说，所有与 NFC 相关的操作都被封装到了 <code>NfcAdaptar</code> 类中，通过 <code>tt.getNFCAdaptar()</code> 获取 <code>nfcAfaptar</code> 对象。</p><blockquote><p>具体的 API 参数细节请参考「<a href="https://open.feishu.cn/document/uYjL24iN/ugTN4YjL4UDO24CO1gjN" target="_blank" rel="noopener">飞书开放平台</a>」</p></blockquote><h3 id="NFC-整体流程"><a href="#NFC-整体流程" class="headerlink" title="NFC 整体流程"></a><strong>NFC 整体流程</strong></h3><ul><li><p>注册 NFC 发现事件回调 <code>nfcAdaptar.onDiscovered</code></p></li><li><p>开启 NFC 扫描 <code>nfcAdaptar.startDiscovered</code></p></li><li><p>NFC 卡片贴近设备</p></li><li><p>触发回调，通过回调可以获得 NFC 支持的协议</p><ul><li>回调参数内的 techs 字段可以用于判断当前卡片支持的协议</li></ul></li><li><p>根据协议去读写 NFC 卡片内容 <code>nfcAdaptar.getNfcA()</code></p></li><li><p>关闭 NFC 扫描，关闭事件监听 <code>nfcAdaptar.offDiscovered</code> / <code>nfcAdaptar.stopDiscovered()</code></p></li></ul><p>可以发现这个流程非常容易理解，也非常容易操作。那么接下来我们看下重头戏</p><h3 id="读写-NFC-卡片"><a href="#读写-NFC-卡片" class="headerlink" title="读写 NFC 卡片"></a><strong>读写 NFC 卡片</strong></h3><p>这里以 NFC-A 协议为主</p><p>通过 <code>nfcAdaptar.getNfcA()</code> 获取操作 NFC-A 卡片的操作类实例 nfca，流程如下</p><ul><li><p>连接卡片 <code>nfca.connect()</code></p></li><li><p>读写卡片 <code>nfca.transceive()</code></p></li><li><p>读写完成之后关闭连接 <code>nfca.close()</code></p></li></ul><p>关键点来了，NFC 卡片的读写不和其他的 IO 设备类似，有专门的 read 和 write 函数。对 NFC 来说，通过给 NFC 卡片发送不同的指令来做到完成不用的操作。</p><p>这些指令都在 NTAG213 文档中有写，这里简单列一下常用的数据</p><table><thead><tr><th>命令</th><th>代码</th><th>功能</th><th>参数</th></tr></thead><tbody><tr><td>Read</td><td>0x30</td><td>一次读取四个页的数据</td><td><code>&lt;Addr:1B&gt;</code></td></tr><tr><td>Write</td><td>0xA2</td><td>一次写入一个页的数据</td><td><code>&lt;Addr:1B&gt; &lt;Data:4B&gt;</code></td></tr><tr><td>Fast Read</td><td>0x3A</td><td>一次读取多个页的数据</td><td><code>&lt;StartAddr:1B&gt; &lt;StopAddr:1B&gt;</code></td></tr></tbody></table><p>比如我要读取第四页的数据，可以写如下代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nfca.transceive(&#123;</span><br><span class="line">    data: <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0x30</span>, <span class="number">0x04</span>]).buffer, <span class="comment">// 必须要传入 ArrayBuffer</span></span><br><span class="line">    success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// res.data 是 ArrayBuffer，转成数组方便查看</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(res.data))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>根据协议，其实还要传 <a href="CRC:2B" target="_blank" rel="noopener">CRC:2B</a>，也就是校验位，不过这个操作已经由 Android 去做掉了，所以就不需要传了，也不需要去了解校验算法</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此，NFC 开发算是入门了，不过这里要注意不同的 NFC 卡片不同的协议会有不同的读写方式，这里要根据你们各自具体的卡片来看。而且有的还有密码保护，还需要额外再走校验的逻辑。</p><h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><ul><li><p><a href="https://blog.csdn.net/xiaozy115/article/details/103171143" target="_blank" rel="noopener">NFC 简介 - CSDN</a></p></li><li><p><a href="https://bitexperts.com/Question/Detail/3360/difference-between-iso-14443-and-iso-18092-i-e-rfid-vs-nfc" target="_blank" rel="noopener">Difference between ISO 14443 and ISO 18092, i.e. RFID vs NFC</a></p></li><li><p><a href="https://www.nxp.com.cn/docs/en/data-sheet/NTAG213_215_216.pdf" target="_blank" rel="noopener">NTAG213 协议文档</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文主要是以「飞书」小程序为准，兼容「微信」小程序，如果没有了解过「飞书」的同学，可以&lt;a href=&quot;https://www.feishu.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击此处&lt;/a&gt;去官网了解&lt;/p&gt;
      
    
    </summary>
    
      <category term="小程序" scheme="https://blog.xgheaven.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="https://blog.xgheaven.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="NFC" scheme="https://blog.xgheaven.com/tags/NFC/"/>
    
  </entry>
  
  <entry>
    <title>心心念的 10 核 20 线程家庭高性能服务器</title>
    <link href="https://blog.xgheaven.com/2020/08/05/high-performance-home-server-with-10-cores-and-20-threads/"/>
    <id>https://blog.xgheaven.com/2020/08/05/high-performance-home-server-with-10-cores-and-20-threads/</id>
    <published>2020-08-04T16:00:00.000Z</published>
    <updated>2023-09-16T15:51:09.759Z</updated>
    
    <content type="html"><![CDATA[<p>因为疫情的原因，在家里实在是无聊，外加最近公司里的事情不是很忙，于是我就开始研究捡垃圾事宜。而且之前在学校薅的 vps 羊毛也快到期了，基本上各大平台都薅过了，没法继续薅了，也使我决定了继续捡垃圾去搞一套家庭服务器。</p><p>开门见山，直接说我捡垃圾的结果，总价 3000 左右</p><ul><li><p>主板：华硕 z10pa-u8 10G-2S 12 ￥1250</p></li><li><p>CPU：e5 2660 v3 10 核 20 线程 ￥510</p></li><li><p>内存：2 <em> 16 ECC DDR4 2133 ￥250 </em> 2</p></li><li><p>电源：海韵 550W 全模组金牌电源 ￥450</p></li><li><p>散热器：超微 E5 2011 服务器专用散热器 ￥155</p></li><li><p>机箱：航嘉 S400 4u 工控机箱 ￥239</p></li><li><p>系统：Unraid，暂时是试用版，所以不计入总价。等后面磨合好了会购买正版</p></li><li><p>硬盘：家里淘汰下来的 500G 垃圾机械，不计入总价</p></li></ul><p>整机装好 unraid 系统后空盘待机功耗 35W 左右，CPU 温度 40 度；系统满载在 130W 左右，温度 75 度左右。整体来说我是非常满意的，因为我另外一台 j1900 的 nas 待机也要 15W，虽然高了 20W 但是带来的性能提升可不止 20W 这么一点。</p><img src="/2020/08/05/high-performance-home-server-with-10-cores-and-20-threads/8e97a58c-76fe-4688-8d44-52e5f8aa8c1d.jpg"><p>可能你会有很多疑惑，为什么要搞这个，为什么选用这样的配置，那么接下来让我一一来解释下我为啥选用这套配置，也给想要相同想法的朋友一个选择方案。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在具体讲选择配件过程中，我们现在对齐目标，只有我们的目标相同，才能更好的理解我为什么选择这套配置：</p><ul><li><p>需要一台家庭强性能服务器，用于跑我个人的项目以及一些常用的 app，要求 CPU 核心数足够多，方便跑多任务</p></li><li><p>服务器单核性能也要足够的强，因为会用来游戏开服，比如 minecraft，这个比较吃单核性能</p></li><li><p>需要能够较好的以虚拟化的方式运行群辉，并且最好能够支持万兆网络，方便有时候心血来潮拷贝素材剪辑视频等</p></li><li><p>偶尔要做家庭影音啥的，所以最好能够硬件解码的能力</p></li><li><p>因为要跑群辉，所以要能够有较多的 SATA 接口，或者足够的 PCI 接口</p></li><li><p>待机功耗要足够的低，毕竟我还是租房子住，不希望电费太贵</p></li><li><p>服务器体积尽可能不要太大，同时要保证静音，而且家里有宠物，所以会考虑走线，避免宠物触碰到，所以机箱的选择可能不是很适合所有人</p></li><li><p>最后的最后，价钱要便宜，挑选起来可就简单多了</p></li></ul><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>一个服务器的核心就是他的 CPU，只要 CPU 定好之后，其他的配件都可以围绕着它展开。</p><p>先说一句，因为我是要做高性能服务器，所以什么 j1900 j3455 奔腾啊这些低功耗的 CPU 全部 pass。</p><p>其实挑选 CPU 是我最纠结的地方，因为我有两个自相矛盾的，是核心数的数量和单核性能之间的矛盾，众所周知，服务器级别 CPU 核心数多但单核性能羸弱，而消费级 CPU 核心数少但单核性能强。于是我在服务器和消费级之间来回摇摆，虽然消费级一般不支持 ECC，但是核心强更吸引我。我也一直不能下定决心。我目标的是至少 8 核 16 线程，并且单核性能与现有的消费级别处理器差不多。</p><p>说道这里，可能就有人会说 AMD 线程撕裂者不香么。确实，当初看到觉得特别符合我的要求，核心多单核强，但问题就在于这玩意上万块啊，就算是线程撕裂者一代，也要 1w，这对于我来说太难以接受了。</p><p>逛了一圈，实在是找不到，于是我不得不降低要求，就是放弃消费级别 CPU。一是因为没有核心数合适的，在锐龙以前的时代，intel 一直在四核心徘徊，就算是在锐龙之后，intel 的核心数也少。而锐龙核心够，但这又牵扯出另外一个问题，就是消费级别的 U 实在是贵啊，7700K 都还 1800 块呢，想要搞个便宜的，只能去找 4 代 3 代的 intel U，但这个时代的 U 和 E5 洋垃圾也差不多。所以最后将目光投向了服务器 E5 洋垃圾</p><p>而 E5 最难选择的其实就是 v2 系列还是 v3 系列了。v2 系列意味着可以用 DDR3 内存以及更便宜的主板，但是他的待机功耗要大不少。但 v3 系列相比要用更贵的 DDR4 内存和主板，但他的性能更强，待机功耗更低。具体对比可以看图</p><img src="/2020/08/05/high-performance-home-server-with-10-cores-and-20-threads/bd1c55d9-6b74-4442-b07b-c8bae4f3d38f.png"><p>可以发现，同样是 2660，v3 比 v2 的性能提升了 20% 还要多，单核心性能比 r5 1600 来说才低了 20% 左右，比我想象中的好多了，一般来说同代的服务器都要比同代的消费级性能至少低 30% 多，如果是更高端的消费级可能要低 50%。而且总分更是比万元的 1900x 一代线程撕裂者还要高。</p><p>当然了，这里应该拿 intel 的做对比，拿 AMD 不太恰当，AMD 本身同代单核就比 intel 低不少，不过我手上只有 AMD 的 u，所以就拿 AMD 的来对比了。</p><p>那我为啥选择 2660 而不是 2650 或者 2678 呢？其实原因很简单，2650 以上基本就符合我的需求了，但是我发现 2660 竟然比 2650 还要便宜，那为啥不用 2660 呢？如果等以后我对性能有更高要求的时候，再换也不迟。</p><img src="/2020/08/05/high-performance-home-server-with-10-cores-and-20-threads/cc377345-f967-44e2-aa29-e0bd973fef47.jpg"><h2 id="准系统？"><a href="#准系统？" class="headerlink" title="准系统？"></a>准系统？</h2><p>在考虑的过程中，我也曾经看过一些准系统，二手服务器 dell r620 r730xd 准系统、二手的塔式服务器准系统，但都被我 pass 掉了，主要原因是：</p><ul><li><p>二手塔式服务器太贵了，光一个准系统就要 3000+ 了，而且还是 v2 的 u。</p></li><li><p>机架式的服务器虽然便宜，但是噪音功耗都太大，而且体积也很大，放到哪里都不合适，因为租的房子没有专门的机房或者书房。</p></li><li><p>r620 是 v2 的 u，功耗太大。而 r730xd 又太贵了，最后也 pass 了</p></li></ul><h2 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h2><p>既然将准系统 pass 掉之后，我不得不开始自选主板的道路。因为我不会用来做把服务器用来做视频渲染，需要核心多，但不需要那么多，所以这里我主要挑选的是单路主板，而且单路的便宜啊。如果小伙伴需要服务器拿来做视频渲染，建议直接上双路主板。PS：其实自从三代锐龙出现之后，建议视频渲染啥的还是直接上 3900x 3950x 这类吧，E5 做视频渲染已经不香了。</p><p>支持 V3 的主板基本有两种，一种是国产的寨板，另外一种就是拆机的服务器主板。</p><p>寨板有一个最大的好处，就是便宜，基本上五六百就可以搞定，但是缺点就是可扩展性太差了，内存插槽少，SATA 少，PCI-E 更少，而且还容易 BOOM，最终我放弃了寨板</p><p>那就只有拆机服务器主板可以选了，这其中就有微星、华硕的可以选，我最后选定了华硕 z10pa-u8 10g-2s 只有一个原因，便宜。微星的拆机件某宝基本上要 2000 左右，而话说的这个只需要 1400 多，运气好的话还能找到 1200 多的，就比如我下单的这个，而且还是湖北店铺，就当支持湖北朋友了。</p><img src="/2020/08/05/high-performance-home-server-with-10-cores-and-20-threads/9f6dbdfa-8022-4228-a125-1716e8f266eb.jpg"><p>简答介绍一下我这个主板，大家来感受下这 1200 块到底值不值：</p><ul><li><p>双板载千兆网卡，双板载万兆网卡，一个 IPMI 管理端口（板载万兆啊，普通的万兆扩展卡都要三四百呢，注意，不是所有的板子都有万兆网卡的，不带 10g-2s 的就没有）</p></li><li><p>8 条内存插槽</p></li><li><p>10 SATA 接口（足够我的硬盘使用了，而且 4 个侧插，6 个直插，还是比较丰富的）</p></li><li><p>板载 m.2 NGFF 接口（因为是上年纪的板子，没有 nvme，不过也很不错了）</p></li><li><p>双 PCI-Ex16，3 个 PCI-Ex8，一个 PCI-Ex1，不过其中一个 x16 是一个 x8 是共用的，当插了一个 x8 之后，x16 会自动变成 x8。</p></li><li><p>板上搭载一个 USB，方便直接做启动盘</p></li></ul><p>总的来讲，在单路主板里面，我觉得这个算是比较值的，尤其是板载万兆网卡。</p><h2 id="机箱"><a href="#机箱" class="headerlink" title="机箱"></a>机箱</h2><p>前面也说了，我不想有一个太大的机箱，所以当时就没想直接买个 2u 机架服务器的机箱。而比较符合的是各种 nas 机箱，比如 8 盘位的，但问题依旧是太贵。8 盘位的要上千了，4 盘位的基本也在五百左右。</p><p>于是我就去看了看普通的塔式机箱，基本上比较符合我的心意，最多有 10 盘位的，支持 E-ATX 主板，而且价钱也才 300 多块，最主要是能够支持普通的机箱配件，而且还有一定的热插拔能力。简直太完美了，唯一的缺点就是外观不够有范</p><p>直到有一天无意间看到 4u 的工控机箱，发现这玩意好帅气，很符合我对一个服务器的定位。虽然只有 7 盘位，但是配合光驱位也能有 10 盘位。最主要的这个带钥匙，就不用怕我家里的猫一不小心碰到开关就给我关机了。而且体积比塔式的还要小巧一点，毕竟是租的方式，能小一点是一点，不过就是损失了热插拔的能力。好在价格更便宜，而且还躺着，于是心血来潮的我就定了这款机箱。</p><p>PS：在我实际装机之后，我觉得奉劝大家，还是塔式的好啊，工控机内部走线实在是太难了，没有热插拔能力测试的时候太难了。不过样子很好看，很有感觉，一次装机之后只要是不加硬盘基本不会动他了，也算是能接受吧。</p><img src="/2020/08/05/high-performance-home-server-with-10-cores-and-20-threads/1c55d487-c227-4f3e-a069-c62aa0abaa7a.jpg"><h2 id="其他配件"><a href="#其他配件" class="headerlink" title="其他配件"></a>其他配件</h2><p>其他的配件基本上就是随便买的，内存选了 2133 频率的，为了保证兼容性。</p><img src="/2020/08/05/high-performance-home-server-with-10-cores-and-20-threads/b0816a31-4345-45bd-a47b-41dd1846f9a6.jpg"><p>有个好玩的事情就是电源，原本想买个金牌的 450W 直出电源就够了，毕竟就几个硬盘，最多可能外加一个计算卡，其他的也不会需要了。但正好赶上 618 活动，550W 金牌全模比 450W 金牌直出还便宜，于是我就买了 550W 了。但后来经过朋友提醒，想起来有个最佳转换效率区间，如果负载太低的话，就算是金牌，转换效率也不会太高的，理论上搞个 200W 就够了。</p><img src="/2020/08/05/high-performance-home-server-with-10-cores-and-20-threads/10269076-e461-432e-a4b1-8dfc41ed4cff.jpg"><p>哎，就这样吧，买都买了。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>一切装好之后，我就安装了 unraid 作为宿主系统，原因很简单：</p><ul><li><p>U 盘就能启动</p></li><li><p>界面友好，EXSI 实在是有点丑</p></li><li><p>Docker 友好，这点太重要了，作为一个开发，深知 Docker 有多好用</p></li><li><p>插件丰富，很多东西都能安装</p></li><li><p>虚拟机太好用了，直通啥的一点问题都没有，而且还支持 XML 编辑，真棒</p></li><li><p>基于 Linux 系统，直接提供了命令行工具，作为一个开发，能搞的东西太多了，太喜欢了</p></li></ul><p>话不多说，直接一个群辉，一个 debian 虚拟机就搞起来了，把我之前在群辉里面跑的那个 Docker 转移到了 unraid 的 Docker 上。</p><p>就此，我心心念的服务器算是告一段落了，接下来就是把云服务器上的业务逐渐迁移到本地来，另外还要折腾下本地域名映射，让泛域名直接解析到内网的网关服务器上，这样就可以通过内网域名直接访问服务器上的业务了。就是内网的域名证书不好搞，用自签名的话需要每一台机器上都要安装根证书，用 CA 签名的吧，泛域名证书太贵了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为疫情的原因，在家里实在是无聊，外加最近公司里的事情不是很忙，于是我就开始研究捡垃圾事宜。而且之前在学校薅的 vps 羊毛也快到期了，基本上各大平台都薅过了，没法继续薅了，也使我决定了继续捡垃圾去搞一套家庭服务器。&lt;/p&gt;
&lt;p&gt;开门见山，直接说我捡垃圾的结果，总价 30
      
    
    </summary>
    
      <category term="家庭私有环境" scheme="https://blog.xgheaven.com/categories/%E5%AE%B6%E5%BA%AD%E7%A7%81%E6%9C%89%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="捡垃圾" scheme="https://blog.xgheaven.com/tags/%E6%8D%A1%E5%9E%83%E5%9C%BE/"/>
    
      <category term="Home Server" scheme="https://blog.xgheaven.com/tags/Home-Server/"/>
    
  </entry>
  
  <entry>
    <title>Hooks &amp; Mobx 只需额外知道两个 Hook，便能体验到如此简单的开发方式</title>
    <link href="https://blog.xgheaven.com/2020/05/07/hooks-mobx-is-a-very-good/"/>
    <id>https://blog.xgheaven.com/2020/05/07/hooks-mobx-is-a-very-good/</id>
    <published>2020-05-06T16:00:00.000Z</published>
    <updated>2023-09-16T15:51:09.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>本文主要讲解了下我平时在工作开发中遇到的关于 Hooks 的一些缺点和问题，并尝试配合 Mobx 解决这些问题的经历。我觉得两者的配合可以极大的降低开发过程中有可能出现的问题以及极大的提高开发体验，而且学习成本也是非常的低。如果你对 Hooks 以及 Mobx 有兴趣，想知道更进一步的了解，那么这篇文章适合你。这篇文章会介绍如下内容，方便你决定是否要仔细阅读，节省时间：</p><ul><li><p>本文不会介绍太过于基础的内容，你需要对 Mobx 以及 Hooks 有基础的了解</p></li><li><p>本文介绍了平时开发中的一些最佳实践，方便小伙伴们对两者有更加深入的认识</p></li><li><p>如果你使用过一部分 Mobx，但是不太了解如何和 Hooks 更好的合作，可以尝试来看看</p></li></ul><p>另外 Hooks 本身真的就是一个理解上非常简单的东西，所以本文也不长，我也不喜欢去写什么万字长文，又不是写教程，而且读者看着标题就失去兴趣了。</p><h2 id="Hooks-究竟有什么问题？"><a href="#Hooks-究竟有什么问题？" class="headerlink" title="Hooks 究竟有什么问题？"></a>Hooks 究竟有什么问题？</h2><p>首先，在这里我不再说 Hooks 的优点，因为他的优点用过的人都清楚是怎么回事，这里主要讲解一下他存在的缺点，以及如何用 Mobx 来进行改进。</p><ul><li><p><strong>依赖传染性</strong> —— 这导致了开发复杂性的提高、可维护性的降低</p></li><li><p><strong>缓存雪崩</strong> —— 这导致运行性能的降低</p></li><li><p><strong>异步任务下无法批量更新</strong> —— 这也会导致运行性能的降低</p></li></ul><p>换句话说，造成这种原因主要是因为 Hooks 每次都会创建一个全新的闭包，而闭包内所有的变量其实都是全新的。而每次都会创建闭包数据，而从性能角度来讲，此时缓存就是必要的了。而缓存又会牵扯出一堆问题。</p><p>说到底，也就是说没有一个公共的空间来共享数据，这个在 Class 组件中，就是 this，在 Vue3 中，那就是 setup 作用域。而 Hooks 中，除非你愿意写 <code>useRef</code> + <code>ref.current</code> 否则是没有办法找到共享作用域。</p><p>而 mobx 和 Hooks 的结合，可以很方便在 Hooks 下提供一个统一的作用域来解决上面遇到的问题，所谓双剑合并，剑走天下。</p><h2 id="Hook1-useObserver"><a href="#Hook1-useObserver" class="headerlink" title="Hook1 useObserver"></a>Hook1 useObserver</h2><p>在传统的使用 mobx 的过程中，大家应该都知道 <code>observer</code> 这个 api，对需要能够响应式的组件用这个包裹一下。同样，这个 api 直接在 hooks 中依旧可以正常使用。 但是 hooks 并不推荐 hoc 的方式。自然，mobx 也提供了 hookify 的使用方式，那就是 <code>useObserver</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = observable(&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> useObserver(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &lt;div&gt;&#123;store.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>看到这里，相信使用过 mobx 的应该可以发现，useObserver 的使用几乎和 Class 组件的 render 函数的使用方式一致。事实上也确实如此，而且他的使用规则也很简单，直接把需要返回的 Node 用该 hooks 包裹后再返回就可以了。</p><p>经过这样处理的组件，就可以成功监听数据的变化，当数据变化的时候，会触发组件的重渲染。至此，第一个 api 就了解完毕了</p><h2 id="Hook2-useLocalStore"><a href="#Hook2-useLocalStore" class="headerlink" title="Hook2 useLocalStore"></a>Hook2 useLocalStore</h2><p>简单来讲，就是在 Hooks 的环境下封装的一个更加方便的 observable。就是给他一个函数，该函数返回一个需要响应式的对象。可以简单的这样理解</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = useLocalStore(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;key: <span class="string">'value'</span>&#125;))</span><br><span class="line"><span class="comment">// equal</span></span><br><span class="line"><span class="keyword">const</span> [store] = useState(<span class="function"><span class="params">()</span> =&gt;</span> observable(&#123;key: <span class="string">'value'</span>&#125;))</span><br></pre></td></tr></table></figure><p>然后就没有了，极其简单的一个 api 使用。而后面要讲的一些最佳实践更多的也是围绕这个展开，后文简化使用 local store 代指。</p><h2 id="这两个-API-能带来什么？"><a href="#这两个-API-能带来什么？" class="headerlink" title="这两个 API 能带来什么？"></a>这两个 API 能带来什么？</h2><p>简单来讲，就是在保留 Hooks 的特性的情况下，解决上面 hooks 所带来的问题。</p><p>第一点，由于 local store 的存在，作为一个不变的对象存储数据，我们就可以保证不同时刻对同一个函数的引用保持不变，不同时刻都能引用到同一个对象或者数据。不再需要手动添加相关的 deps。由此可以避免 useCallback 和 useRef 的过度使用，也避免很多 hooks 所面临的的闭包的坑（老手请自动忽略）。依赖传递性和缓存雪崩的问题都可以得到解决</p><p>直接上代码，主要关注注释部分</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要实现一个方法，只有当鼠标移动超过多少像素之后，才会触发组件的更新</span></span><br><span class="line"><span class="comment">// props.size 控制移动多少像素才触发回调</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MouseEventListener</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> [pos, setPos] = useState(&#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> posRef = useRef()</span><br><span class="line"><span class="keyword">const</span> propsRef = useRef()</span><br><span class="line"><span class="comment">// 这里需要用 Ref 存储最新的值，保证回调里面用到的一定是最新的值</span></span><br><span class="line">posRef.current = pos</span><br><span class="line">propsRef.current = propsRef</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> handler = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> newPos = &#123;x: e.xxx, y: e.xxx&#125;</span><br><span class="line"><span class="keyword">const</span> oldPos = posRef.current</span><br><span class="line"><span class="keyword">const</span> size = propsRef.current.size</span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line"><span class="built_in">Math</span>.abs(newPos.x - oldPos.x) &gt;= size</span><br><span class="line">|| <span class="built_in">Math</span>.abs(newPos.y - oldPos.y) &gt;= size</span><br><span class="line">) &#123;</span><br><span class="line">setPos(newPos)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当组件挂载的时候，注册这个事件</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'mousemove'</span>, handler)</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">document</span>.removeEventListener(<span class="string">'mousemove'</span>, handler)</span><br><span class="line"><span class="comment">// 当然这里也可以监听 [pos.x, pos.y]，但是性能不好</span></span><br><span class="line">&#125;, [])</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">props.children(pos.x, pos.y)</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 mobx 改写之后，这种使用方式远比原生 hooks 更加符合直觉。</span></span><br><span class="line"><span class="comment">// 不会有任何 ref，任何 current 的使用，任何依赖的变化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MouseEventListenerMobx</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> state = useLocalStore(<span class="function"><span class="params">target</span> =&gt;</span> (&#123;</span><br><span class="line">x: <span class="number">0</span>,</span><br><span class="line">y: <span class="number">0</span>,</span><br><span class="line">handler(e) &#123;</span><br><span class="line"><span class="keyword">const</span> nx = e.xxx</span><br><span class="line"><span class="keyword">const</span> ny = e.xxx</span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line"><span class="built_in">Math</span>.abs(nx - state.x) &gt;= target.size ||</span><br><span class="line"><span class="built_in">Math</span>.abs(ny - state.y) &gt;= target.size</span><br><span class="line">) &#123;</span><br><span class="line">state.x = nx</span><br><span class="line">state.y = ny</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;), props)</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'mousemove'</span>, state.handler)</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">document</span>.removeEventListener(<span class="string">'mousemove'</span>, state.handler)</span><br><span class="line">&#125;, [])</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> useObserver(<span class="function"><span class="params">()</span> =&gt;</span> props.children(state.x, state.y))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二，就是针对异步数据的批量更新问题，mobx 的 action 可以很好的解决这个问题</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件挂载之后，拉取数据并重新渲染。不考虑报错的情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AppWithHooks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> [data, setData] = useState(&#123;&#125;)</span><br><span class="line"><span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">true</span>)</span><br><span class="line">useEffect(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">await</span> fetchData()</span><br><span class="line"><span class="comment">// 由于在异步回调中，无法触发批量更新，所以会导致 setData 更新一次，setLoading 更新一次</span></span><br><span class="line">setData(data)</span><br><span class="line">setLoading(<span class="literal">false</span>)</span><br><span class="line">&#125;, [])</span><br><span class="line"><span class="keyword">return</span> (<span class="comment">/* ui */</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AppWithMobx</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> store = useLocalStore(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">data: &#123;&#125;,</span><br><span class="line">loading: <span class="literal">true</span>,</span><br><span class="line">&#125;))</span><br><span class="line">useEffect(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">await</span> fetchData()</span><br><span class="line">runInAction(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 这里借助 mobx 的 action，可以很好的做到批量更新，此时组件只会更新一次</span></span><br><span class="line">store.data = data</span><br><span class="line">store.loading = <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;, [])</span><br><span class="line"><span class="keyword">return</span> useObserver(<span class="function"><span class="params">()</span> =&gt;</span> (<span class="comment">/* ui */</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过也有人会说，这种情况下用 <code>useReducer</code> 不就好了么？确实，针对这个例子是可以的，但是往往业务中会出现很多复杂情况，比如你在异步回调中要更新本地 store 以及全局 store，那么就算是 <code>useReducer</code> 也要分别调用两次 dispatch ，同样会触发两次渲染。而 mobx 的 action 就不会出现这样的问题。// 如果你强行 <code>ReactDOM.unstable_batchedUpdates</code> 我就不说啥了，勇士受我一拜</p><h2 id="Quick-Tips"><a href="#Quick-Tips" class="headerlink" title="Quick Tips"></a>Quick Tips</h2><p>知道了上面的两个 api，就可以开始愉快的使用起来了，只不过这里给大家一下小 tips，帮助大家更好的理解、更好的使用这两个 api。（不想用而且也不敢用「最佳实践」这个词，感觉太绝对，这里面有一些我自己也没有打磨好，只能算是 tips 来帮助大家拓展思路了）</p><h3 id="no-this"><a href="#no-this" class="headerlink" title="no this"></a>no this</h3><p>对于 store 内的函数要获取 store 的数据，通常我们会使用 this 获取。比如</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = useLocalStore(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">count: <span class="number">0</span>,</span><br><span class="line">add() &#123;</span><br><span class="line"><span class="keyword">this</span>.count++</span><br><span class="line">&#125;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; add &#125; = store</span><br><span class="line">add() <span class="comment">// boom</span></span><br></pre></td></tr></table></figure><p>这种方式一般情况下使用完全没有问题，但是 this 依赖 caller，而且无法很好的使用解构语法，所以这里并不推荐使用 this，而是采用一种 <code>no this</code> 的准则。直接引用自身的变量名</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = useLocalStore(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">count: <span class="number">0</span>,</span><br><span class="line">add() &#123;</span><br><span class="line">store.count++</span><br><span class="line">&#125;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; add &#125; = store</span><br><span class="line">add() <span class="comment">// correct，不会导致 this 错误</span></span><br></pre></td></tr></table></figure><ul><li><p>避免 this 指向的混乱</p></li><li><p>避免在使用的时候直接解构从而导致 this 丢失</p></li><li><p>避免使用箭头函数直接定义 store 的 action，一是没有必要，二是可以将职责划分的更加清晰，那些是 state 那些是 action</p></li></ul><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>在某些情况下，我们的 local store 可能需要获取 props 上的一些数据，而通过 source 可以很方便的把 props 也转换成 observable 的对象。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> store = useLocalStore(<span class="function"><span class="params">source</span> =&gt;</span> (&#123;</span><br><span class="line">doSomething() &#123;</span><br><span class="line"><span class="comment">// source 这里是响应式的，当外界 props 发生变化的时候，target 也会发生变化</span></span><br><span class="line"><span class="keyword">if</span> (source.count) &#123;&#125;</span><br><span class="line"><span class="comment">// 如果这里直接用 props，由于闭包的特性，这里的 props 并不会发生任何变化</span></span><br><span class="line"><span class="comment">// 而 props 每次都是不同的对象，而 source 每次都是同一个对象引用</span></span><br><span class="line"><span class="comment">// if (props.count) &#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过第二个参数，就可以完成这样的功能</span></span><br><span class="line">&#125;), props)</span><br><span class="line"><span class="comment">// return Node</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这里不仅仅可以用于转换 props，可以将很多非 observable 的数据转化成 observable 的，最常见的比如 Context、State 之类，比如</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> context = useContext(SomeContext)</span><br><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> store = useLocalStore(<span class="function"><span class="params">source</span> =&gt;</span> (&#123;</span><br><span class="line">getCount() &#123;</span><br><span class="line"><span class="keyword">return</span> source.count * source.multi</span><br><span class="line">&#125;</span><br><span class="line">&#125;), &#123;...props, ...context, count&#125;)</span><br></pre></td></tr></table></figure><h3 id="自定义-observable"><a href="#自定义-observable" class="headerlink" title="自定义 observable"></a>自定义 observable</h3><p>有的时候，默认的 observable 的策略可能会有一些性能问题，比如为了不希望针对一些大对象全部响应式。可以通过返回自定义的 observable 来实现。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = useLocalStore(<span class="function"><span class="params">()</span> =&gt;</span> observable(&#123;</span><br><span class="line">hugeObject: &#123;&#125;,</span><br><span class="line">hugeArray: [],</span><br><span class="line">&#125;, &#123;</span><br><span class="line">hugeObject: observable.ref,</span><br><span class="line">hugeArray: observable.shallow,</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>甚至你觉得自定义程度不够的话，可以直接返回一个自定义的 store</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = useLocalStore(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> ComponentStore())</span><br></pre></td></tr></table></figure><h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><p>默认的使用方式下，最方便高效的类型定义就是通过实例推导，而不是通过泛型。这种方式既能兼顾开发效率也能兼顾代码可读性和可维护性。当然了，你想用泛型也是可以的啦</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用这种方式，直接通过对象字面量推导出类型</span></span><br><span class="line"><span class="keyword">const</span> store = useLocalStore(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">todos: [] <span class="keyword">as</span> Todo[],</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然你可以通过泛型定义，只要你不觉得烦就行</span></span><br><span class="line"><span class="keyword">const</span> store = useLocalStore&lt;&#123;</span><br><span class="line">todos: Todo[]</span><br><span class="line">&#125;&gt;<span class="function">(<span class="params">(<span class="params"></span>) =&gt; (<span class="params">&#123;todos: []&#125;</span>)</span>)</span></span><br></pre></td></tr></table></figure><p>但是这个仅仅建议用作 local store 的时候，也就是相关的数据是在本组件内使用。如果自定义 Hooks 话，建议还是使用预定义类型然后泛型的方式，可以提供更好的灵活性。</p><h3 id="memo"><a href="#memo" class="headerlink" title="memo?"></a>memo?</h3><p>当使用 useObserver api 之后，就意味着失去了 observer 装饰器默认支持的浅比较 props 跳过渲染的能力了，而此时需要我们自己手动配合 memo 来做这部分的优化</p><p>另外，memo 的性能远比 observer 的性能要高，因为 memo 并不是一个简单的 hoc</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> memo(<span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> xxx = useLocalStore(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;&#125;))</span><br><span class="line"><span class="keyword">return</span> useObserver(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (&lt;div/&gt;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="不再建议使用-useCallback-useRef-useMemo-等内置-Hooks"><a href="#不再建议使用-useCallback-useRef-useMemo-等内置-Hooks" class="headerlink" title="不再建议使用 useCallback/useRef/useMemo 等内置 Hooks"></a>不再建议使用 useCallback/useRef/useMemo 等内置 Hooks</h3><p>上面的这几个 Hooks 都可以通过 useLocalStore 代替，内置 Hooks 对 Mobx 来说是毫无必要。而且这几个内置 api 的使用也会导致缓存的问题，建议做如下迁移</p><ul><li><p>useCallback 有两种做法</p><ul><li><p>如果函数不需要传递给子组件，那么完全没有缓存的必要，直接删除掉 useCallback 即可，或者放到 local store 中也可以</p></li><li><p>如果函数需要传递给子组件，直接放到 local store 中即可。</p></li></ul></li><li><p>useMemo 直接放到 local store，通过 getter 来使用</p></li></ul><h3 id="useEffect-or-reaction"><a href="#useEffect-or-reaction" class="headerlink" title="useEffect or reaction?"></a>useEffect or reaction?</h3><p>经常使用 useEffect 知道他有一个功能就是监听依赖变化的能力，换句话说就是可以当做 watcher 使用，而 mobx 也有自己的监听变化的能力，那就是 reaction，那么究竟使用哪种方式更好呢？</p><p>这边推荐的是，两个都用，哈哈哈，没想到吧。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">reaction(<span class="function"><span class="params">()</span> =&gt;</span> store.count, <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'changed'</span>))</span><br><span class="line">, [])</span><br></pre></td></tr></table></figure><p>说正经的，针对非响应式的数据使用 useEffect，而响应式数据优先使用 reaction。当然如果你全程抛弃原生 hooks，那么只用 reaction 也可以的。</p><h3 id="组合？拆分？"><a href="#组合？拆分？" class="headerlink" title="组合？拆分？"></a>组合？拆分？</h3><p>逻辑拆分和组合，是 Hooks 很大的一个优势，在 mobx 加持的时候，这个有点依旧可以保持。甚至在还更加简单。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCustomHooks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 推荐使用全局 Store 的规则来约束自定义 Hooks</span></span><br><span class="line"><span class="keyword">const</span> store = useLocalStore(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">count: <span class="number">0</span>,</span><br><span class="line">setCount(count) &#123;</span><br><span class="line">store.count = count</span><br><span class="line">&#125;</span><br><span class="line">&#125;))</span><br><span class="line"><span class="keyword">return</span> store</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 此时这个 store 你可以从两个角度来思考</span></span><br><span class="line"><span class="comment">// 第一，他是一个 local store，也就是每一个都会初始化一个新的</span></span><br><span class="line"><span class="comment">// 第二，他可以作为全局 store 的 local 化，也就是你可以将它按照全局 store 的方式来使用</span></span><br><span class="line"><span class="keyword">const</span> store = useCustomHook()</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="comment">// ui</span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="App-Store"><a href="#App-Store" class="headerlink" title="App Store"></a>App Store</h3><p>Mobx 本身就提供了作为全局 Store 的能力，这里只说一下和 Hooks 配合的使用姿势</p><p>当升级到 mobx-react@6 之后，正式开始支持 hooks，也就是你可以简单的通过这种方式来使用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;Provider sa=&#123;saStore&#125; sb=&#123;sbStore&#125;&gt;</span><br><span class="line">&lt;Todo/&gt;</span><br><span class="line">&lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export function Todo() &#123;</span></span><br><span class="line"><span class="regexp">const &#123;sa, sb&#125; = useContext(MobxProviderContext)</span></span><br><span class="line"><span class="regexp">return (</span></span><br><span class="line"><span class="regexp">&lt;div&gt;&#123;sa.foo&#125; &#123;sb.bar&#125;&lt;/</span>div&gt;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Context-永远是数据共享的方案，而不是数据托管的方案，也就是-Store"><a href="#Context-永远是数据共享的方案，而不是数据托管的方案，也就是-Store" class="headerlink" title="Context 永远是数据共享的方案，而不是数据托管的方案，也就是 Store"></a>Context 永远是数据共享的方案，而不是数据托管的方案，也就是 Store</h3><p>这句话怎么理解数据共享和组件通讯呢？举个例子</p><ul><li><p>有一些基础的配置信息需要向下传递，比如说 Theme。而子组件通常只需要读取，然后做对应的渲染。换句话说数据的控制权在上层组件，是上层组件共享数据给下层组件，数据流通常是单向的，或者说主要是单向的。这可以说是数据共享</p></li><li><p>而有一些情况是组件之间需要通讯，比如 A 组件需要修改 B 组件的东西，这种情况下常见的做法就是将公共的数据向上一层存放，也就是托管给上层，但是使用控制权却在下层组件。其实这就是全局 Store，也就是 Redux 这类库做的事情。可以看出来数据流通常是双向的，这就可以算作数据托管</p></li></ul><p>曾经关注过 Hooks 的发展，发现很多人在 Hooks 诞生的时候开始尝试用 Context + useReducer 来替换掉 Redux，我觉得这是对 Context 的某种曲解。</p><p>原因就是 Context 的更新问题，如果作为全局 Store，那么一定要在根组件上挂载，而 Context 检查是否发生变化是通过直接比较引用，那么就会造成任意一个组件发生了变化，都会导致从 Provider 开始的整个组件树发生重新渲染的情况。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, init)</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="comment">// 每次当子组件调用 dispatch 之后，会导致 state 发生变化，从而导致 Provider 的 value 变化</span></span><br><span class="line"><span class="comment">// 进而让所有的子组件触发刷新</span></span><br><span class="line">&lt;GlobalContext.Provider value=&#123;&#123;...state, dispatch&#125;&#125;&gt;</span><br><span class="line">&#123;<span class="comment">/* child node */</span>&#125;</span><br><span class="line">&lt;<span class="regexp">/GlobalContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>而如果你想避免这些问题，那就要再度封装一层，这和直接使用 Redux 也就没啥区别了。</p><p>主要是 Context 的更新是一个性能消耗比较大的操作，当 Provider 检测到变化的时候，会遍历整颗 Fiber 树，比较检查每一个 Consumer 是否要更新。</p><p>专业的事情交给专业的来做，使用 Redux Mobx 可以很好的避免这个问题的出现。</p><h3 id="如何写好一个-Store"><a href="#如何写好一个-Store" class="headerlink" title="如何写好一个 Store"></a>如何写好一个 Store</h3><p>知道 Redux 的应该清楚他是如何定义一个 Store 吧，官方其实已经给出了比较好的最佳实践，但在生产环境中，使用起来依旧很多问题和麻烦的地方。于是就诞生了很多基于 Redux 二次封装的库，基本都自称简化了相关的 API 的使用和概念，但是这些库其实大大增加了复杂性，引入了什么 namespace/modal 啥的，我也记不清了，反正看到这些就自动劝退了，不喜欢在已经很麻烦的东西上为了简化而做的更加麻烦。</p><p>而 Mobx 这边，官方也有了一个很好的<a href="https://mobx.js.org/best/store.html" target="_blank" rel="noopener">最佳实践</a>。我觉得是很有道理，而且是非常易懂易理解的。</p><p>但还是那个问题，官方在有些地方还是没有进行太多的约束，而在开发中也遇到了类似的问题，所以这里在基于官方的框架下有几点意见和建议：</p><ul><li><p>保证所有修改 store 的操作都只能在 store 内部操作，也就是说你要通过调用 store 上的 action 方法更新 store，坚决不能在外部直接修改 store 的 property 的值。</p></li><li><p>保证 store 的可序列化，方便 SSR 的使用以及一些 debug 的功能</p><ul><li><p>类构造函数的第一个参数永远是初始化的数据，并且类型保证和 toJSON 的返回值的类型一致</p></li><li><p>如果 store 不定义 toJSON 方法，那么要保证 store 中的数据不存在不可序列化的类型，比如函数、DOM、Promise 等等类型。因为不定义默认就走 JSON.stringify 的内置逻辑了</p></li></ul></li><li><p>store 之间的沟通通过构造函数传递实现，比如 ThemeStore 依赖 GlobalStore，那么只需要在 ThemeStore 的构造参数中传入 GlobalStore 的实例即可。不过说到这里，有的人应该会想到，这不就是手动版本的 DI 么。没错，DI 是一个很好的设计模式，但是在前端用的比较轻，就没必要引入库来管理了，手动管理下就好了。也通过这种模式，可以很方便的实现 Redux 那种 namespace 的概念以及子 store</p></li><li><p>如果你使用 ts 开发，那么建议将实现和定义分开，也就是说分别定义一个 interface 和 class，class 继承 Interface，这样对外也就是组件内只需要暴露 interface 即可。这样可以很方便的隐藏一些你不想对外部暴露的方法，但内部却依旧要使用的方法。还是上面的例子，比如 GlobalStore 有一个属性是 ThemeStore 需要获取的，而不希望组件获取，那么就可以将方法定义到 class 上而非 interface 上，这样既能有良好的类型检查，又可以保证一定的隔离性。</p></li></ul><p>是的，基本上这样就可以写好一个 Store 了，没有什么花里胡哨的概念，也没有什么乱七八糟的工具，约定俗成就足以。我向来推崇没有规则就是最大的规则，没有约束就是最大的约束。很多东西能约定俗成就约定俗成，落到纸面上就足够了。完全没必要做一堆 lint/tools/library 去约束，既增加了前期开发成本，又增加了后期维护成本，就问问你司内部有多少 dead 的工具和库？</p><p>俗话说的话，「秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人而复哀后人也」，这就是现状（一巴掌打醒）</p><p>不过以上的前提是要求你们的开发团队有足够的开发能力，否则新手很多或者同步约定成本高的话，搞个库去约束到也不是不行（滑稽脸）</p><h2 id="缺点？"><a href="#缺点？" class="headerlink" title="缺点？"></a>缺点？</h2><p>说了这么多，也不是说是万能的，有这个几个缺点</p><ul><li><p>针对一些就带状态的小组件，性能上还不如原生 hooks。可以根据业务情况酌情针对组件使用原生 hooks 还是 mobx hooks。而且针对小组件，代码量可能相应还是增多。因为每次都要包裹 <code>useObserver</code> 方法。</p></li><li><p>mobx 就目前来看，无法很好在未来使用异步渲染的功能，虽然我觉得这个功能意义不大。某种程度上说就是一个障眼法，不过这个思路是值得一试的。</p></li><li><p>需要有一定 mobx 的使用基础，如果新手直接上来写，虽然能避免很多 hooks 的坑，但是可能会踩到不少 mobx 坑</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Mobx 在我司的项目中已经使用了很久了，但 Hooks 也是刚刚使用没多久，希望这个能给大家帮助。也欢迎大家把遇到的问题一起说出来，大家一起找解决办法。</p><p>我始终觉得基于 Mutable 的开发方式永远是易于理解、上手难度最低的方式，而 Immutable 的开发方式是易维护、比较稳定的方式。这两者没必要非此即彼，而 Mobx + React 可以认为很好的将两者整合在一起，在需要性能的地方可以采用 Immutable 的方式，而在不需要性能的地方，可以用 Mutable 的方式快速开发。</p><p>当然了，你就算不用 Mobx 也完全没有问题，毕竟原生的 Hooks 的坑踩多了之后，习惯了也没啥问题，一些小项目，我也会只用原生 Hooks 的（防杠声明）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;本文主要讲解了下我平时在工作开发中遇到的关于 Hooks 的一些缺点和问题，并尝试配合 Mobx 解决这些问题的经历。我觉得两者的配合可以极
      
    
    </summary>
    
      <category term="Frontend" scheme="https://blog.xgheaven.com/categories/Frontend/"/>
    
    
      <category term="React" scheme="https://blog.xgheaven.com/tags/React/"/>
    
      <category term="React Hooks" scheme="https://blog.xgheaven.com/tags/React-Hooks/"/>
    
      <category term="Mobx" scheme="https://blog.xgheaven.com/tags/Mobx/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks 究竟有多慢？</title>
    <link href="https://blog.xgheaven.com/2020/02/06/how-much-slow-about-react-hooks/"/>
    <id>https://blog.xgheaven.com/2020/02/06/how-much-slow-about-react-hooks/</id>
    <published>2020-02-05T16:00:00.000Z</published>
    <updated>2023-09-16T15:51:09.755Z</updated>
    
    <content type="html"><![CDATA[<p>自从 Hooks 诞生以来，官方就有考虑到了性能的问题。添加了各种方法优化性能，比如 memo、hooks deps、lazy initilize 等。而且在官方 FAQ 中也有讲到，Function 组件每次创建闭包函数的速度是非常快的，而且随着未来引擎的优化，这个时间进一步缩短，所以我们这里根本不需要担心函数闭包的问题。</p><p>当然这一点也通过我的实验证实了，确实不慢，不仅仅是函数闭包不慢，就算是大量的 Hooks 调用，也是非常快的。简单来说，1 毫秒内大约可以运行上千次的 hooks，也就是 <code>useState</code> <code>useEffect</code> 的调用。而函数的创建，就更多了，快的话十万次。</p><p>很多人都觉得既然官方都这么说了，那我们这么用也就好了，不需要过分担心性能的问题。我一开始也是这样想的。但是直到最近有一次我尝试对公司项目里面一个比较复杂的组件用 Hooks 重写，我惊奇的发现重渲染时间竟然从 2ms 增长到了 4ms。业务逻辑没有任何变化，唯一的变的是从 Class 变成了 Hooks。这让我有点难以相信，我一直觉得就算是慢也不至于慢了一倍多吧，怎么着两者差不多吧。于是我开始无差别对比两个写法的性能区别。</p><h2 id="懒人阅读指南"><a href="#懒人阅读指南" class="headerlink" title="懒人阅读指南"></a>懒人阅读指南</h2><p>我相信肯定很多懒人不想看下面的分析，想直接看结果。没问题，满足你们，直接通过目录找到最后看「总结」就好了，如果你觉得有问题或者觉得我说的不对，可以重新仔细阅读一下文章，帮我指出哪里有问题。</p><h2 id="为什么有这篇文章"><a href="#为什么有这篇文章" class="headerlink" title="为什么有这篇文章"></a>为什么有这篇文章</h2><p>其实我原本不是很想写一篇文章的，因为我觉得这个只是很简单的一个对比。于是我只是在掘金的沸点上随口吐槽了两句，结果……我决定写一篇文章。主要是觉得这群人好 two，就算是质疑也应该先质疑我的测量方式，而不是说我的使用方式。都用了这么多年了，还能用错）滑稽脸</p><img src="/2020/02/06/how-much-slow-about-react-hooks/d2226e34-5a04-4bef-a525-129141b5dc8b.jpg"><p>不过既然要写，就写的完备一些，尽量把一些可能的情况都覆盖了，顺便问问大家是否有问题。如果大家对下面的测试方法或者内容有任何问题的话，请大家正常交流哦，千万不要有一些过激或者偏激的言论。因为性能测试这东西，一人一个方法，一人一个想法。</p><p>既然说道这里，其实有一点我要说，沸点里面说到的 50% 这个测量数据确实有些问题。主要有这么几个原因，第一，我当初只是想抱着试试的心态，于是就直接在开发模式下运行的。第二，平时写代码写习惯了，就直接用了 <code>Date.now()</code> 而没有使用精度更高 <code>performance.now()</code> 从而导致了误差略微有点大。虽然误差略大，但是大方向还是没错的</p><p>后文的测试中，我也将这些问题修复了，尽量给大家一个正确的数据。</p><h2 id="开始之前，我们要知道……"><a href="#开始之前，我们要知道……" class="headerlink" title="开始之前，我们要知道……"></a>开始之前，我们要知道……</h2><p>假设现在有 <code>HookComp</code> 和 <code>ClassComp</code> 两个组件分别表示函数式组件和类组件，后文用 Hook(HC) 和 Class(CC) 代替。</p><h3 id="功能定义"><a href="#功能定义" class="headerlink" title="功能定义"></a>功能定义</h3><p>为了更加贴近实际，这里假设两个组件都要完成相同的一个功能。那就是<strong>用户登录</strong>这个流程：</p><ul><li><p>有用户名输入框和密码输入框</p></li><li><p>有一个登录按钮，点击之后校验用户名是否为 <code>admin</code> 且密码为 <code>admin</code></p></li><li><p>如果校验成功，下方提示登录成功，否则提示用户名或者密码错误</p></li><li><p>每次输入内容，都将清空内容</p></li><li><p>另外为了消除误差，额外添加一个按钮，用于触发 100 次的 render，并 log 出平均的渲染时间。</p></li></ul><img src="/2020/02/06/how-much-slow-about-react-hooks/3936f68c-543c-42b6-854e-3bf13a868c66.png" title="DEMO"><p>具体的业务逻辑的实现，请看后面的 DEMO 地址。</p><p>另外因为 Class 组件有 setState 可以自动实现 batch 更新，但是 Hook 不行，所以这里实现的时候把所有的更新操作都放在 React 事件中同步更新，众所周知，React 的事件是自带 batch 更新的，从而保证只有一次渲染。保证两者功能效果一致。</p><h3 id="对比常量"><a href="#对比常量" class="headerlink" title="对比常量"></a>对比常量</h3><ul><li><p>2018 款 15 寸 MacBook Pro 入门款，i7-8750H 6 核 12 线程 + 16g + 256g</p></li><li><p>Chrome Stable 79.0.3945.117</p></li><li><p>react <code>16.12.0</code> PS: 其实我从 <code>16.8.0</code> 就开始测试了，懒癌发作一直没有继续搞</p></li><li><p>react-dom <code>16.12.0</code></p><p>React 全家桶版本全部使用<strong>生产模式</strong>，降低开发模式的影响。</p></li></ul><h3 id="衡量标准：从函数调用到渲染到-DOM-上的时间"><a href="#衡量标准：从函数调用到渲染到-DOM-上的时间" class="headerlink" title="衡量标准：从函数调用到渲染到 DOM 上的时间"></a>衡量标准：从函数调用到渲染到 DOM 上的时间</h3><p>这个时间其实当组件量非常大的时候其实是不准的，因为大家调用的时间是不同的，但是渲染到 DOM 上的时间基本是一致的，就会导致在组件树越浅越前的组件测量出来的时间就会越长。但是这里的情况是页面只有一个对比组件，所以可以暂时用这个作为衡量标准。</p><p>针对 HC 来说</p><ul><li><p>在组件运行的一开始就记录为开始时间</p></li><li><p>使用 <code>useLayoutEffect</code> 的回调作为结束时间。该 Hook 会在组件挂载或者更新 DOM 之后同步调用。而 <code>useEffect</code> 会在下一个 tick 调用，如果使用该 hook 就会导致最终测量出来的结果普遍慢一些。</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hooks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> now = performance.now()</span><br><span class="line">useLayoutEffect(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(performance.now() - now))</span><br><span class="line"><span class="keyword">return</span> (<span class="comment">/* ui */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对 CC 来说</p><ul><li><p>当运行 render 方法的时候，记录时间</p></li><li><p>当运行 <code>componentDidUpdate</code> 或者 <code>componentDidMount</code> 的时候，打印耗时。这两个钩子都是在组件挂载或者更新 DOM 之后同步调用，与 <code>useLayoutEffect</code> 调用时机一致。</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Class <span class="keyword">extends</span> Component &#123;</span><br><span class="line">componentDidMount = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.log()</span><br><span class="line">componentDidUpdate = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.log()</span><br><span class="line">log = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(performance.now() - <span class="keyword">this</span>.now)</span><br><span class="line">render() &#123;</span><br><span class="line"><span class="keyword">this</span>.now = performance.now()</span><br><span class="line"><span class="keyword">return</span> (<span class="comment">/* ui */</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试流程和结果计算"><a href="#测试流程和结果计算" class="headerlink" title="测试流程和结果计算"></a>测试流程和结果计算</h3><ul><li><p>页面刷新，此时要针对测试内容先进行 5 轮预热测试。目的是为了让 Chrome 对热区代码进行优化，达到最高的性能。</p></li><li><p>每一轮包含若干次的渲染，比如 100 次或者 50 次，对于每一轮测试，都会抛弃 5% 最高和最低一共 10% 的数据，只保留中间的值，并对这些值计算平均值得到该轮测试结果</p></li><li><p>然后进行 5 轮正常测试，记录每次的结果，统计平均值。</p></li><li><p>将此时的值计算作为最终的数据值</p></li></ul><h3 id="DEMO-地址"><a href="#DEMO-地址" class="headerlink" title="DEMO 地址"></a>DEMO 地址</h3><ul><li><p>代码：<a href="https://codesandbox.io/s/how-much-hooks-slow-hso28" target="_blank" rel="noopener">CodeSandBox</a> </p></li><li><p>展示地址：<a href="https://csb-hso28.netlify.com/" target="_blank" rel="noopener">https://csb-hso28.netlify.com/</a></p></li></ul><p>PS: CodeSandBox 似乎不能以生产模式运行，不过你可以将它一键部署到 ZEIT 或者 netlify 上面，查看生产环境的效果。</p><h2 id="开胃菜-重渲染测试结果"><a href="#开胃菜-重渲染测试结果" class="headerlink" title="开胃菜-重渲染测试结果"></a>开胃菜-重渲染测试结果</h2><p>最为开胃菜，用一个最常见的场景来测试实在是最合适不过了，那就是组件的重渲染。话说不多，直接上测试结果</p><table><thead><tr><th>Avg. Time(ms)</th><th>Hook Slow</th><th>Hook(Self)</th><th>Class</th><th>Class(Self)</th><th>Hook</th><th>Self</th></tr></thead><tbody><tr><td>第五次平均时间</td><td>0.171808623414</td><td>0.04126375367107627</td><td>0.1941208809532307</td><td>0.024725271102327567</td><td>0.22747252228577713</td><td>0.6688898374583169</td></tr><tr><td>第四次平均时间</td><td>0.1696739222</td><td>0.04082417709159327</td><td>0.18879122377096952</td><td>0.02120880942259516</td><td>0.22082417118516598</td><td>0.9248688730306829</td></tr><tr><td>第三次平均时间</td><td>0.160409555184</td><td>0.04109888910674132</td><td>0.1931868181410399</td><td>0.022967028748858104</td><td>0.22417582970644748</td><td>0.7894734907224213</td></tr><tr><td>第二次平均时间</td><td>0.130965058748</td><td>0.045824176785382593</td><td>0.2072527365001676</td><td>0.02346153545019391</td><td>0.23439560331158585</td><td>0.953161884168321</td></tr><tr><td>第一次平均时间</td><td>0.216216175927</td><td>0.04549450906259673</td><td>0.20939560484263922</td><td>0.02357143663115554</td><td>0.2546703217776267</td><td>0.9300694214990858</td></tr></tbody></table><p>简单解释下数据，Hook 和 Class 是通过上面规定的方式统计出来的数据，而 Hook(Self) Class(Self) 是计算了 HC 和 CC 函数调用的时间，最后的 Self 和 Hook Slow 则是 Hook 相比 Class 慢的百分比。这里只需要关注不带 Self 的数据即可。</p><p>让我们来细细「品味」一下，Hook 比 Class 慢了 16%。</p><p>等等？？？ 16%，emmm……乍一听这是一个多么惊人的数字，5 % 的性能降低都很难接受了，何况是 16%。如果你的页面中有上百个这样组件，想想都知道……咦~~~那酸爽</p><p>Wait!!! 或许有人会说了，抛开数值大小谈相对值，这根本就是耍流氓么。每个组件组件都是毫秒级别的渲染，这么小的级别作比较误差也会很大。而且你的测试的测量方式真的很对么？为啥看到很多文章说 Hooks 性能甚至比 Class 组件还高啊。而且你这个测量真的准确么？</p><p>这里先回答一下测量的问题，上面也说了，useLayoutEffect 和 CDU/CDM 基本是一致的，而且为了佐证，这里直接上 Performance 面板的数据，虽然只能在开发模式下才能看到这部分数据，但依旧具有参考意义</p><img src="/2020/02/06/how-much-slow-about-react-hooks/c9566ca6-24bf-4afa-a39a-3af55953b1d9.png" title="Hooks"><img src="/2020/02/06/how-much-slow-about-react-hooks/94335857-9c76-43a7-8067-503032ae5511.png" title="Class"><p>当然因为我这里只是截取了一个样例，没法给大家一个平均的值，但是如果大家多次尝试可以发现就算是 React 自己打的标记点，Class 也会比 Hook 快那么一点点。</p><p>而针对更多的疑问，这里我们就基于这个比较结果，引申出更多的比较内容，来逐步完善：</p><ul><li><p>挂载性能如何？也就是第一次渲染组件</p></li><li><p>大量列表渲染性能如何？没准渲染的组件多了，性能就不会呈现线性叠加呢？</p></li><li><p>当 Class 被很多 HOC 包裹的时候呢？</p></li></ul><h2 id="其他对比"><a href="#其他对比" class="headerlink" title="其他对比"></a>其他对比</h2><h3 id="挂载性能"><a href="#挂载性能" class="headerlink" title="挂载性能"></a>挂载性能</h3><p>通过快速卸载挂载 40 次计算出平均时间，另外将两者横向布局，降低每次挂载卸载的时候 Chrome Layout&amp;Paint 上的差异。话不多说，直接上结果</p><table><thead><tr><th>Avg. Time(ms)</th><th>Hook Slow(%)</th><th>Hook(Self)</th><th>Class(Self)</th><th>Hook</th><th>Class</th></tr></thead><tbody><tr><td>第三次平均时间</td><td>0.100681682204</td><td>0.04797298587053209</td><td>0.024729729252489837</td><td>0.5672973001728187</td><td>0.5154054158845464</td></tr><tr><td>第二次平均时间</td><td>0.137816482105</td><td>0.041216209128096294</td><td>0.02486483395301007</td><td>0.6013513618224376</td><td>0.5285134916571347</td></tr><tr><td>第四次平均时间</td><td>0.009446076914</td><td>0.04378377736822979</td><td>0.025405410073093465</td><td>0.5343243404216057</td><td>0.5293243023491389</td></tr><tr><td>第五次平均时间</td><td>0.05774346214</td><td>0.041081066671255474</td><td>0.025540552529934292</td><td>0.5371621495263802</td><td>0.5078378347428264</td></tr><tr><td>第一次平均时间</td><td>0.036722530281</td><td>0.04027024968653112</td><td>0.025810805980015446</td><td>0.5608108209295047</td><td>0.5409459180727199</td></tr></tbody></table><p>通过交替运行连续跑 5 轮 40 次测试，可以得到上面这个表格。可以发现，不管那一次运行，都是 Class 时间会少于 Hook 的时间。通过计算可得知，Hook 平均比 Class 慢了 (0.53346 - 0.49811) / 0.49811 = 7%，绝对差值为 0.03535ms。</p><p>这个的性能差距可以说是很少了，如果挂载上百个组件的时候，两者差距基本是毫秒内的差距。而且可以看出来，绝对值的差距可以说是依旧没有太多的变化，甚至略微微微微减少，可以简单的认为其实大部分的时间依旧都花费在一些常数时间上，比如 DOM。</p><h3 id="大列表性能"><a href="#大列表性能" class="headerlink" title="大列表性能"></a>大列表性能</h3><p>通过渲染 100 个列表的数据计算出平均时间。</p><table><thead><tr><th>Avg. Time(ms)</th><th>Hook(500)</th><th>Hook</th><th>Hook Slow(%,500)</th><th>Hook Slow(%)</th><th>Class(500)</th><th>Class</th></tr></thead><tbody><tr><td>第二次平均时间</td><td>9.59723405143682</td><td>2.6090425597701934</td><td>0.10286063613</td><td>0.104480973312</td><td>8.702127664211266</td><td>2.3622340473168073</td></tr><tr><td>第三次平均时间</td><td>9.64329787530005</td><td>2.5888297637488615</td><td>0.10438723417</td><td>0.104028668798</td><td>8.731808533218313</td><td>2.344893603684737</td></tr><tr><td>第一次平均时间</td><td>9.55063829376818</td><td>2.5251063647026077</td><td>0.085798601307</td><td>0.081415992606</td><td>8.795957447604296</td><td>2.335000020313136</td></tr><tr><td>第五次平均时间</td><td>9.597553207756992</td><td>2.571702087694343</td><td>0.10075770158</td><td>0.15273472846</td><td>8.719042523149797</td><td>2.230957413012994</td></tr><tr><td>第四次平均时间</td><td>9.604468084673615</td><td>2.567340426662184</td><td>0.095974553092</td><td>0.0995534837</td><td>8.76340427574642</td><td>2.334893631570517</td></tr></tbody></table><p>我们先不计算下慢了多少，先看看这个数值，100 次渲染一共 2ms 多，平均来说一次 0.02ms，而而我们上面测试的时候发现，单独渲染一个组件，平均需要 0.2ms，这中间的差距是有点巨大的。</p><p>而如何合理解释这个问题呢？只能说明在组件数小的时候，React 本身所用的时间与组件的时间相比来说比例就会比较大，而当组件多了起来之后，这部分就变少了。</p><p>换句话说，React Core 在这中间占用了多少时间，我们不得而知，但是我们知道肯定是不少的。</p><h3 id="HOC"><a href="#HOC" class="headerlink" title="HOC"></a>HOC</h3><p>Hook 的诞生其实就是为了降低逻辑的复用，简单来讲就是简化 HOC 这种方式，所以和 Hook 对线的其实是 HOC。最简单的例子，Mobx 的注入，就需要 inject 高阶组件包裹才可以，但是对于 Hook 来讲，这一点完全不需要。</p><p>这里测试一下 Class 组件被包裹了 10 层高阶组件的情况下的性能，每一层包裹的组件做的事情非常简单，那就是透传 props。</p><p>啥？你说根本不可能套 10 层？其实也是很容易的，你要注意这里我们所说的 10 层其实是指有 10 层组件包裹了最终使用的组件。比如说大家都知道 mobx inject 方法或者 redux 的 connect 方法，看似只被包裹了一层，其实是两层，因为还有一层 <code>Context.Consumer</code>。同理你再算上 History 的 HOC，也是一样要来两层的。再加上一些其他的东西，再加一点夸张不就够了，手动滑稽）</p><table><thead><tr><th>Avg. Time(ms)</th><th>Class With 10 HOC</th></tr></thead><tbody><tr><td>第五轮</td><td>0.25384614182697546</td></tr><tr><td>第四轮</td><td>0.27269232207602195</td></tr><tr><td>第二轮</td><td>0.2821977993289193</td></tr><tr><td>第三轮</td><td>0.278846147951189</td></tr><tr><td>第一轮</td><td>0.2710439444898249</td></tr></tbody></table><p>这结果也就是很清楚了吧，在嵌套较多 HOC 的时候，Class 的性能其实并不好，从 0.19855ms 增加到 0.27173ms，时间接近有 26% 的增加。而这个性能不好并不是因为 Class，而是因为渲染的组件过多导致的。从另一个角度，hook 就没有这种烦恼，即使是大量 Hook 调用性能依旧在可接受范围内。</p><h2 id="量化娱乐一下？"><a href="#量化娱乐一下？" class="headerlink" title="量化娱乐一下？"></a>量化娱乐一下？</h2><p>有了上面的数据，来做一个有意思的事情，将数据进行量化。</p><p>假设有如下常数，<code>r</code> 表示 React 内核以及其他和组件数无关的常数，<code>h</code> 表示 hook 组件的常数，而 <code>c</code> 表示 Class 组件的常数，<code>T</code> 表示最终所消耗的时间。可以得知这四个参数肯定不为负数。</p><p>通过简单的假设，可以得到如下等式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T(n,m) = hn + cm + r</span><br><span class="line">// n 表示 hook 组件的数量</span><br><span class="line">// m 表示 class 组件的数量</span><br></pre></td></tr></table></figure><p>想要计算得到 <code>r</code> <code>h</code> <code>c</code>  参数也很–简单–，简单个鬼，因为数据不是准确的，不能直接通过求解三元一次方程组的方式，而是要通过多元一次拟合的方式求得，而我又不想装 matlab，于是千辛万苦找到一个支持在线计算多元一次方程的网站算了下，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">h = 0.0184907294</span><br><span class="line">c = 0.01674766395</span><br><span class="line">r = 0.4146159332</span><br><span class="line">RSS = 0.249625719</span><br><span class="line">R^2 = 0.9971412136</span><br></pre></td></tr></table></figure><p>这个拟合的结果有那么一点点差强人意，因为如果你把单个 Class 或者 Hook 的结果代入的话，会发现偏差了有一倍多。所以我上面也说道只是娱乐娱乐，时间不够也没法细究原因了。不过从拟合的结果上来看，也能发现一个现象，那就是 h 比 c 要大。</p><p>另外观察最后的拟合度，看起来 0.99 很大了，但实际上并没有什么意义。而且这里数据选取的也不是很好，做拟合最好还是等距取样，这样做出来的数据会更加准确。这里只是突然奇想想要玩玩看，所以就随便做了下。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不管你是空降过来的还是一点点阅读到这里的，我这边先直接说基于上面的结论：</p><ul><li><p>当使用 Hook 的时候，整体性能相比 Class 组件会有 10 - 20% 的性能降低。</p></li><li><p>当仅仅使用函数式组件，而不使用 Hook 的时候，性能不会有降低。也就是说可以放心使用纯函数式组件</p></li><li><p>Hook 的性能降低不仅仅体现在渲染过程，就算是在第一次挂载过程中，也相比 Class 有一定程度的降低</p></li><li><p>Hook 的性能降低有三部分</p><ul><li><p>第一部分是 Hook 的调用，比如说 <code>useState</code> 这些。但是这里有一点需要注意的是，这里的调用指的是有无，而不是数量。简单来说就是从 0 到 1，性能降低的程度远远高于 从 1 到 n。</p></li><li><p>第二部分是因为引入 Hook 而不得不在每次渲染的时候创建大量的函数闭包，临时对象等等</p></li><li><p>第三部分是 React 对 Hook 处理所带来的额外消耗，比如对 Hook 链表的管理、对依赖的处理等等。随着 Hook 的增加，这些边际内容所占用的时间也会变得越来越大。</p></li></ul></li><li><p>但 Hook 有一点很强，在逻辑的复用上，是远高于 HOC 方式，算是扳回一局。</p></li></ul><p>所以 Hook 确实慢，慢的有理有据。但究竟用不用 Hooks 就全看，我不做定夺。凡事都有两面，Hooks 解决了 Class 一些短板，但是也引入了一些不足。如果一定要我推荐的话，我推荐 Hooks+Mobx。</p><h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><ul><li><a href="http://www.xuru.org/rt/MLR.asp" target="_blank" rel="noopener">多元一次方程在线拟合</a></li></ul><h2 id="One-More"><a href="#One-More" class="headerlink" title="One More"></a>One More</h2><p>以上内容是我花了快一个月一点点整理出来的，甚至还跨了个与众不同的「年」。性能测试本身就是一个很有争议的东西，不同的写法不同的测试方式都会带来不同的结果。我也是在这期间一点点修改我的测试内容，从最开始只有单组件测试，到后来添加了组件列表的测试，以及挂载的测试。另外对数据收集也修改了很多，比如多次取平均值，代码预热等等。每一次修改都意味着所有测试数据要重新测试，但我只是想做到一个公平的对比。</p><p>就在现在，我依旧会觉得测试里面有很多内容依旧值得去改进，但是我觉得拖的时间太长了，而且我认为把时间花在从源码角度分析为什么 Hook 比 Class 慢上远比用数据证明要有意义的多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自从 Hooks 诞生以来，官方就有考虑到了性能的问题。添加了各种方法优化性能，比如 memo、hooks deps、lazy initilize 等。而且在官方 FAQ 中也有讲到，Function 组件每次创建闭包函数的速度是非常快的，而且随着未来引擎的优化，这个时间进
      
    
    </summary>
    
      <category term="Frontend" scheme="https://blog.xgheaven.com/categories/Frontend/"/>
    
    
      <category term="React" scheme="https://blog.xgheaven.com/tags/React/"/>
    
      <category term="React Hooks" scheme="https://blog.xgheaven.com/tags/React-Hooks/"/>
    
  </entry>
  
  <entry>
    <title>如何使用自签名 CA 和证书来保护个人在公网上的内容</title>
    <link href="https://blog.xgheaven.com/2019/10/13/use-self-signed-ca-to-protect-your-self-content/"/>
    <id>https://blog.xgheaven.com/2019/10/13/use-self-signed-ca-to-protect-your-self-content/</id>
    <published>2019-10-12T16:00:00.000Z</published>
    <updated>2023-09-16T15:51:09.750Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个喜欢折腾的人，个人搞了很多东西放在自己的服务器上，但是为了方便，能够在世界各地随时随地的打开查看和使用，我将服务器暴露到了公网中，当然了有些在公有云上的本来就暴露出来的。</p><p>那么这里就有一个问题，我如何保护我的信息只能我来查看呢？</p><ul><li><p>最简单的方法就是通过 HTTP Basic Auth + HTTPS。记住一定要上 https，否则你的密码也是会泄漏的。为什么说简单呢？因为只需要在 Nginx 或 Traefik 上配置下就可以了。但是这个方案有一个非常麻烦的问题，就是过一段时间之后就要输入用户名和密码。时间短了，到无所谓，时间一长就会觉得很烦。</p></li><li><p>构建一套 token 验证体系，不管是使用 oauth 也好还是 jwt 也好，都是可以的。安全性也是可以保证的，而且设置好 token 的时间长度，也能保证避免频繁的输入密码。但是这有一个问题就是实现起来太过于复杂，都快赶上公司的一套系统了。而且还要有各种登录页面，想想都烦。</p></li><li><p>与上面类似，不过验证方式使用 Two Auth，也就是基于时间的 6 位数组。但是依旧比较复杂。</p></li><li><p>使用 OpenVPN 的方式。这在一定程度上也能使用，但是对于我来说，OpenVPN 的限制还是比较大的。首先安卓手机无法开启两个 VPN，而且我也不能一直连着 VPN，因为我会部署一些经常用的服务。而且我不是为了能够连接到内网，而是想对外网使用的服务添加验证。</p></li></ul><p>我想了许久，有没有一种不需要输入密码，就可以验证安全的呢？因为是我一个人使用的，所以我根本不需要多用户系统，也就是说验证方式只需要一个密码就可以了。这我突然想起了之前在写 gRPC 的时候有一个双向验证的参数，也可以验证客户端可以不可以。当时觉得只是他们基于 h2 改的协议，结果我一查发现这原来就包含在 https 里面，准确说是 SSL 规范里面。（怪自己当初上计算机网络的时候没好好学这部分，竟然连这个都不知道）</p><p>那么至此，思路就很清晰了，给我的所有个人服务都添加 https 客户端校验。只要我的证书够安全，我的页面就是安全的（反正都是我个人的东西，直接拿着 U 盘到处拷贝，手机 Pad 用数据线发送，我就不信这样谁还能盗走我的证书，傲娇脸）</p><h2 id="关于-SSL-证书的一些知识"><a href="#关于-SSL-证书的一些知识" class="headerlink" title="关于 SSL 证书的一些知识"></a>关于 SSL 证书的一些知识</h2><ul><li><p>生成证书我们主要采用 <code>openssl</code> 具体的安装教程我就不讲解了，有兴趣的小伙伴自行查阅，主要有下面几个步骤：</p><ul><li><p><code>openssl genrsa</code>：生成 Private Key，用于生成请求文件使用，这里用 <code>.key</code> 后缀。</p></li><li><p><code>openssl req</code>：依赖上面生成的 Key 去生成 CSR，也就是证书请求文件。使用 <code>.csr</code> 后缀。这期间要填写一些信息，前面的几个大写字母是缩写，后面在命令行使用的时候会用到。</p><ul><li><p>C(Country) 国家</p></li><li><p>ST(State/Province) 州或者省</p></li><li><p>L(Locality) 地区，国内写区即可</p></li><li><p>O(Organization) 组织</p></li><li><p>OU(Organization) 组织单位</p></li><li><p>CN(Common Name) 通用名，这个是非常重要的，影响了证书的显示名称和 HTTPS 的域名。</p></li></ul></li><li><p><code>openssl x509</code>：根据 x509 规范，利用 CA 的证书和私钥将 CSR 文件加密成真正可以使用到的证书。使用 <code>.crt</code> 后缀</p></li></ul></li><li><p>SSL 证书必须要采用 sha-2 加密算法。2015 年 12 月 31 日前，CA 机构还会颁发 SHA-1 签名的证书，但是之后只会签发 SHA-2 签名的证书了。Chrome 也会对 SHA-1 签名的证书提示不安全。在 openssl 中用的是 <code>-sha-256</code> 参数。</p></li><li><p><code>CRT</code> 和 <code>PEM</code> 的关系，大家可以简单的认为 <code>PEM</code> 是将证书 base64 之后的文件，而 <code>CRT</code> 是既能 base64 也能 binary 的一种文件格式。但是通常 <code>openssl</code> 产出的是 base64 的文件，你可以通过 <code>-outform</code> 参数控制产出的类型。</p></li></ul><h2 id="CA-的生成"><a href="#CA-的生成" class="headerlink" title="CA 的生成"></a>CA 的生成</h2><p>有了 CA 我们才能去给其他的证书签名，生成 CA 的过程很简单</p><h3 id="创建根钥"><a href="#创建根钥" class="headerlink" title="创建根钥"></a>创建根钥</h3><blockquote><p>💡 这个秘钥非常重要，任何获得了这个秘钥的人在知道密码的情况下都可以生成证书。所以请小心保存</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -des3 -out root.key 4096</span><br></pre></td></tr></table></figure><ul><li><p><code>-des3</code> 标明了私钥的加密方式，也就是带有密码。建议添加密码保护，这样即使私钥被窃取了，依旧无法对其他证书签名。你也可以更换其他的加密方式，具体的请自行 help。</p></li><li><p><code>4096</code> 表示秘钥的长度。</p></li></ul><h3 id="创建自签名证书"><a href="#创建自签名证书" class="headerlink" title="创建自签名证书"></a>创建自签名证书</h3><p>因为是 CA 证书，所以没法让别人去签名，只能自签名。这里可以认为是生成 CSR 和签名两部合成一步走。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -sha256 -new -key root.key -sha256 -days 1024 -out root.crt</span><br></pre></td></tr></table></figure><h2 id="服务端证书生成"><a href="#服务端证书生成" class="headerlink" title="服务端证书生成"></a>服务端证书生成</h2><h3 id="生成证书私钥"><a href="#生成证书私钥" class="headerlink" title="生成证书私钥"></a>生成证书私钥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out your-domain.com.key 2048</span><br></pre></td></tr></table></figure><p>和 CA 证书不同，这个私钥一般不需要加密，长度也可以短一些。</p><h3 id="生成证书请求文件"><a href="#生成证书请求文件" class="headerlink" title="生成证书请求文件"></a>生成证书请求文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key your-domain.com.key -out your-domain.com.csr</span><br></pre></td></tr></table></figure><p>这期间要填入一些信息，注意 CN 的名字一定要是你的域名。</p><h3 id="使用-CA-对-CSR-签名"><a href="#使用-CA-对-CSR-签名" class="headerlink" title="使用 CA 对 CSR 签名"></a>使用 CA 对 CSR 签名</h3><p>在 Chrome 58 之前，Chrome 会根据 CN 来检查访问的域名是不是和证书的域名一致，但是在 Chrome 58 之后，改为使用 SAN(Subject Alternative Name) 而不是 CN 检查域名的一致性。</p><p>而 SAN 属于 x509 扩展里面的内容，所以我们需要通过 <code>-extfile</code> 参数来指定存放扩展内容的文件。</p><p>所以我们需要额外创建一个 <code>your-domain.com.ext</code> 文件用来保存 SAN 信息，通过指定多个 DNS 从而可以实现多域名证书。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">subjectAltName = @alt_names</span><br><span class="line"></span><br><span class="line">[alt_names]</span><br><span class="line">DNS.1 = your-domain.com</span><br><span class="line">DNS.2 = *.your-domain.com</span><br><span class="line">DNS.3 = *.api.your-domain.com</span><br></pre></td></tr></table></figure><p>以此类推，如果域名较少，还可以用另外一种简写方案。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subjectAltName = DNS: your-domain.com, DNS: *.your-domain.com</span><br></pre></td></tr></table></figure><p>关于语法的更多内容请查看<a href="https://www.openssl.org/docs/manmaster/man5/x509v3_config.html" target="_blank" rel="noopener">官方文档</a>。在有了 ext 文件之后就直接可以开始签名了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -sha256 -<span class="keyword">in</span> your-domain.com.csr -CA root.crt -CAkey root.key -CAcreateserial -out your-domain.com.crt -days 365 -extfile your-domain.com.ext</span><br></pre></td></tr></table></figure><p><code>CAcreateserial</code> 这个参数是比较有意思的，意思是如果证书没有 serial number 就创建一个，因为我们是签名，所以肯定会创建一个。序列号在这里的作用就是唯一标识一个证书，当有两个证书的时候，只有给这两个证书签名的 CA 和序列号都一样的情况下，我们才认为这两个证书是一致的。除了自定生成，还可以通过 <code>-set_serial</code> 手动指定一个序列号。</p><p>当使用 <code>-CAcreateserial</code> 参数之后，会自动创建一个和 CA 文件名相同的，但是后缀是 <code>.srl</code> 的文件。这里存储了上一次生成的序列号，每次调用的时候都会读取并 +1 。也就是说每一次生成的证书的序列号都比上一次的加了一。</p><p>现在，只需要将 <code>your-domain.com.crt</code> 和 <code>your-domain.com.key</code> 放到服务端就可以使用了。别忘了将 CA 添加系统当中，要不然浏览器访问会出现问题。</p><h2 id="客户端证书生成"><a href="#客户端证书生成" class="headerlink" title="客户端证书生成"></a>客户端证书生成</h2><p>服务端有了之后，就需要生成客户端的证书，步骤和服务端基本一致，但是不需要 SAN 信息了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out client.key 2048</span><br><span class="line"><span class="comment"># 这里也可以采用非交互形式，方便制作成命令行工具</span></span><br><span class="line">openssl req -new \</span><br><span class="line">-key client.key \</span><br><span class="line">-subj <span class="string">"/C=CN/ST=Zhejiang/O=X/CN=*.your-domain.com"</span> \ <span class="comment"># 这里的缩写就是文章一开始所说的那些缩写</span></span><br><span class="line">-out client.csr</span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> client.csr -CA root.crt -CAkey root.key -out client.crt -days 365</span><br></pre></td></tr></table></figure><p>只不过客户端验证需要的是 PKCS#12 格式，这种格式是将证书和私钥打包在了一起。因为系统需要知道一个证书的私钥和公钥，而证书只包含公钥和签名，不包含私钥，所以需要这种格式的温江将私钥和公钥都包含进来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -<span class="built_in">export</span> -clcerts -<span class="keyword">in</span> client.crt -inkey client.key -out client.p12</span><br></pre></td></tr></table></figure><p>这期间会提示你输入密码，用于安装的时候使用。也就是说不是什么人都可以安装客户端证书的，要有密码才行，这无疑又增加了一定的安全性。当然了，我试过不输入密码，但是好像有点问题，有兴趣的同学可以自己尝试下。</p><h2 id="客户端校验证书的使用"><a href="#客户端校验证书的使用" class="headerlink" title="客户端校验证书的使用"></a>客户端校验证书的使用</h2><p>这里以 Node.js 举例。使用 <code>https</code> 模块，在创建的时候和普通的创建方式基本一致，但是需要额外指定 <code>requestCert</code> 和 <code>ca</code> 参数来开启客户端校验。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">https.createServer(&#123;</span><br><span class="line">key: fs.readFileSync(<span class="string">'your-domain.com.key'</span>),</span><br><span class="line">cert: fs.readFileSync(<span class="string">'your-domain.com.crt'</span>),</span><br><span class="line">requestCert: <span class="literal">true</span>,</span><br><span class="line">ca: [fs.readFileSync(<span class="string">'root.crt'</span>)], <span class="comment">// 校验客户端证书的 CA</span></span><br><span class="line">&#125;, (req, resp) =&gt; &#123;</span><br><span class="line"><span class="comment">// blahblah</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样只要客户端没有安装合法的证书，那么整个请求就是失败的。而且根本不会进入请求处理的回调函数中，这也意味着显示的错误是浏览器的默认错误。那么这对用户来讲其实不太友好。</p><p>那么我们可以通过在参数中添加 <code>rejectUnauthorized: false</code> 来关闭这个功能，也就是说不管客户端证书校验是正确还是失败，都可以进入正常的回调流程。此时我们只需要通过 <code>req.client.authorized</code> 来判断这个请求是否通过了客户端证书的校验，可以给予用户更详尽的错误提示。</p><p>另外我们还可以通过 <code>resp.connection.getPeerCertificate()</code> 获取客户端证书的信息，甚至可以根据不同的信息选择给予不同的用户权限。</p><p>这里有一个 DEMO: <a href="https://www.xgheaven.net.cn:3443/" target="_blank" rel="noopener">https://www.xgheaven.net.cn:3443</a>，大家打开之后应该会看到一个证书校验失败的提示。这里要说下，我这里的 DEMO 没有使用自签名的服务端证书，只是使用了自签名的 CA 去检查客户端证书。因为用自己签名的服务端证书的话，浏览器会提示不安全，因为用户么有安装自签名的 CA。</p><img src="/2019/10/13/use-self-signed-ca-to-protect-your-self-content/41f19dae-c1c5-42ac-9f4d-004d654a1de5.png"><p>可以点击下载客户端证书按钮，安装客户端证书。因为客户端证书是有密码保护的，请输入页面上提示的密码。</p><p>再次刷新，如果是 Mac 系统，会提示你要使用哪个客户端证书登录，此时就说明安装成功了。</p><img src="/2019/10/13/use-self-signed-ca-to-protect-your-self-content/ecf1b91c-a04f-4989-93a2-a78f871a75bc.png"><p>点击确认，可能还要输入一个系统密码允许 Chrome 访问 Keychain，一劳永逸的话在输入密码之后选择 Always Allow，从此就不需要再输入密码了。</p><img src="/2019/10/13/use-self-signed-ca-to-protect-your-self-content/971d1090-103f-405c-9982-1017a28996dc.png"><p>按照道理，你就可以看到这个页面了。</p><img src="/2019/10/13/use-self-signed-ca-to-protect-your-self-content/a28b3a21-4688-4133-adae-df2f1c74457b.png"><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>有了这个功能，我就可以将我的所有内容全盘私有化而且还能直接暴露在公网中。配合之前毕设搞的微服务化，简直不要美滋滋。如果之前是使用账号密码登录的，也可以接入这个方案。就是将登录页面替换成证书校验就可以了。</p><h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><ul><li><p><a href="https://medium.com/@sevcsik/authentication-using-https-client-certificates-3c9d270e8326" target="_blank" rel="noopener">Authentication using HTTPS client certificates</a></p></li><li><p><a href="https://alexanderzeitler.com/articles/Fixing-Chrome-missing_subjectAltName-selfsigned-cert-openssl/" target="_blank" rel="noopener">Fixing Chrome 58+ [missing_subjectAltName] with openssl when using self signed certificates</a></p></li><li><p><a href="https://gist.github.com/fntlnz/cf14feb5a46b2eda428e000157447309" target="_blank" rel="noopener">Self Signed Certificate with custom CA</a></p></li><li><p><a href="https://www.jianshu.com/p/68c664b663f4" target="_blank" rel="noopener">散列算法：SHA-1，SHA-2和SHA-256之间的区别（下）</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一个喜欢折腾的人，个人搞了很多东西放在自己的服务器上，但是为了方便，能够在世界各地随时随地的打开查看和使用，我将服务器暴露到了公网中，当然了有些在公有云上的本来就暴露出来的。&lt;/p&gt;
&lt;p&gt;那么这里就有一个问题，我如何保护我的信息只能我来查看呢？&lt;/p&gt;
&lt;ul&gt;
&lt;l
      
    
    </summary>
    
      <category term="家庭私有环境" scheme="https://blog.xgheaven.com/categories/%E5%AE%B6%E5%BA%AD%E7%A7%81%E6%9C%89%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="SelfHost" scheme="https://blog.xgheaven.com/tags/SelfHost/"/>
    
      <category term="TLS" scheme="https://blog.xgheaven.com/tags/TLS/"/>
    
      <category term="HTTPS" scheme="https://blog.xgheaven.com/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>如何让你的 React 『变慢』？探析 Array Diff 的一些边角特性</title>
    <link href="https://blog.xgheaven.com/2019/10/07/make-your-react-to-slow/"/>
    <id>https://blog.xgheaven.com/2019/10/07/make-your-react-to-slow/</id>
    <published>2019-10-06T16:00:00.000Z</published>
    <updated>2023-09-16T15:51:09.748Z</updated>
    
    <content type="html"><![CDATA[<p>当你看到这个标题的时候，一定很好奇，React 不是很快么？为啥会变慢呢？在写这篇文章之前，我也是这么认为的，但是当我去看了一下 React 有关 Array 的 Diff 之后，我才认识到其实 React 如果你用的不正确，那么是会变慢的。</p><h2 id="React-Diff-算法"><a href="#React-Diff-算法" class="headerlink" title="React Diff 算法"></a>React Diff 算法</h2><p>React Diff 算法相信大家不是很陌生吧，这里就不具体展开讲了。不过有一点要补充下，Diff 算法针对的是整个 React 组件树，而不仅仅是 DOM 树，虽然这样性能会比较低一些，但是实现起来却很方便。</p><p>而在 Diff 算法中，针对数组的 diff 其实是比较有意思的一个地方。在开始讲解方面，我希望你能对 React 有一定的了解和使用。</p><h2 id="试一试有什么区别？"><a href="#试一试有什么区别？" class="headerlink" title="试一试有什么区别？"></a>试一试有什么区别？</h2><p>首先我们创建 3 个组件，分别渲染 10000 个 DOM 元素，从 <code>[1...10000]</code> ，渲染成如下。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> e10000 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>).map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> i + <span class="number">1</span>)</span><br><span class="line">element10000.map(<span class="function"><span class="params">i</span> =&gt;</span> &lt;div key=&#123;<span class="string">`<span class="subst">$&#123;i&#125;</span>`</span>&#125;&gt;&#123;i&#125;&lt;<span class="regexp">/div&gt;)</span></span><br></pre></td></tr></table></figure><p>每个组件有两个状态，会切换数据的顺序</p><ul><li><p>组件 A 在 <code>[1...10000]</code> 和 <code>[2,1,3...10000]</code> 之间切换。</p></li><li><p>组件 B 在 <code>[1...10000]</code> 和 <code>[10000,1...9999]</code> 之间切换</p></li><li><p>组件 C 在 <code>[1...10000]</code> 和 <code>[10000...1]</code> 之间切换，也就是正序和倒序之间切换。</p></li></ul><p>我们简单命名下，默认的初始状态为 <code>S1</code> 而切换之后的状态为 <code>S2</code> 。大家可以思考一下，同一个组件状态切换的时候，所耗费的时间是不是都是一样的？可以直接使用这个 <a href="https://codesandbox.io/s/react-slow-array-diff-example-kw112?fontsize=14" target="_blank" rel="noopener">DEMO</a>。</p><img src="/2019/10/07/make-your-react-to-slow/d859191a-15f6-4fa6-945f-7c895d22399c.png"><p>可以直接点击上方的 toggle 来切换两者之间的状态，并在控制台中查看渲染的时间。因为每次时间都不是绝对准确的，所以取了多次平均值，直接揭晓答案：</p><table><thead><tr><th>组件</th><th>S2 ⇒ S1</th><th>S1 ⇒ S2</th></tr></thead><tbody><tr><td>A</td><td>102ms</td><td>103ms</td></tr><tr><td>B</td><td>129ms</td><td>546ms</td></tr><tr><td>C</td><td>556ms</td><td>585ms</td></tr></tbody></table><p>有么有觉得很奇怪，为什么同样是 S1 ⇒ S2 ，同样是只改变了一个元素的位置，为什么 A 和 B 的时间差距有这么多的差距。这个具体原理就要从 Diff 算法开始讲起了。</p><h2 id="Array-Diff-的原理"><a href="#Array-Diff-的原理" class="headerlink" title="Array Diff 的原理"></a>Array Diff 的原理</h2><p>在讲 React 的实现之前，我们先来抛开 React 的实现独立思考一下。但是如果直接从 React 的组件角度下手会比较麻烦，首先简化一下问题。</p><p>存在两个数组 A 和 B，数组中每一个值必须要保证在对应数组内是唯一的，类型可以是字符串或者数字。那么这个问题就转变成了如何从数组 A 通过<strong>最少的</strong>变换<strong>步骤</strong>到数组 B。</p><blockquote><p>其实每个元素的值对应的就是 React 当中的 key。如果一个元素没有 key 的话，index 就是那个元素默认的 key。为什么要强调<strong>最少</strong>？因为我们希望的是能够用最少的步数完成，但是实际上这会造成计算量的加大，而 React 的实现并没有计算出最优解，而是一个较快解。</p></blockquote><p>顺便定义一下操作的类型有：<code>删除元素</code>，<code>插入元素</code>，<code>移动元素</code>。</p><p>这里又要引申一个特殊点，React 充分利用了 DOM 的特性，在 DOM 操作中，你是可以不使用 index 来索引数据的。简单来讲，如果用数组表示，删除需要指定删除元素的索引，插入需要指定插入的位置，而移动元素需要指定从哪个索引移动到另一个索引。而利用 DOM，我们就可以简化这些操作，可以直接删除某个元素的实例，在某个元素前插入或者移动到这里（利用 <code>insertBefore</code> API，如果是要在添加或者移动到最后，可以利用 <code>append</code> ）。这样最大的好处是我们不需要记录下移动到的位置，只需要记录下那些元素移动了即可，而且这部分操作正好可以由 Fiber 来承担。</p><p>举个例子说，从 <code>A=[1,2,3]</code> 变化到 <code>B=[2,3,4,1]</code>，那么只需要记录如下操作即可：</p><img src="/2019/10/07/make-your-react-to-slow/0a8fb847-d652-48bc-ae59-5dbd06ed1169.png"><p>有人好奇，不需要记录移动插入到那个元素前面么？其实不需要的，这是因为你有了操作列表和 B 数组之后，就可以知道目标元素在哪里了。而且采用这种方式就根本不需要关心每次操作之后索引的变化。</p><p>回到上面的简化后的问题，首先通过对比 A、B 数组，可以得到哪些元素是删除的，哪些元素是添加的，而不管采用什么样子的策略，添加删除元素的操作次数是无法减少的。因为你不能凭空产生或者消失一个元素。那么我们问题就可以再简化一下，把所有的添加删除的元素剔除后分别得到数组 A’ 和 B’，也就是 A’ 中不包含被删除的元素，B’ 中不包含被添加的元素，此时 A’ 和 B’ 的长度一定是一样长的。也就是求解出最少移动次数使得数组 A’ 能够转化成数组 B’。</p><p>如果只是简单的求解一下最少移动步数的话，答案很简单，就是<strong>最长上升子序列（LIS，Longest Increasing Subsequence）</strong>。关于如何证明为什么是最长不下降子序列这个算法，可以通过简单的反证法得到。关于这个算法的内容我就不具体讲解了，有兴趣的可以自行 Google。在这里我们只需要知道这个算法的时间复杂度是 <code>O(n^2)</code> 。</p><p>但是现在我们还无法直接应用这个算法，因为每个元素的类型可能是字符串或者数字，无法比较大小。定义数组 T 为 <strong>B’ 内元素在 A’ 的位置</strong>。举个例子，如果 <code>A&#39; = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code> <code>B&#39; = [&#39;b&#39;, &#39;c&#39;, &#39;a&#39;]</code>，那么 <code>T = [2, 3, 1]</code>。本文约定位置是从 1 开始，索引从 0 开始。</p><p>此时便可以对 T 求解 LIS，可以得到 <code>[2, 3]</code>，我们将剩下不在 LIS 中的元素标记为移动元素，在这里就是 <code>1</code>，最后补上被剔除的删除和插入的元素的操作动作。这样 Diff 算法就可以结束了。</p><p>上面讲解的是一个<strong>个人认为</strong>完整的 Array Diff 算法，但是还是可以在保证正确性上继续优化。但是不管优化，这个复杂度对于 React 来讲还是偏高的，而如何<strong>平衡效率和最优解</strong>成为了最头疼的问题，好在 React 采用了一个混合算法，在牺牲掉一定正确性的前提下，将复杂度降低为 <code>O(n)</code>。下面我们来讲解下。</p><h2 id="React-简化之后的-Array-Diff"><a href="#React-简化之后的-Array-Diff" class="headerlink" title="React 简化之后的 Array Diff"></a>React 简化之后的 Array Diff</h2><p>大家有过 React 开发经验的人很清楚，大部分情况下，我们通常是这样使用的：</p><ul><li><p><strong>情形1</strong>：一个标签的的直接子子标签数量类型顺序不变，通常用于静态内容或者对子组件的更新</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如每次渲染都是这样的，里面的直接子元素的类型和数量是不变的，在这种情况下，其实是可以省略 key</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;div key=<span class="string">"header"</span>&gt;header&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div key="content"&gt;content&lt;/</span>div&gt;</span><br><span class="line">&lt;div key=<span class="string">"footer"</span>&gt;footer&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;SubCmp time=&#123;Date.now()&#125;/</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>情形2</strong>：一个标签有多个子标签，但是一般只改变其中的少数几个子标签。最常见的场景就是规则编辑器，每次只在最后添加新规则，或者删除其中某个规则。当然了，滚动加载也算是这种。</p></li><li><p><strong>情形3</strong>：交换某几个子标签之间的顺序</p></li><li><p><strong>情形4</strong>：翻页操作，几乎重置了整个子元素</p></li></ul><p>上面只是简单举了几个常见的例子，大家可以发现，大部分情况下子标签变动的其实并不多，React 利用了这个，所以将 LIS 简化成以第一个元素开始，找到最近上升子序列。简单来来讲就是从头开始遍历，只要这个元素不小于前的元素，那么就加入队列。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Q = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 标准算法</span></span><br><span class="line">LIS = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 简化后的算法，从第一个开始，找到最近的不下降子序列即可。</span></span><br><span class="line">LIS_React = [<span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>我们乍一看，这个算法不对呀，随便就能举出一个例子让这个算法错成狗，但是我们要结合实际情况来看。如果我们套回前面说的几种情况，可以看到对于情况 1,2,3 来讲，几乎和简化前效果是一样。而这样做之后，时间复杂度降低为 <code>O(n)</code> ，空间复杂度降低为 <code>O(1)</code>。我们给简化后的算法叫做 <code>LIS&#39;</code> 方便后面区分。</p><p>我们将 LIS 算法简化后，配合上之前一样的流程就可以得出 React 的 Array Diff 算法的核心流程了。（为什么叫核心流程，因为还有很多优化的地方没有讲）</p><h2 id="变慢的原因？"><a href="#变慢的原因？" class="headerlink" title="变慢的原因？"></a>变慢的原因？</h2><p>当我们在了解了 React 的实现之后，我们再回过来头来看看前面给出的三个例子为啥会有这么大的时间差距？</p><ul><li><p>组件 A 从 <code>[1...10000]</code> 变化到 <code>[2,1,3...10000]</code> 。此时我们先求解一下 <code>LIS&#39;</code> 可以得到 <code>[2,3,4...10000]</code>，那么我们只需要移动 <code>1</code> 这个元素就可以了，将移动到元素 <code>3</code> 前面。同理反过来也是如此，也就是说 S1 ⇒ S2 和 S2 ⇒ S1 的所需要移动的次数是一致的，理论上时间上也就是相同的。</p></li><li><p>组件 B 从 <code>[1...10000]</code> 变化到 <code>[10000,1,2...9999]</code> 。同理，先计算 <code>LIS&#39;</code> 可以得到 <code>[10000]</code>，没错，你没看错，就是只有一次元素，那么我需要将剩下的所有元素全都移动到 <code>10000</code> 的后面去，换句话要进行 9999 次移动。这也就是为啥 <code>S1 =&gt; S2</code> 的时间会这么慢。但是反过来却不需要这个样子，将状态反过来，并重新计算索引，那么也就是从 <code>[1...10000]</code> 到 <code>[2,3....10000,1]</code>，在计算一次 <code>LIS&#39;</code> 得到 <code>[2,3...10000]</code> ，此时只需要移动一次即可，<code>S2 ⇒ S1</code> 的时间也就自然恢复的和组件 A 一致。</p></li><li><p>组件 C 是完全倒序操作，所以只分析其中一个过程即可。首先计算 <code>LIS&#39;</code> 可以得到，<code>[10000]</code> ，也就是说要移动 9999 次，反过来也是要 9999 次，所以时间状态是一致的。</p></li></ul><p>经过这样的分析大家是不是就明白为啥会变慢了吧？</p><h2 id="优化细节"><a href="#优化细节" class="headerlink" title="优化细节"></a>优化细节</h2><h3 id="降低-Map-的生成操作次数"><a href="#降低-Map-的生成操作次数" class="headerlink" title="降低 Map 的生成操作次数"></a>降低 Map 的生成操作次数</h3><p>上面有一点没有讲到，不知道大家有没有思考到，我怎么知道某个元素是该添加函数删除呢？大家第一反应就是构建一个 Set，将数组元素全放进去，然后进行判断就可以了。但是在 React 中，其实用的是 Map，因为要存储对应的 Fiber，具体细节大家可以不用关注，只需要知道这里用 Map 实现了这个功能。</p><p>不管怎么样，根据算法，一开始肯定要构建一遍 Map，但是我们来看下上面的 <code>情形1</code>。发现内容是根本不会发生变化的，而且对于 <code>情形2</code> 来讲，有很大的概率前面的大部分是相同的。</p><p>于是 React 一开始不构建 Map，而是假设前面的内容都是一致的，对这些元素直接执行普通的更新 Fiber 操作，直到碰到第一个 key 不相同的元素才开始构建 Map 走正常的 Diff 流程。按照这个方式，<strong>情形1</strong>根本不会创建 Map，而且对于<strong>情形2、3</strong>来讲也会减少很多 Map 元素的操作（set、get、has）。</p><h3 id="降低循环次数"><a href="#降低循环次数" class="headerlink" title="降低循环次数"></a>降低循环次数</h3><p>按照上面的算法，我们需要至少 3 遍循环：第一遍构建 Map，第二遍剔除添加删除的元素生成 A’ 和 B’，第三遍计算 LIS 并得到哪些元素需要移动或者删除。而我们发现第二遍和第三遍是可以合并在一起的。也即是说我们在有了 Map 的情况下，不需要剔除元素，当遍历发现这个元素是新增的时候，直接记录下来。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于 Diff 算法其实还有很多的细节，我这边没有过多讲解，因为比较简单，比较符合直觉。大家有兴趣的可以自己去看下。另外有人应该会注意到，上面的例子中，为什么切换同样的次数，有的时间长，有的时间短了。日后有时间再分析下补充了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当你看到这个标题的时候，一定很好奇，React 不是很快么？为啥会变慢呢？在写这篇文章之前，我也是这么认为的，但是当我去看了一下 React 有关 Array 的 Diff 之后，我才认识到其实 React 如果你用的不正确，那么是会变慢的。&lt;/p&gt;
&lt;h2 id=&quot;Rea
      
    
    </summary>
    
      <category term="Frontend" scheme="https://blog.xgheaven.com/categories/Frontend/"/>
    
    
      <category term="React" scheme="https://blog.xgheaven.com/tags/React/"/>
    
      <category term="源码分析" scheme="https://blog.xgheaven.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Node Cli 设计上的几点建议</title>
    <link href="https://blog.xgheaven.com/2019/09/07/some-tips-for-create-npm-cli/"/>
    <id>https://blog.xgheaven.com/2019/09/07/some-tips-for-create-npm-cli/</id>
    <published>2019-09-07T10:59:29.000Z</published>
    <updated>2023-09-16T15:51:09.747Z</updated>
    
    <content type="html"><![CDATA[<p>在平时的开发中，我发现大家特别喜欢将很多自己常用或者公司常用的脚本封装成一个 cli，这虽然无可厚非，但是作为一个有强迫症的患者来说，我认为这其实做不好会导致 cli 非常不好用的。所以这里总结了下平时写 cli 的经验希望和大家分享下。</p><h3 id="写之前请思考"><a href="#写之前请思考" class="headerlink" title="写之前请思考"></a>写之前请思考</h3><ol><li>我是不是为了 cli 而去写 cli，换句话我觉得这样比较 cool。如果是，那么请放弃这种想法。</li><li>这个 cli 一定会减轻工作量么？<ul><li>有很多公司喜欢将各种 webpack/eslint/babel 工具封装成一个 cli，那么这真的会降低使用者的工作量么？如果你封装的不好，相反会增加很大的工作量。最神奇的是，封装了这么多工具，配置文件却一个都没少，babelrc/eslintrc/prettierrc，那封装了有何用。</li><li>cli 的不透明性就会导致使用者永远都是有使用成本的，不论这个 cli 有多简单。他不会知道你是干了什么。所以能避免写一个 cli 就避免写一个 cli。那如果真的要写，有其他方案么？请看第三条</li></ul></li><li>除了写 node cli 真的没有其他方案了么？<ul><li>大部分情况下，写 shell 的效率远远高于写 cli，将一个命令拆分成多个 shell，然后配合简单的帮助文档即可。如果用户不知道是做什么的，那么直接就可以去看源码。</li><li>而且使用 git 管理 shell 也同样高效，比如将个人的一些脚本放到 private github 上，然后直接 clone 下来就可以用了。这样不需要每次都 npm publish，进而污染 npm。</li><li>大部分情况下，去写 Makefile/Rakefile 同样可行。当然，Node 生态也有 Jake，不过不推荐用，因为要装 <code>jake</code> 包。</li><li>如果你这个 cli 是作为一个项目的脚手架工具，那么是不是用 <code>yeoman</code> 或者 <code>degit</code> 这类工具更好？除非你的项目非常热门，功能自定义程度高，否则完全不需要自己去写一个脚手架。如果你只是觉得好玩，想写一个脚手架的话，那么请去看第一条，问问自己。</li><li>如果是一个团队使用，那么除非有很大的普世性，那么用 git 管理同样比 npm 管理要强的多。</li></ul></li><li>最后如果决定一定要写 cli 的话，有必要发布到 npm 么？<ul><li>是不是发布到自己的 scope 下也是一个不错的选择？</li><li>是不是直接让别人通过 <code>npm install [github.com/user/package](http://github.com/user/package)</code> 也是一个不错的选择？</li><li>是不是上传到公司 or 个人的私有 npm 更好？</li></ul></li></ol><h3 id="开发时请遵循以下几点"><a href="#开发时请遵循以下几点" class="headerlink" title="开发时请遵循以下几点"></a>开发时请遵循以下几点</h3><ol><li>请使用 npm</li><li>不要写死版本号，优先使用 <code>^</code><ul><li>这是因为有可能你的 cli 会被直接当做依赖安装到项目中，如果你写死了版本号，那么可能会装多分依赖。比如项目依赖了 <code>yargs@^13.2.0</code> ，但是你锁死了 <a href="mailto:`yargs@13.1.0" target="_blank" rel="noopener">`yargs@13.1.0</a>`，就会导致安装两个 yargs。</li></ul></li><li>避免引入一些功能很大，而自己只用其中一部分的包<ul><li>因为没有 webpack 工具，无法进行 tree shaking，所以导致安装了很多比较大的包。比如你只是用了 <code>lodash</code> 的 <code>cloneDepp</code> 却安装了整个包。优先使用 <code>[lodash.xxx](http://lodash.xxx)</code> 子包。</li></ul></li><li>如果你使用了某些构建工具(babel,webpack,typescript,flow)，那么请将构建之后的文件也加入代码仓库。<ul><li>比如有一个 <code>src</code> 目录存放了 ts 源文件，而 <code>dist</code> 存放了构建之后的 js 文件。那么很多人的选择往往是将这 <code>dist</code> 文件夹加入 gitignore。这样其实是不太好的，原因如下：</li><li>第一，方便追踪变化，比如你自己添加了一些 debug 代码，这个时候构建之后发现没有问题。又把 debug 代码删除，当你提交的时候就可以很清楚的看到自己修改了之后没有构建代码</li><li>第二，方便通过 <a href="http://unpkg.com" target="_blank" rel="noopener">unpkg.com</a> 等工具访问</li><li>第三，在版本开发依赖升级之后，可以很方便的看到改变的内容。一般使用者会放心升级 cli 之类的开发工具，所以这部分的质量需要我们自己来保证。</li></ul></li></ol><h3 id="交互设计上请遵循以下几点"><a href="#交互设计上请遵循以下几点" class="headerlink" title="交互设计上请遵循以下几点"></a>交互设计上请遵循以下几点</h3><ol><li>Throw as possible，将可能的所有报错向上抛出，是一个好系统所必备的能力。但是在错误展示的时候，可以向用户隐藏部分调用栈信息等，只保留关键信息即可。</li><li>尽可能遵循 linux 下的 cli 规范。</li><li>不要让用户产生无畏的等待，通过添加进度条或者输出完成列表等告诉用户你依旧是在工作中的。</li><li>给予用户想查看所有日志的能力。可以通过 <code>-v</code> <code>-vv</code> <code>-vvv</code> 或者 <code>--log-level debug</code> 来控制显示级别</li><li>对所有命令的描述都不要超过一行。不论屏幕宽度如何（一般默认 80），最好不要超过 70。如果需要大量描述，请尝试通过 man 或者单独的页面。</li><li>帮助是最好的文档，写好 cli 的 help 远比去写好一个文档网站要关键</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在平时的开发中，我发现大家特别喜欢将很多自己常用或者公司常用的脚本封装成一个 cli，这虽然无可厚非，但是作为一个有强迫症的患者来说，我认为这其实做不好会导致 cli 非常不好用的。所以这里总结了下平时写 cli 的经验希望和大家分享下。&lt;/p&gt;
&lt;h3 id=&quot;写之前请思
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个 18 届前端校招生在网易的 257 天</title>
    <link href="https://blog.xgheaven.com/2019/03/12/257-days-in-netease/"/>
    <id>https://blog.xgheaven.com/2019/03/12/257-days-in-netease/</id>
    <published>2019-03-12T07:54:40.000Z</published>
    <updated>2023-09-16T15:48:05.170Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>思来想去，我决定还是要写一篇文章分享一下我在网易的经历和生活，我对网易的观点或者想法以及评论也许并不是客观公正的，我只是想从一个校招生的角度来讲述。</p></blockquote><p>2018 年 7 月 01 日，我从杭电毕业，进入了网易，从事大数据前端管理页面开发；<br>2019 年 3 月 15 日，我主动离开了网易，一共 257 天、6168 小时、370080 分、22204800 秒。</p><h2 id="心路历程"><a href="#心路历程" class="headerlink" title="心路历程"></a>心路历程</h2><p>进入网易后，我的心态也一点一点的发生着变化，这其中有一些是因为自己的原因，也有一部分是网易的原因，如果你愿意，我愿和你慢慢阐述</p><h3 id="意外-——-校招季拿到了网易-Offer"><a href="#意外-——-校招季拿到了网易-Offer" class="headerlink" title="意外 —— 校招季拿到了网易 Offer"></a>意外 —— 校招季拿到了网易 Offer</h3><p>我原本没想给网易投递 Offer，那个时候我心里只有阿里，至于原因么，有句话说的好，『所有的 Node 大佬不是在阿里，就去在去阿里的路上』，虽然我不是大佬，但是我也有一颗想成为技术大佬的心。那个时候我只投递了阿里的 Offer。</p><p>可是事与愿违，18 届的校招可谓说是及其严格，基本都是社招要求，而且听说就招了 300 人(只是听说)。投了两次阿里云，都以失败告终（毕竟我的朴神来阿里云）。这个时候正好有同学在网易实习，我就看了下，有前端岗位，那就去下试试吧。</p><p>说实话，那个时候对网易的前端、Node 没有抱有任何希望。网易在前端的开源社区几乎没有任何动静，也几乎从来没参加过任何技术论坛，也从来没听说他们有用任何前端框架，可以说对网易前端没有任何的概念。</p><p>面试的时候我也就啥都没准备，纯裸考，只是觉得这公司进不进无所谓吧，甚至 HR 面的时候，稍微顶撞了一下 HR，HR 问了一个问题，我回答了，结果他说我回答的不是他问的问题，我思考了一下，坚定的回了他一句『我回答的就是你的问题，那您不是想问这个？』。结果<strong>意外</strong>的，我竟然进了，我当时自己都蒙了。直到入职之后才回过神来，原来是他们太缺人了。。。</p><p>但是毕竟校招，怎么样还是要试一下么，就安慰自己说可能他们内部用的技术挺好的，只不过按照丁磊的作风，可能不喜欢招摇吧。但后来结果实力打脸，事与愿违~</p><p>说实话，当时也找过其他的公司，可是杭州这边，真正既有技术实力、有大佬助阵、面向开源的公司几乎少的可怜，除了阿里几乎找不到几个，于是当时在好朋友的推荐下，投了有赞的前端、七牛的后端。</p><p>七牛的后端笔试直接跪了，有赞的拿到了 offer，但是当时脑抽觉得有赞技术不好（另外是我和室友都拿到了有赞的 offer，但是前端的老大跟我的室友说带着他一起搞波大事情，和我却啥都没说，就加了个微信，我觉得受到了某种歧视），而且觉得有赞的平台有点小，于是给推了。</p><p>后来真正进入到网易之后，觉得网易还不如有赞呢。或许大家认识有赞是因为 996，都认为有赞 996 不好，可是有赞和普通的互联网企业一样，并没有 996，相反比其他公司还有活力，有各种兴趣组织，甚至还有官方的游戏比赛，Dota/王者，比赛还有专人解说呢。而且钱多福利好。而且杭州除了阿里能数上的有赞也是接入企业滴滴。</p><p>反正说了这么多，最终我算是说服自己，现在网易学习 1 年，然后去我喜欢的公司。</p><h3 id="期待-——-嗨，猪行动"><a href="#期待-——-嗨，猪行动" class="headerlink" title="期待 —— 嗨，猪行动"></a>期待 —— 嗨，猪行动</h3><p>期待着进入网易的生活会是什么样子；期待着会不会遇见很多大佬；期待着网易的食堂有多么好吃；期待着能不能和同事很好的相处；期待能不能用到自己喜欢的技术；期待着别人能不能承认自己的能力。</p><p>一切的期待，都在拿到校招 Offer 的那一刻开始。</p><p>这期间参加了 『嗨，猪行动』，第一次以校招的身份进入网易，我们在 HR 小哥哥小姐姐们的安排下，一起参加了一些有趣有意思的活动。大家分成各个小队，以小队的身份参加比赛，每完成一个比赛，都会有一定的积分奖励，在活动结束之后，可以去换取很多严选的礼物，比如有行李箱、抱枕、牙刷、拖鞋、杯子、笔等等。</p><p>我觉得这场活动最成功的便是在最后，来了一场上百人吃鸡游戏，在园区散落着很多盒子，每个盒子里面<strong>武器</strong>或者<strong>命</strong>，然后找到其他小队成员消灭之。虽然我们的枪只是简单的水枪，子弹也是可消除墨水，命只是一个简单的丝带绑在头上。而且我不得不承认这个游戏 Bug 太多，不过不得不说真的是很好玩的。</p><p>很快，虽然我很轻松的活到了前 10 名的样子，但是我是用某些不正常的方法（在某个门后躺着，假装自己已经死掉了，悠闲的等着；而且我们在这个游戏开始前就已经偷偷攒了好多武器和命，就是在玩吃鸡之前的游戏的时候），感觉不是太很公平，于是我就主动退出了。</p><p>静静的看着他们战斗，很快场上就只剩下 2 名妹子，一枚来自其他的组，还有一枚便是我们组的。于是最精彩的决赛来了，我们给他们腾出了场地，每人补足武器。</p><p>piupiupiu，piupiupiu，真的是太精彩了，我无法描述，但是结果有点遗憾，我们组的妹子惜败第二名。</p><p>一天如此开心，感谢 HR 小哥哥小姐姐们的辛勤付出，也感谢队友的努力奋斗，或许在此刻，我对网易的印象有了那么一些改变，感觉让人期待网易的生活会是怎么样子。</p><h3 id="满足-——-Mini-项目-『来人吖』"><a href="#满足-——-Mini-项目-『来人吖』" class="headerlink" title="满足 —— Mini 项目 『来人吖』"></a>满足 —— Mini 项目 『来人吖』</h3><p>2018 年 7 月 1 日，这一天终于到来了。我真正的不如了网易的大门，发现一切都是如想象的那么美好。</p><p>免费的四餐（包含夜宵喽），除了人太多以外味道还是很不错的；各种严选考拉的内购。有各种各样的折扣，而且有些还会直接在食堂门口摆摊。免费的班车简直不要太舒服，就是要每天 7 点半起床赶班车，真的是难受。园区免费停车、新能源免费充电，虽然这个时候我还没有买车，不过我已经在考虑中了。</p><p>入职之后，参加了 2 天的素质拓展，终于圆梦了我一直想去尝试的高空断桥，刺激、爽，还想再来一次。哈哈哈。</p><p>很快，最令我欣喜激动的事情来了，『Mini 项目』，简单点来讲，就是网易花了 100w 做了 8 个没啥用的产品。当然了，其实不是这样，重新讲一下，就是大家在一个月的时间里面，从<strong>零</strong>开始，做出一个可以上线的产品，从中体验整个产品的开发流程，学习工作中用到的技术栈，培养同学之间的合作意识。这其实是一个非常有意义的事情，从中你可以体会到创业的过程，需求分析、竞品分析、优势分析、未来产品规划、UI 设计、技术架构、团队合作、测试保证、产品推广，每一步都可谓非常有价值。</p><p>当然了，这其中最让我满足的便是我在 Mini 项目中担任了技术负责人的身份，终于可以满足我想玩各种技术的心，把各种想用的技术都集成在一起，话不多说，先申请 10 台机器走起，Docker Swarm;Kafka;Node.js;NestJs;小程序;mpvue;Redis;TiDB;ES;CI/CD;Spring Cloud，简直不要太爽。</p><p>让我最欣慰满足的是虽然我这个技术负责人当的不是很称职，但是大家不嫌弃，而且一起推动团队的进步，而且对我定下的技术方向没有太多的异议，尤其是后端龙哥定的微服务化的 Spring Cloud 框架简直不要太符合我的胃口。感觉大家都是有技术追求，热爱技术。</p><p>另外最爽的就是入职一个月的便天天加班，甚至有几次我都是凌晨 12 点下班，到家都 1 点了，第二天还要 7 点半爬起来赶班车，谢天谢地那个时候还有顺风车。即便如此，我并没有觉得加班有多累，因为我们都有一个共同的目标——产品上线，拿到第一。</p><p>哦顺便说一句，那个时候我们就是想做顺风车匹配，只不过我们是做拼滴滴车，简单来讲就是大家都是乘客，匹配到一起了，由其中一个人打滴滴，然后大家一起走。这样做最大的好处便是省钱，比如说我回家快车 80，拼车 60，如果找齐 4 人，便只要 20 快，甚至比顺风车还便宜，而且有快车的服务。但是即便如此，开始产品评审的时候，评委一直无法绕开滴滴顺风车这个大对手，也对我们的产品产生了质疑，而且我们在这期间也质疑过很多次，直到我们做完了之后没多久，2018 年 8 月，顺风车下架了，顺风车下架了，顺风车下架了，重要事情说三遍，我们这才意识到我们的产品是有多么正确，多么正确，多么正确。</p><h3 id="向往-——-就要步入真正的业务线去了"><a href="#向往-——-就要步入真正的业务线去了" class="headerlink" title="向往 —— 就要步入真正的业务线去了"></a>向往 —— 就要步入真正的业务线去了</h3><p>一个月的 Mini 项目结束之后，虽然我们并没有取得第一名，但是我们在这期间收获了更多的东西。</p><p>小组里面的每个人就要到对应的业务线去了，有去云信的，有去严选的，有去云音乐的，也有去 AI、安全部门的。虽然这些部门无一例外经历了裁员。</p><p>有了 Mini 项目的经历之后，我对接下来步入真正的工作充满了无比的向往，会不会他们也和我们的组员一样有着技术追求，我能不能发挥我自己最大的力量给项目贡献代码，能不能维护以为开源项目，能不能听到很多大佬们的讲座。</p><p>以前这些问题我是有所担心的，但是有了 Mini 项目的经历之后，我更相信我所说的。可是事实却是……</p><h3 id="愁-——-为什么和我想象的不一样，甚至说是非常非常非常不一样"><a href="#愁-——-为什么和我想象的不一样，甚至说是非常非常非常不一样" class="headerlink" title="愁 —— 为什么和我想象的不一样，甚至说是非常非常非常不一样"></a>愁 —— 为什么和我想象的不一样，甚至说是非常非常非常不一样</h3><p>可是事实却是事与愿违，进入部门之后，我才发现是我想多了。</p><p>有的时候我一直在吐槽说我们项目技术差，比如什么只能用 ES5；没有 webpack；没有测试；没有 CI；虽然是前后端分离，但是代码却和后端放在一个仓库里面；Git 提交没有规范，各种 pull merge；Git Message 也没有规范；……这是一个已经三年的项目了，而且最有意思的是原本开始的时候是孟导定的用 Regular，想兼容 IE。但是我问现在不是只兼容 Chrome 么，这是为啥呢？他们和我说原因就是因为 IE 实在是兼容不了。这个时候我真想说一句，这个理由真的很棒。</p><p>这个问题不仅仅体现在前端，后端也是有如此的问题，觉得只要能解决问题就好了，要什么格式，要什么技术追求。这碗面条（代码）我只要保证计算机能吃就行，乱成啥样关我啥事。我只说一句，看了后端 Java 代码，我是第一次见识到 Space 和 Tab 缩进同时使用的，牛啤。</p><p>我甚至还开过一个玩笑说，前端越来越追求规范，开始越来越多的使用 TS 强类型的语言，而后端却想着如果绕开 Java 类型限定，内部几乎都是 JSONObject。当然这是一句玩笑，毕竟有些框架的东西你是没法直接用 JSONObject 的，但也能反映一些问题。</p><p>愁啊愁啊，当初的期待全部破灭，想推重构，可是我一个刚入职的又如何推的动？</p><p>愁啊愁啊，不仅仅是因为技术，而且内部其他的问题也很多，比如说 QA 测试问题、产品乱接需求、文档书写不全。。。夸张点说，我的大学技术社团除了干活没钱、人力不足以外，算是吊打我们部门，至少从技术上是这么讲的。至少社团的服务器环境是全 Docker 化的。都 9102 年了，还不会用 Docker 是来搞笑的么……</p><p>更愁的是，网易似乎不接受内部的合作，我曾经给网易云写了一个更好用对象存储 Node.js SDK，<a href="https://github.com/XGHeaven/nos-node-sdk" target="_blank" rel="noopener">nos-node-sdk</a>，想合并到他们的代码库里面，结果他们一直不给我回复。问他们为啥不改进代码，他说人手不够……我 go……我帮你写了，我帮你维护还不乐意啊，再说我就不吐槽你们的文档写的有多差了，错误一片一片的，也就我愿意认认真真的看下来了。</p><h3 id="迷茫-——-完全看不到方向"><a href="#迷茫-——-完全看不到方向" class="headerlink" title="迷茫 —— 完全看不到方向"></a>迷茫 —— 完全看不到方向</h3><p>时间一久，我就陷入了迷茫期，找不到未来发展的方向，就像是我周围的同学都在踏步前进，有研究 Node 内核的，有使用 Egg 开发后台的，有用 React+Antd 的，还有 Typescript 写 IOS 组件的。而我，现在只能看着 Regular，对未来几乎没有任何帮助。换句话说，他们所在的环境至少给他们拓宽了不少眼界，而网易却没给我拓宽任何的眼界。</p><p>我也在安慰自己，毕竟学习是自己的事情，公司不给力，只能靠我们自己啦。确实我也在不停的努力，尝试学习其他的东西，可是这种学习毕竟是没有方向性的，我现在缺的是项目经历，而不是基础。基础就像是地基，只要地基够用，如何快速搭建起高楼是最重要的，而不是说连高楼都没造起来的时候想着拓宽地基。</p><p>另外，你见过那个专家是可以脱离他们的环境的？工作不用 React，却想成为 React 专家；工作不用 Java，却想成为 Java 专家；工作不接触 Node 内核，怎么成为 Node 专家；工作不接触浏览器内核；怎么成为浏览器专家。<strong>一个公司的天花板牵扯着你能早就多高的喽，也能让你知道你现在的基础够不够用，如何更好的提高自己。</strong>自我驱动的学习最大的用处是帮你补足基础，而只有真正的项目经历，才能真正让你有质的成长。</p><p>但是，这些东西在网易，很难寻得。</p><p>也许有人会出来说，网易里面技术栈也是很多的，React/Vue 都是有的。确实，有的确有，可能这又能如何？况且使用这部分技术的人也是少之又少，最关键的还是人！</p><h3 id="离开-——-却没有任何留念"><a href="#离开-——-却没有任何留念" class="headerlink" title="离开 —— 却没有任何留念"></a>离开 —— 却没有任何留念</h3><p>最终我选择了离开网易，去寻找新的家园。</p><p>当我真正离开的时候，我才发现原来网易并不是那么的不堪。有的地方还是有许多值得学习借鉴的地方，可惜对于我们这些下层人民来讲，上层优秀的想法无法渗透到我们这里，在我们眼里，网易只是一个完成需求就可以下班的地方，不需要你有太多的想法，只需要按照上面的指示一步一步来做就可以了。</p><p>难得说网易的福利好，可惜我并没有沾上多少，食堂 Mini 项目之后我就搬离本部园区，在外面写字楼包了一块办公区，所以食堂基本吃不上了；免费停车就更不用说了，只能停本部，然后走一公里到我的工作地点；内部的技术分享全在园区，根本没时间赶过去，只能在线上看看了；各种摆摊更别说看见了；网易二期别人都搬过去了，为啥我们还不搬。简单点来讲，我培养不了我对网易的感情，对我来我，我就像是给大公司做外包，那我为啥不去一个钱多技术好的公司呢。</p><p>离开的时候，最大的愧疚便是对 HR 们，愧对了你们对我们的培养，真的真的真的非常抱歉，路过 HR 办公区的时候，害怕你看到我，虽然你还是看到了我。不过我们是主动离职的，比被裁的要好一点点，可惜就是没钱拿。</p><p>但是，这并不能阻止我离开网易。</p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><ul><li>感谢陪伴和我一起走过 mini 项目的同学们</li><li>感谢导师的帮助</li><li>感谢身边的同事们</li><li>最最感谢校招 HR 小姐姐小哥哥们的努力，为你们实力打 Call。感谢你们对我们的照顾和指导，让我们更快的融入到了网易的大世界中。谢谢，谢谢，尤其感谢森森和 6 姐。</li></ul><h2 id="回首"><a href="#回首" class="headerlink" title="回首"></a>回首</h2><p>现在我入职了字节跳动，现在回过头来看了看，对我来说，这真的算是一个非常正确的决定，我也就不吐槽网易跟字节跳动相比的基础设施有多差了，我也不吐槽网易有多扣了。</p><p>如果你现在问我推不推荐网易，我觉得还是值得推荐的，但是一定一定一定要看部门，一定一定一定要看 Leader，一定一定一定要看环境。看部门有没有发展前景，看 Leader 愿不愿意培养自己，看环境会不会限制到你的天花板。</p><p>另外这里实力打 Call 考拉前端，足够开放，也有大佬，如果真的去可以去这个部门。当然严选的就是有点封闭了，搞了一套很不错的 npm 私有仓库，权限系统也做了，却不尝试在公司内部推广，搞不懂。云音乐和严选差不多，这里又要吐槽一下内部的 nei 是好难用，不仅仅是 ui 丑，而且这么久了，才上线在线 mock 功能，还不支持 swagger 导入，还不如之前我实习的公司大搜车推出的 easy-mock 呢。</p><p>过去就是过去，迎接未来，至少字节跳动能给我保证多劳多得，这就足够了！！！</p><p>另外说一句，有想要内推字节跳动的学弟学妹么，社招也可以哦，请用简历砸我吧，<a href="mailto:xutianyang.bradley@bytedance.com" target="_blank" rel="noopener">xutianyang.bradley@bytedance.com</a>，如果想要和我交流的话，可以 Telegram 找我，@xgheaven。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;思来想去，我决定还是要写一篇文章分享一下我在网易的经历和生活，我对网易的观点或者想法以及评论也许并不是客观公正的，我只是想从一个校招生的角度来讲述。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2018 年 7 月 01 日，我从杭电毕业，进入了网易
      
    
    </summary>
    
      <category term="Netease" scheme="https://blog.xgheaven.com/categories/Netease/"/>
    
    
  </entry>
  
  <entry>
    <title>可控组件？不可控组件？让我们来讨论一下下~</title>
    <link href="https://blog.xgheaven.com/2018/12/29/how-to-handle-controlled-uncontrolled-component-in-react/"/>
    <id>https://blog.xgheaven.com/2018/12/29/how-to-handle-controlled-uncontrolled-component-in-react/</id>
    <published>2018-12-29T02:48:57.000Z</published>
    <updated>2023-09-16T15:48:05.168Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><blockquote><p><strong>前言</strong>：本人入职之后算是第一次真正去写 React，发现了 React 的组件系统和其他框架的组件系统有些许的不同，这也触发了我对其中组件的可控性的一些思考和总结。</p></blockquote><h1 id="可控组件？不可控组件？"><a href="#可控组件？不可控组件？" class="headerlink" title="可控组件？不可控组件？"></a>可控组件？不可控组件？</h1><p>自从前端有了组件系统之后，有一个很常见但是却又被大家忽视的概念，就是可控组件（Controlled Component）和不可控组件（Uncontrolled Component）。</p><h3 id="什么是可控和不可控？"><a href="#什么是可控和不可控？" class="headerlink" title="什么是可控和不可控？"></a>什么是可控和不可控？</h3><p>官方详细讲解了什么事可控和不可控组件，虽然只是针对 <code>input</code> 组件的 <code>value</code> 属性来讲的。但是对于很多第三方组件库来讲，一个组件不止有一个数据属于可控。比如 Ant Design 的 <code>Select</code> 组件，<code>value</code> 和 <code>open</code> 都属于可控的数据，如果你让 value 可控 open 不可控，那这到底是可控组件还是不可控组件呢？</p><p>所以从广义来讲使用可控/不可控组件其实不是很恰当，这里使用<strong>可控数据</strong>与<strong>不可控数据</strong>更加合理一点。一个组件可能可能同时有可控的数据和不可控的数据。</p><p><strong>可控数据</strong>是指组件的<strong>数据</strong>被使用者所控制。<strong>不可控数据</strong>是指组件的<strong>数据</strong>不由使用者来控制而是由组件内部控制。</p><p>之所以会有可控和不可控，主要是跟人奇怪的心理有关。如果把框架比作一个公司，组件比作人，组件之间的关系比作上下级。那么上级对下级的期望就是你既能自己做好分内的事情，也可以随时听从我的命令。这本身就是一件矛盾的事情，一边撒手不管，一边又想全权掌控。遇到这样的上级，下级肯定会疯了吧。</p><h3 id="为啥要区分呢？"><a href="#为啥要区分呢？" class="headerlink" title="为啥要区分呢？"></a>为啥要区分呢？</h3><p>在 Vue 中，其实都忽视了这两者的区别，我们来看下面这个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input/&gt;</span><br></pre></td></tr></table></figure><p>上面是一个最简单 Input 组件，我们来思考一下如下几种使用场景：</p><ul><li><p>如果我只关心最后的结果，也就是输入的值，中间的过程不关心，最简单的方式是用 <code>v-model</code> 或者自己在 <code>change</code> 事件里面获取值并保存下来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;value&quot;/&gt;</span><br><span class="line">&lt;!-- OR --&gt;</span><br><span class="line">&lt;input @change=&quot;change&quot;/&gt;</span><br></pre></td></tr></table></figure><p>这种场景是非常普遍，Vue 可以很好的完成，结果也符合人们的预期。</p></li><li><p>如果我也只是关心结果，但是想要一个初始值。<br>也很简单，通过 value 传入一个静态字符串不就好了，或者传入一个变量，因为 Vue 的 props 是单向的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;value&quot;/&gt; &lt;!-- value 有初始值 --&gt;</span><br><span class="line">&lt;input value=&quot;init string&quot; @change=&quot;change&quot;/&gt;</span><br><span class="line">&lt;input :value=&quot;initValue&quot; @change=&quot;change&quot;/&gt;</span><br></pre></td></tr></table></figure><p>其中第三个方案并不是非常正确的方式，如果 <code>initValue</code> 在用户输入期间发生了更新，那么他将覆盖用户的数据，且不会触发 <code>change</code> 事件。</p></li><li><p>我不仅仅关心结果，还关心过程，我需要对过程进行控制。比如说把输入的字符串全部大小写，或者锁定某些字符串。<br>熟练的工程师肯定可以写出下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;value&quot;/&gt; &lt;!-- watch &quot;value&quot;，做修改 --&gt;</span><br><span class="line">&lt;input :value=&quot;value&quot; @change=&quot;change&quot;/&gt; &lt;!-- 在 change 中修改数据 --&gt;</span><br></pre></td></tr></table></figure><p>但是这会有问题：</p><ol><li>数据的修改都是在渲染 dom 之后，也就是说你不管怎么处理，都会出现输入的抖动。</li><li>如果通过第二种方法，恰巧你做的工作是限制字符串长度，那么你这样写 <code>change(e) {this.value = e.target.slice(0, 10)}</code> 函数会发现没有效果。这是因为当超过 10 字符之后，value 的值长度一直是 10，vue 没有检测到 value 的变化，从而不会更新 input.value。</li></ol></li></ul><p>出现这个问题最关键的是因为没有很好的区分可控组件和不可控组件，我们来回顾一下上面的某一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input :value=&quot;value&quot; @change=&quot;change&quot;/&gt;</span><br></pre></td></tr></table></figure><p>你能从这块代码能看出来使用这个组件的用户的意图是什么呢？他是想可控的使用组件还是说只是想设置一个初始值？你无法得知。我们人类都无法得知，那么代码层面就不可能得知的了。所以 vue 对这一块的处理其实是睁一只眼闭一只眼。用户用起来方便，</p><p>用一个例子来简单描述一下：上级让你去做一项任务，你询问了上级关于这些任务的信息（props），然后你就开始（初始化组件）工作了，并且你隔一段时间就会向上级汇报你的工作进度（onChange），上级根据你反馈的进度，合理安排其他的事情。看起来一切都很完美。但是有的上级会有比较强的控制欲，当你提交了你的工作进度之后，他还会瞎改你的工作，然后告诉你，按照我的继续做。然后下级就懵逼，当初没说好我要接受你的修改的呀（value props），我这里也有一份工作进度呀（component state），我应该用我自己的还是你的？</p><p>对于人来说，如何处理上级的要求（props）和自身工作（state）是一个人情商的表现，这个逻辑很符合普通人的想法，但是对于计算机来说，它没有情商也无法判断究竟应该听谁的。为了克服这个问题，你需要多很多的判断和处理才可以，而且对于一些不变的值，你需要先清空再 nextTick 之后赋值才可以出发组件内部的更新。</p><p>最近入职之后，公司用到了 React，我才真正的对这个有所理解。</p><h3 id="value-defaultValue-onChange"><a href="#value-defaultValue-onChange" class="headerlink" title="value? defaultValue? onChange?"></a>value? defaultValue? onChange?</h3><blockquote><p>如果对 React 可控组件和不可控组件有了解了可以跳过这块内容了。</p></blockquote><p>让我们来看一下 React 如何处理这个的？我们还是拿上面的那三种情况来说：</p><ul><li><p>如果我只关心最后的结果，也就是输入的值，中间的过程不关心</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input onChange=&#123;onChange&#125;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>如果我也只是关心结果，但是想要一个初始值</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input defaultValue=<span class="string">"init value"</span> onChange=&#123;onChange&#125;/&gt;</span><br><span class="line">&lt;input defaultValue=&#123;initValue&#125; onChange=&#123;onChange&#125;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>我不仅仅关心结果，还关心过程，我需要对过程进行控制</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input value=&#123;value&#125; onChange=&#123;onChange&#125;/&gt;</span><br></pre></td></tr></table></figure></li></ul><p>当看完了这段你会很清楚的知道什么样的结构是可控，什么结构是不可控：</p><ul><li>如果有 <code>value</code> 那么就属于可控数据，永远使用 <code>value</code> 的值</li><li>否则属于不可控数据，由组件使用内部 <code>value</code> 的值，并且通过 <code>defaultValue</code> 设置默认值</li></ul><p>不论什么情况修改都会触发 <code>onChange</code> 事件。</p><p>React 对可控和不可控的区分其实对于计算机来说是非常合理的，而且也会让整个流程变的非常清晰。当然，不仅仅只有这一种设置的方式，你可以按照一定的规则也同样可以区分，但是<strong>保证可控和不可控之间清晰的界限是一个好的设计所必须要满足的</strong>。</p><h3 id="propName-in-this-props？"><a href="#propName-in-this-props？" class="headerlink" title="propName in this.props？"></a><code>propName</code> in this.props？</h3><p>了解上面的概念之后，我们进入到实战环节，我们怎么从代码的层面来判断当前组件是可控还是不可控呢？</p><p>根据上面的判断逻辑来讲：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isControlled1 = <span class="string">'value'</span> <span class="keyword">in</span> <span class="keyword">this</span>.props <span class="comment">// approval 1</span></span><br><span class="line"><span class="keyword">const</span> isControlled2 = !!<span class="keyword">this</span>.props.value <span class="comment">// approval 2</span></span><br><span class="line"><span class="keyword">const</span> isControlled3 = <span class="string">'value'</span> <span class="keyword">in</span> <span class="keyword">this</span>.props &amp;&amp; <span class="keyword">this</span>.props.value !== <span class="literal">null</span> &amp;&amp; <span class="keyword">this</span>.props.value !== <span class="literal">undefined</span> <span class="comment">// approval 3</span></span><br></pre></td></tr></table></figure><p>我们来观察上面几个判断的方式，分别对应一下下面几个模板（针对第三方组件）：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Input value=&#123;inputValue&#125; /&gt; <span class="comment">// element 1，期望可控</span></span><br><span class="line">&lt;Input value=<span class="string">""</span> /&gt; <span class="comment">// element 2，期望可控</span></span><br><span class="line">&lt;Input /&gt; <span class="comment">// element 3，期望不可控</span></span><br><span class="line">&lt;Input value=&#123;<span class="literal">null</span>&#125; /&gt; <span class="comment">// element 4，期望？？？</span></span><br></pre></td></tr></table></figure><p>可以得到如下表格</p><table><thead><tr><th>是否可控</th><th style="text-align:center">approval 1</th><th style="text-align:center">approval 2</th><th style="text-align:center">approval 3</th></tr></thead><tbody><tr><td>element1</td><td style="text-align:center"><code>true</code></td><td style="text-align:center"><code>true</code></td><td style="text-align:center"><code>true</code></td></tr><tr><td>element2</td><td style="text-align:center"><code>true</code></td><td style="text-align:center"><code>false</code></td><td style="text-align:center"><code>true</code></td></tr><tr><td>element3</td><td style="text-align:center"><code>false</code></td><td style="text-align:center"><code>false</code></td><td style="text-align:center"><code>false</code></td></tr><tr><td>element4</td><td style="text-align:center"><code>true</code></td><td style="text-align:center"><code>false</code></td><td style="text-align:center"><code>false</code></td></tr></tbody></table><p>大家第一眼就应该能看出来方法二其实是不正确的，他无法很好的区分这两种状态，所以直接 pass 掉。</p><p>眼尖的同学也会发现为什么 element 4 的期望没有填写呢？这是因为有一条官方的规则没有讲，这条规则是这样的：<strong>当设置了 <code>value</code> 属性之后，组件就变成了可控组件，会阻止用户修改 input 的内容。但是如果你想在设置了 <code>value</code>  prop 的同时还想让用户可以编辑的话，只可以通过设置 <code>value</code> 为 <code>undefined</code> 或 <code>null</code>。</strong></p><p>在官方的这种规则下面，element 4 期望是不可控组件，也就是说 approval 3 是完全符合官方的定义的。但是这样会导致可控和不可控之间的界限有些模糊。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Input value=&#123;inputValue&#125; /&gt;</span><br><span class="line"><span class="comment">// 如果 inputValue 是 string，组件是什么状态？如果是 null 又是什么状态？</span></span><br></pre></td></tr></table></figure><p>所以这里其实我推荐使用 approval 1 的方式，这也是 antd 所采用的。虽然不符合官方的定义，但是我觉得符合人们使用组件的一种直觉。<small>第六感，=逃=</small></p><h3 id="Independence"><a href="#Independence" class="headerlink" title="Independence"></a>Independence</h3><p>有了判断的方法，那么我们可以画出一个简单的流程图（Input 组件为例）：</p><img src="/2018/12/29/how-to-handle-controlled-uncontrolled-component-in-react/handle-controlled.jpg"><p>图片有点复杂，简单来讲就是每一次需要获取可控数据或者更新可控数据的时候，都需要检测一下当前组件的状态，并根据状态选择是从 props 中获取数据还是从 state 中获取数据已经更新的时候调用的是那个函数等等。图中有一些箭头的方向不是很正确，而且部分细节未画出，大家见谅。</p><p>如果只是添加这一个可控的属性 <code>value</code> ，这样写未尝不可，但是如果我们要同时考虑很多属性呢？比如说 Antd Select 组件就同时有 <code>value</code> 和 <code>open</code> 两个可控属性，那么整个代码量是以线性方式增长的。这很明显是无法接受的。</p><p>于是这里我引入了 Independence 装饰器来做这件事情。架构如下：</p><img src="/2018/12/29/how-to-handle-controlled-uncontrolled-component-in-react/independence.jpg"><p>我们可以这么理解，一个支持可控和不可控的组件本质上可以拆分成内部一个展示型的无状态受控的组件和外面的包装组件，通过包装（也就是高阶组件的方式）让内部受控组件支持不可控。</p><p>这样写其实有如下几个好处：</p><ol><li>组件逻辑复杂度降低，只需要将组件的受控情况</li><li>可以将任意受控组件包装成不受控组件，尤其是对第三方组件的封装上</li><li>组件复杂度降低，代码冗余变少</li><li>非常方便的添加和删除受控属性，只需要修改装饰器即可</li></ol><h3 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h3><p>目前我简单实现了 Independence 装饰器，代码在网易猛犸开源的组件库 <a href="https://github.com/Mammut-FE/bdms-ui" target="_blank" rel="noopener">bdms-ui</a>（建设中，组件不全、文档不全、时间不够，敬请期待）中，<a href="https://github.com/Mammut-FE/bdms-ui/blob/master/src/lib/independence.tsx" target="_blank" rel="noopener">代码在此</a>。</p><p>他遵循这样的规范：<strong>假如属性名称为 <code>value</code>，那么默认值为 <code>defaultValue</code>，change 事件为 <code>onValueChange</code></strong>。支持通过 <code>onChangeName</code> 修改 change 事件名称，通过 <code>defaultName</code> 修改默认值名称。</p><p>另外最简单的使用方式就是通过装饰器了，拿 <code>Select</code> 组件举例。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Independence(&#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">        onChangeName: <span class="string">'onChange'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    open: &#123;&#125; <span class="comment">// 使用默认值</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Select</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// blahblah，你就可以当受控组件来编写了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从此编写可控和不可控的数据从未如此简单。另外 Independence 还实现了 forward ref 的功能。</p><p>不过现在功能还比较薄弱，需要经过时间的检验，等完备之后可以封装成一个库。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文简单讲解了一下什么是可控和不可控，以及提出了一个 React 的解决方案。</p><p>这些只是基于我的经验的总结，欢迎大家积极交流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;：本人入职之后算是第一次真正去写 React，发现了 React 的组件系统和其他框架的组件系统有些许的不同，这也触发了我对其中组件的可控性的一些思考和总结。&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="React" scheme="https://blog.xgheaven.com/categories/React/"/>
    
    
      <category term="React" scheme="https://blog.xgheaven.com/tags/React/"/>
    
      <category term="Component" scheme="https://blog.xgheaven.com/tags/Component/"/>
    
  </entry>
  
  <entry>
    <title>尝鲜用 React Hook + Parcel 构建真心话大冒险简单页面</title>
    <link href="https://blog.xgheaven.com/2018/12/26/react-hook-with-parcel-to-build-truth-or-dare/"/>
    <id>https://blog.xgheaven.com/2018/12/26/react-hook-with-parcel-to-build-truth-or-dare/</id>
    <published>2018-12-26T01:52:47.000Z</published>
    <updated>2023-09-16T15:48:05.165Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>阅读推荐</strong>：本人需要您有一定的 React 基础，并且想<strong>简单</strong>了解一下 Hook 的工作方式和注意点。但是并不详细介绍 React Hook，如果想有进一步的了解，可以查看官方文档。因为项目比较简单，所以我会比较详细的写出大部分代码。建议阅读文章之前请先阅读目录找到您关注的章节。</p></blockquote><!-- TOC --><h1 id="React-Hook-Parcel"><a href="#React-Hook-Parcel" class="headerlink" title="React Hook + Parcel"></a>React Hook + Parcel</h1><p>几天前，我女票和我说他们新人培训需要一个《真心话大冒险》的界面，想让我帮她写一个。我说好呀，正好想到最近的 React Hook 还没有玩过，赶紧来试试，于是花了一个晚上的时间，其实是俩小时，一个小时搭建项目，一个小时写。</p><p>Demo: <a href="http://souche-truth-or-dare.surge.sh" target="_blank" rel="noopener">http://souche-truth-or-dare.surge.sh</a> (因为女票是大搜车的)</p><img src="/2018/12/26/react-hook-with-parcel-to-build-truth-or-dare/demo.gif"><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>首先我们创建一个文件夹，做好初始化操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir truth-or-dare</span><br><span class="line"><span class="built_in">cd</span> truth-or-dare</span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>安装好依赖，<code>react@next</code> <code>react-dom@next</code> <code>parcel-bundler</code> <code>emotion@9</code> <code>react-emotion@9</code> <code>babel-plugin-emotion@9</code>。</p><blockquote><p>React Hook 截止发稿前（2018-12-26）还处于测试阶段，需要使用 <code>next</code> 版本。</p><p><code>emotion</code> 是一个比较完备的 css-in-js 的解决方案，对于我们这个项目来讲是非常方便合适的。另外因为 emotion@10 的最新版本对 <code>parcel</code> 还有一定的兼容性问题，见 <a href="https://github.com/parcel-bundler/parcel/issues/2237" target="_blank" rel="noopener">issue</a>。所以这里暂时使用 <code>emotion@9</code> 的旧版本。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i react@next react-dom@next emotion@9 react-emotion@9</span><br><span class="line">npm i parcel-bundler babel-plugin-emotion@9 -D</span><br></pre></td></tr></table></figure><p>创建 <code>.babelrc</code> 文件或者在 <code>package.json</code> 中写入 Babel 配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugin"</span>: [</span><br><span class="line">    [<span class="string">"emotion"</span>, &#123;<span class="attr">"sourceMap"</span>: <span class="literal">true</span>&#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 <code>src</code> 文件夹，并创建 <code>index.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>真心话大冒险<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./index.jsx"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>和 <code>index.jsx</code> 文件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>First Render<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure><p>最后添加如下 <code>scripts</code> 到 <code>package.json</code> 中</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"start"</span>: <span class="string">"parcel serve src/index.html"</span>,</span><br><span class="line">  <span class="attr">"build"</span>: <span class="string">"rm -rf ./dist &amp;&amp; parcel build src/index.html"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们就可以 <code>npm start</code> 就可以成功启动开发服务器了。在浏览器中打开 <code>localhost:1234</code> 即可。</p><p><code>parcel</code> 已经内建了 Hot Reload，所以不需要进行额外的配置，开箱即用。是不是觉得非常简单，有了它，手动搭建项目不再困难。当然了，TS 也是开箱即用的，不过这次我这个项目真的很小，就不用 TS 了。</p><h3 id="useState-第一个接触的-Hook"><a href="#useState-第一个接触的-Hook" class="headerlink" title="useState 第一个接触的 Hook"></a>useState 第一个接触的 Hook</h3><p>我们创建一个 <code>App.jsx</code> 开始我们真正的编码。先简单来看一下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [selected, setSelected] = useState(<span class="string">'*'</span>)</span><br><span class="line">  <span class="keyword">const</span> [started, setStarted] = useState(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;&#123;selected&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button&gt;&#123;started ? '结束' : '开始'&#125;&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>我们就完成了对 Hook 最简单的使用，当然了现在还没有任何交互效果，也许你并不明白这段代码有任何用处。</p><p>简单讲解一下 useState，这个函数接受一个参数，为初始值，可以是任意类型。它会返回一个 <code>[any, (v: any) =&gt; void]</code> 的元组。其中第一个 State 的值，另一个是一个 Setter，用于对 State 设置值。</p><p>这个 Setter 我们如何使用呢？只需要在需要的地方调用他就可以了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;() =&gt; setStarted(!started)&#125;&gt;&#123;started ? <span class="string">'结束'</span> : <span class="string">'开始'</span>&#125;&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>保存，去页面点击一下这个按钮看看，是不是发现他会在 <code>结束</code> 和 <code>开始</code> 之间切换？Setter 就是这么用，非常简单，如果用传统的 Class Component 来理解的话，就是调用了 <code>this.setState({started: !this.state.started})</code> 。不过和 setState 不同的是，Hook 里面的所有数据比较都是 <code>===</code>（严格等于）。</p><p>useState 还有很多用法，比如说 Setter 支持接收一个函数，用于传入之前的值以及返回更新之后的值。</p><h3 id="useEffect-监听开始和结束事件"><a href="#useEffect-监听开始和结束事件" class="headerlink" title="useEffect 监听开始和结束事件"></a>useEffect 监听开始和结束事件</h3><p>接下来，我们想要点击开始之后，屏幕上一直滚动，直到我点击结束。</p><p>如果这个需求使用 Class Component 来实现的话，是这样的：</p><ol><li>监听按钮点击事件</li><li>判断是开始还是结束<ul><li>如果是开始，那么就创建一个定时器，定时从数据当中随机获取一条真心话或大冒险并更新 <code>selected</code></li><li>如果是结束，那么就删除之前设置的定时器</li></ul></li></ol><p>非常直接，简单粗暴。</p><p>用了 Hook 之后，当然也可以这样做了，不过你还需要额外引入一个 State 来存储 timer，因为函数组件无法持有变量。但是如果我们换一种思路：</p><ol><li>监听 <code>started</code> 变化<ul><li>如果是开始，那么创建一个定时器，做更新操作</li><li>如果是结束，那么删除定时器</li></ul></li></ol><p>好像突然变简单了，让我们想象这个用 Class Component 怎么实现呢？</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidUpdate(_, preState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.started !== preState.started) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state.started) &#123;</span><br><span class="line">        <span class="keyword">this</span>.timer = setInterval(<span class="comment">/* blahblah*/</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearInterval(<span class="keyword">this</span>.timer)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// blahblah</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好麻烦，而且逻辑比较绕，而且如果 componentDidUpdate 与 render 之间有非常多的代码的时候，就更难对代码进行分析和阅读了，如果你后面维护这样的代码，你会哭的。可是用 useEffect Hook 就不一样了。画风如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 之前的代码</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 当 started 变化的时候，调用传进去的回调</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (started) &#123;</span><br><span class="line">      <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setSelected(chooseOne())</span><br><span class="line">      &#125;, <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(timer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [started])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 返回的 View</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用了 React Hook 之后，所有的逻辑都在一起了，代码清晰且便于阅读。</p><p>useEffect 从字面意义上来讲，就是可能会产生影响的一部分代码，有些地方也说做成副作用，其实都是没有问题的。但是副作用会个人一种感觉就是这段代码是主动执行的而不是被动执行的，不太好理解。我觉得更好的解释就是受到环境（State）变化影响而执行的代码。</p><p>为什么这么理解呢？你可以看到 useEffect 还有第二个参数，是一个数组，React 会检查这个数组这次渲染调用和上次渲染调用（因为一个组件内可能会有多次 useEffect 调用，所以这里加入了<strong>渲染</strong>限定词）里面的每一项和之前的是否变化，如果有一项发生了变化，那么就调用回调。</p><p>当理解了这个流程之后，或许你就能理解为什么我这么说。</p><p>当然了，第二个参数是可以省略的，省略之后就相当于默认监听了全部的 State。（现在你可以这么理解，但是当你进一步深入之后，你会发现不仅仅有 State，还有 Context 以及一些其他可能触发状态变化的 Hook，本文不再深入探究）</p><p>到现在，我们再来回顾一下关于定时器的流程，先看一下代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (started) &#123;</span><br><span class="line">  <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setSelected(chooseOne())</span><br><span class="line">  &#125;, <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(timer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理想的流程是这样的：</p><ul><li>如果开始，那么注册定时器。——Done!</li><li>如果是结束，那么取消定时器。——Where? </li></ul><p>咦，<code>else</code> 的分支去哪里了？为啥在第一个分支返回了取消定时器的函数？</p><p>这就牵扯到 useEffect 的第二个特性了，他不仅仅支持做正向处理，也支持做反向清除工作。你可以返回一个函数作为清理函数，当 effect 被调用的时候，他会先调用上次 effect 返回的清除函数（可以理解成析构），然后再调用这次的 effect 函数。</p><p>于是我们轻松利用这个特性，可以在只有一条分支的情况下实现原先需要两条分支的功能。</p><h3 id="其他-Hook"><a href="#其他-Hook" class="headerlink" title="其他 Hook"></a>其他 Hook</h3><p>在 Hook 中，上面两个是使用非常频繁的，当然还有其他的比如说 <code>useContext</code>/<code>useReducer</code>/<code>useCallback</code>/<code>useMemo</code>/<code>useRef</code>/<code>useImperativeMethods</code>/<code>useLayoutEffect</code>。</p><p>你可以创建自己的 Hook，在这里 React 遵循了一个约定，就是所有的 Hook 都要以 <code>use</code> 开头。为了 ESLint 可以更好对代码进行 lint。</p><p>这些都属于高级使用，感兴趣的可以去研究一下，本片文章只是入门，不再过多讲解。</p><h3 id="我们来用-Emotion-加点样式"><a href="#我们来用-Emotion-加点样式" class="headerlink" title="我们来用 Emotion 加点样式"></a>我们来用 Emotion 加点样式</h3><p>css-in-js 大法好，来一顿 Duang, Duang, Duang 的特技就好了，代码略过。</p><h3 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h3><p>重新修改 <code>src/index.jsx</code> 文件，将 <code>&lt;div/&gt;</code> 修改为 <code>&lt;App/&gt;</code> 即可。</p><p>最后的 <code>src/App.jsx</code> 文件如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'react-emotion'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lists = [</span><br><span class="line">  <span class="string">'说出自己的5个缺点'</span>,</span><br><span class="line">  <span class="string">'绕场两周'</span>,</span><br><span class="line">  <span class="string">'拍一张自拍放实习生群里'</span>,</span><br><span class="line">  <span class="string">'成功3个你说我猜'</span>,</span><br><span class="line">  <span class="string">'记住10个在场小伙伴的名字'</span>,</span><br><span class="line">  <span class="string">'大声说出自己的名字“我是xxx”3遍'</span>,</span><br><span class="line">  <span class="string">'拍两张自拍放实习生群里'</span>,</span><br><span class="line">  <span class="string">'选择另一位小伙伴继续游戏'</span>,</span><br><span class="line">  <span class="string">'直接通过'</span>,</span><br><span class="line">  <span class="string">'介绍左右两个小伙伴'</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chooseOne</span>(<span class="params">selected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="string">''</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    n = lists[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * lists.length)]</span><br><span class="line">  &#125; <span class="keyword">while</span>( n === selected)</span><br><span class="line">  <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Root = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  background: #FF4C19;</span></span><br><span class="line"><span class="string">  height: 100vh;</span></span><br><span class="line"><span class="string">  width: 100vw;</span></span><br><span class="line"><span class="string">  text-align: center;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Title = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  height: 50%;</span></span><br><span class="line"><span class="string">  font-size: 18vh;</span></span><br><span class="line"><span class="string">  text-align: center;</span></span><br><span class="line"><span class="string">  color: white;</span></span><br><span class="line"><span class="string">  padding: 0 10vw;</span></span><br><span class="line"><span class="string">  font-family:"Microsoft YaHei",Arial,Helvetica,sans-serif,"宋体";</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = styled.button<span class="string">`</span></span><br><span class="line"><span class="string">  outline: none;</span></span><br><span class="line"><span class="string">  border: 2px solid white;</span></span><br><span class="line"><span class="string">  border-radius: 100px;</span></span><br><span class="line"><span class="string">  min-width: 120px;</span></span><br><span class="line"><span class="string">  width: 30%;</span></span><br><span class="line"><span class="string">  text-align: center;</span></span><br><span class="line"><span class="string">  font-size: 12vh;</span></span><br><span class="line"><span class="string">  line-height: 20vh;</span></span><br><span class="line"><span class="string">  margin-top: 15vh;</span></span><br><span class="line"><span class="string">  color: #FF4C19;</span></span><br><span class="line"><span class="string">  cursor: pointer;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [selected, setSelected] = useState(<span class="string">'-'</span>)</span><br><span class="line">  <span class="keyword">const</span> [started, setStarted] = useState(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setStarted(!started)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (started) &#123;</span><br><span class="line">      <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setSelected(chooseOne(selected))</span><br><span class="line">      &#125;, <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(timer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [started])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Root&gt;</span><br><span class="line">      &lt;Title&gt;&#123;selected&#125;&lt;<span class="regexp">/Title&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Button onClick=&#123;onClick&#125;&gt;&#123;started ? '结束' : '开始'&#125;&lt;/</span>Button&gt;</span><br><span class="line">    &lt;<span class="regexp">/Root&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="总结复盘-——-性能问题？"><a href="#总结复盘-——-性能问题？" class="headerlink" title="总结复盘 —— 性能问题？"></a>总结复盘 —— 性能问题？</h3><p>最近刚刚转正答辩，突然发现<strong>复盘</strong>这个词还挺好用的，哈哈哈。</p><p>虽然这么短时间的使用，还是有一些自己的思考，说出来供大家参考一下。</p><p>如果你仔细思考一下会发现，当使用 useEffect 的时候，其实每次都是创建了一个新的函数，但并不是说每次都会调用这个函数。如果你代码里面 useEffect 使用的很多，而且代码还比较长，每次渲染都会带来比较大的性能问题。</p><p>所以解决这个问题有两个思路：</p><ol><li><p>不要在 Hook 中做太多的逻辑，比如说可以让 Hook 编写一些简单的展示组件，比如 Tag/Button/Loading 等，逻辑不复杂，代码量小，通过 Hook 写在一起可以降低整个组件的复杂度。</p></li><li><p>将 Effect 拆分出去，并通过参数传入。类似于这个样子</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someEffect</span>(<span class="params">var1, var2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// doSomething</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// useState...</span></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> someEffect(var1, var2), [someVar])</span><br><span class="line">    <span class="comment">// return ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这也是创建了一个函数，但是这个函数创建的速度和创建一个几十行几百行的逻辑的函数相比，确实快了不少。其次不建议使用 <code>.bind</code> 方法，他的执行效率并没有这种函数字面量快。</p><p>这种方式不建议手动来做，可以交给 babel 插件做这部分的优化工作。</p></li></ol><p>其实作为一个开发者来说，不应该太多的关注这部分，但是性能就是程序员的 XX 点，我还是会下意识从性能的角度来思考。这里只是提出了一点小小的优化方向，希望以后 React 官方也可以进一步做这部分的优化工作。</p><p>已经有的优化方案，可以查看官方 <a href="https://reactjs.org/docs/hooks-faq.html#performance-optimizations" target="_blank" rel="noopener">FAQ</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过这个简短的使用，感觉用了 Hook 你可以将更多的精力放在逻辑的编写上，而不是数据流的流动上。对于一些轻组件来说简直是再合适不过了，希望早点能够正式发布正式使用上吧。</p><p>另外 <code>parcel</code> 提供了强大的内置功能，让我们有着堪比 <code>webpack</code> 的灵活度却有着比 <code>webpack</code> 高效的开发速度。</p><p>好的，一篇 1 小时写代码，1 天写文章的水文写完了。以后如果有机会再深入尝试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;阅读推荐&lt;/strong&gt;：本人需要您有一定的 React 基础，并且想&lt;strong&gt;简单&lt;/strong&gt;了解一下 Hook 的工作方式和注意点。但是并不详细介绍 React Hook，如果想有进一步的了解，可以查看官方文档。因
      
    
    </summary>
    
      <category term="React" scheme="https://blog.xgheaven.com/categories/React/"/>
    
    
      <category term="React" scheme="https://blog.xgheaven.com/tags/React/"/>
    
      <category term="React Hook" scheme="https://blog.xgheaven.com/tags/React-Hook/"/>
    
      <category term="Parcel" scheme="https://blog.xgheaven.com/tags/Parcel/"/>
    
  </entry>
  
  <entry>
    <title>【后知后觉系列】Css Position: Sticky 属性以及某些场景的使用</title>
    <link href="https://blog.xgheaven.com/2018/11/18/hindsight-fe-what-usage-of-position-sticky/"/>
    <id>https://blog.xgheaven.com/2018/11/18/hindsight-fe-what-usage-of-position-sticky/</id>
    <published>2018-11-18T14:03:41.000Z</published>
    <updated>2023-09-16T15:51:09.747Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>不知何时，曾经我们认为的东西便会被打破，如果我们不坚持着去学习，那么我们终将会被社会所淘汰。于是我决定写《后知后觉系列》来记录一下我曾经跟不上的知识和关键点，内容不一定复杂，内容含量不一定高，也许别人已经写过一个一样的教程了，但是希望你能从我的笔记中获取你认为重要的东西，在纷繁复杂的工作中留下一个真正极客的世界，希望某一天这些东西都能够运用到工作当中。——XGHeaven</p></blockquote><blockquote><p>记得先看一下目录，找到你喜欢好奇的内容去针对性阅读，毕竟我不是来写教程的。</p></blockquote><!-- TOC --><h1 id="position-sticky-这究竟是一个什么鬼？"><a href="#position-sticky-这究竟是一个什么鬼？" class="headerlink" title="position: sticky 这究竟是一个什么鬼？"></a>position: sticky 这究竟是一个什么鬼？</h1><p>最近公司在用 Regular 封装一个表格组件，需要实现固定表头的功能。这个是几乎所有的组件库都会实现的一个效果，所以实现方式有很多种：</p><ol><li>因为 thead/tr 的 position 属性是无效的，所以需要单独用 div 创建一个表头。然后设置这个表头的 <code>position: absolute</code>，同时 <code>top: 0</code>。同时这种模式下，需要用户指定每一列的宽度，保证自制的表头和下面原生的表格一一对应起来。如果不指定的话，也可以等待 dom 渲染完成之后，再测量宽度。比如 Ant Design 就是使用的这种方式。</li><li>因为上面那种方案的难点在于无法很好的保证自制表头和原生表格宽度的一致性，所以我们组的大佬提出了使用原生 thead，监听 scroll 事件，设置 <code>transform</code> 属性使得表头进行偏移，从而实现 fixHeader 的问题，这种方式解决了第一个的问题，但是需要手动监听 scroll 事件，在快速滚动的情况下，可能会有一定的性能问题。而且不够优雅。如果后面的表格内容中有 <code>position: relative</code> 的元素，会覆盖到表头。</li></ol><p>不管是哪种方式，我总感觉不是很完美，于是我就在思考，除了手动更新的方式，难道就没有一些比较好的方式去做。然后我就去翻看了 github 的固定表头的方式，顿时豁然开朗。于是就延伸出了这篇文章，<code>position: sticky</code> 属性。</p><p><strong>Pay Attention</strong>：后面所讲的内容就不怎么和表格固定表头相关，如果你对表格固定表头或者固定列有一定问题，可以查看网易考拉的这篇文章 <a href="https://blog.kaolafed.com/2017/12/25/一起来聊聊table组件的固定列/" target="_blank" rel="noopener">《一起来聊聊table组件的固定列》</a>。</p><p>当第一眼看到这个熟悉的时候，第一句话就是“我 CA”，这 TMD 是什么鬼属性，position 什么时候有了这个属性。于是去看了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position" target="_blank" rel="noopener">MDN</a> 的介绍，可以理解为，这个属性是<strong>实现固定顶部最简单的实现方式</strong>。</p><p>他其实是一种 <code>position:relative</code> 和  <code>position: fixed</code> 的结合体，一定要配合 <code>top/right/bottom/left</code> 的属性一起才有作用，设置对应方向的最小值。当大于最小值的时候，他就像 <code>relative</code> 一样，作为文档流的一部分，并且 <code>top/right/bottom/left</code> 属性也会失效。否则当小于设置的值的时候表现的像 <code>fixed</code>，只不过这个 <code>fixed</code> 不再现对于窗口，而是相对于最近的可滚动块级元素。</p><p>如果你看过其他关于 sticky 的文章，大部分都会以黏贴的意思来解释他，那么很明显，确实也是这个意思，如果你觉得看了其他教程能够清楚的话，那么可以不用看我这篇了，如果你没看懂的话，可以来我这里看看。</p><p>废话少说，我们先来看一下如何正确使用 sticky。</p><h2 id="正确的使用姿势"><a href="#正确的使用姿势" class="headerlink" title="正确的使用姿势"></a>正确的使用姿势</h2><blockquote><p>以下的代码预览请使用最新 Chrome 查看，或者支持 <code>position: sticky</code> 的浏览器查看。部分网站不支持 iframe，可以去我的 Blog 查看</p></blockquote><ol><li><p><code>position: sticky</code> 只相对于第一个有滚动的父级块元素（scrolling mechanism，通过 overflow 设置为 <code>overflow/scroll/auto/overlay</code> 的元素），而不是父级块元素。</p><iframe height="265" scrolling="no" title="position sticky 相对于最外面的可滚动父级" src="//codepen.io/xgheaven/embed/preview/zMjPRL/?height=265&theme-id=dark&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/xgheaven/pen/zMjPRL/" target="_blank" rel="noopener">position sticky 相对于最外面的可滚动父级</a> by Bradley Xu (<a href="https://codepen.io/xgheaven" target="_blank" rel="noopener">@xgheaven</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe></li><li><p><code>position: sticky</code> 只有当设置对应的方向(top/right/bottom/left)，才会有作用，并且可以互相叠加，可以同时设置四个方向。</p></li><li><p>即使设置了 <code>position: sticky</code>，也只能显示在父级块元素的内容区域，他无法超出这个区域，除非你设置了负数的值。</p></li><li><p><code>position: sticky</code> 并不会触发 BFC，简单来讲就是计算高度的时候不会计算 float 元素。</p></li><li><p>当设置了 <code>position: sticky</code> 之后，内部的定位会相对于这个元素</p><iframe height="265" scrolling="no" title="position sticky 内部绝对定位相对于这个元素" src="//codepen.io/xgheaven/embed/preview/qQKbJO/?height=265&theme-id=dark&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/xgheaven/pen/qQKbJO/" target="_blank" rel="noopener">position sticky 内部绝对定位相对于这个元素</a> by Bradley Xu (<a href="https://codepen.io/xgheaven" target="_blank" rel="noopener">@xgheaven</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe></li><li><p>虽然 <code>position: sticky</code> 表现的像 <code>relative</code>  或者 <code>fixed</code>，所以也是可以通过 <code>z-index</code> 设置他们的层级。当这个元素的后面的兄弟节点会覆盖这个元素的时候，可以通过 <code>z-index</code> 调节层级。</p><p></p><p data-height="265" data-theme-id="dark" data-slug-hash="LXodKa" data-default-tab="css,result" data-user="xgheaven" data-pen-title="position: sticky 通过 z-index 调节层级" data-preview="true" class="codepen">See the Pen <a href="https://codepen.io/xgheaven/pen/LXodKa/" target="_blank" rel="noopener">position: sticky 通过 z-index 调节层级</a> by Bradley Xu (<a href="https://codepen.io/xgheaven" target="_blank" rel="noopener">@xgheaven</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script></li></ol><p>当你懂了这几个之后，其实这个属性就用起来就很简单了。</p><h2 id="举个栗子-通讯录列表头部"><a href="#举个栗子-通讯录列表头部" class="headerlink" title="举个栗子 - 通讯录列表头部"></a>举个栗子 - 通讯录列表头部</h2><p>no code no bb，直接上代码。</p><iframe height="265" scrolling="no" title="position sticky 通讯录 Demo" src="//codepen.io/xgheaven/embed/preview/RqyYvZ/?height=265&theme-id=dark&default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/xgheaven/pen/RqyYvZ/" target="_blank" rel="noopener">position sticky 通讯录 Demo</a> by Bradley Xu (<a href="https://codepen.io/xgheaven" target="_blank" rel="noopener">@xgheaven</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><h2 id="拓展思考"><a href="#拓展思考" class="headerlink" title="拓展思考"></a>拓展思考</h2><h3 id="如何检测是否已经被固定？"><a href="#如何检测是否已经被固定？" class="headerlink" title="如何检测是否已经被固定？"></a>如何检测是否已经被固定？</h3><p>最常见的需求就是，当还在文档流当中的时候，正常显示，但是当固定住的时候，添加一些阴影或者修改高度等操作。要想实现这个效果，第一反应可能就是手动监听 <code>scroll</code> 事件，判断位置，这当然是没有问题的，但是随之而来的确实性能的损耗。</p><p>最好的方式是使用 IntersectionObserver，这是一个可以监听一个元素是否显示在视窗之内的 API，具体内容见阮老师的<a href="http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html" target="_blank" rel="noopener">《IntersectionObserver API 使用教程》</a>。基本原理就是在一段滚动的头部和尾部分别添加两个岗哨，然后通过判断这两个岗哨的出现和消失的时机，来判断元素是否已经被固定。</p><p>例子<a href="https://ebidel.github.io/demos/sticky-position-event.html" target="_blank" rel="noopener">详见此处</a></p><h3 id="那能不能实现表格头-列固定呢？"><a href="#那能不能实现表格头-列固定呢？" class="headerlink" title="那能不能实现表格头/列固定呢？"></a>那能不能实现表格头/列固定呢？</h3><p><del>理想很丰满，显示很骨感，因为 thead/tbody 对 position 无爱，所以也就不支持 sticky 属性，所以我们还是要单独创建一个头部。</del></p><p>后来经过网友提醒，自己又去研究了一下，发现还是有办法做到固定表头和列的。</p><p>首先针对 Firefox，它本身就支持 thead/tbody 的 position 属性，所以可以直接通过对 thead/tbody 设置 position 来实现。而对于 Chrome 浏览器来讲，可以通过设置 thead 内的 th 来实现。具体见 Demo.</p><p></p><p data-height="265" data-theme-id="dark" data-slug-hash="RqmMQm" data-default-tab="html,result" data-user="xgheaven" data-pen-title="position sticky 通过设置 td 来实现固定表头" data-preview="true" class="codepen">See the Pen <a href="https://codepen.io/xgheaven/pen/RqmMQm/" target="_blank" rel="noopener">position sticky 通过设置 td 来实现固定表头</a> by Bradley Xu (<a href="https://codepen.io/xgheaven" target="_blank" rel="noopener">@xgheaven</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><p><strong>然后好像就没有了</strong>，谢谢观看水水的《后知后觉系列》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;不知何时，曾经我们认为的东西便会被打破，如果我们不坚持着去学习，那么我们终将会被社会所淘汰。于是我决定写《后知后觉系列》来记录一下我曾经跟不上的知识和关键点，内容不一定复杂，内容含量不一定高，也许别人已经写过一个一样的教程了，但是希望你能从我的笔记
      
    
    </summary>
    
      <category term="后知后觉" scheme="https://blog.xgheaven.com/categories/%E5%90%8E%E7%9F%A5%E5%90%8E%E8%A7%89/"/>
    
    
      <category term="​- CSS - Relearning" scheme="https://blog.xgheaven.com/tags/%E2%80%8B-CSS-Relearning/"/>
    
  </entry>
  
  <entry>
    <title>安装 CentOS7 中我所遇到的一些麻烦</title>
    <link href="https://blog.xgheaven.com/2018/10/14/the-trouble-of-installing-centos7/"/>
    <id>https://blog.xgheaven.com/2018/10/14/the-trouble-of-installing-centos7/</id>
    <published>2018-10-14T06:12:02.000Z</published>
    <updated>2023-09-16T15:48:05.164Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><blockquote><p>自己家里有一台 Dell 服务器，之前一直跑着 FreeNAS，后来发现自己对 NAS 的需求并不是很高，所以我决定装回 Linux，之前用的 Debian，虽然 Debian 很好，但是没法只使用 root 用户，所以我又回归了 CentOS 系统，但是问题并没有我想的那么简单。</p></blockquote><p>另外，这是一篇总结文章，所以<code>没有图</code>，见谅。</p><h2 id="Trouble-1-U-盘启动找不到启动盘"><a href="#Trouble-1-U-盘启动找不到启动盘" class="headerlink" title="Trouble 1: U 盘启动找不到启动盘"></a>Trouble 1: U 盘启动找不到启动盘</h2><p>这里所说的找不到启动盘并不是说无法进入引导界面，而是说进入了引导界面但是无法正确加载安装镜像。具体表现请往下看</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>相信大家装过系统的都知道，在 Windows 上面有很多 ISO 刻录到 U 盘的工具，这些工具非常好用，所以我就理所当然的用 <code>ISO to USB</code> 这个软件刻录启动 U 盘。</p><p>我刻录的是 <code>CentOS-7-DVD</code> 的版本，大约 4.2G，里面包含了必要的安装包。</p><p>U 盘刻录完成，插入电脑，启动，一切正常，进入选择界面，选择 <code>Install CentOS 7</code>，之后问题来了，出现了 <code>failed to map image memory</code> 提示，之后等了一段时间之后就一直出现 <code>warning:dracut-initqueue timeout-starting timeout script</code> 的提示，最终显示启动失败，进入恢复模式，显示 <code>dracut:/#</code> 终端提示符，不管怎么重启都不行。</p><p>当然，Google 当然是有结果的，<a href="https://blog.csdn.net/weixin_42609121/article/details/81737671" target="_blank" rel="noopener">《安装CentOS7.4出现failed to map image memory以及warning:dracut-initqueue timeout的解决办法》</a> 指出了原因和解决方案。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>出现这个原因是因为找不到启动盘，解决方案其实也很简单，就是手动设置一下就可以了。</p><p>首先找到你的 U 盘是哪个硬盘符，方法就是在恢复模式下运行 <code>ls -l /dev | grep sd</code>，可以看到一系列的文件，一般情况下 sda 是硬盘，sdb 是 U 盘，sda1 是硬盘上第一个分区，同理 sda2 是第二个分区。如果你有多个硬盘，那么 U 盘可能是 sdc, sdd 等等，找到你的 U 盘启动盘的分区，我的是 sdb1。</p><p>然后在选择界面的时候按 e，然后将 <code>inst.stage2=hd:LABEL=CentOS\x207\x20x86_64.check</code> 修改为 <code>inst.stage2=hd:/dev/sdbx(你u盘所在)</code>，之后修改结束之后按 <code>Ctrl+x</code> 退出就可以正常进入安装界面了。</p><p>那么有人会说每次启动都要这么做么？答案是的，但实在是太麻烦了，不急，这个也是有办法解决的，办法请看 Trouble 3 的解决方案。</p><h2 id="Trouble-2-安装的时候明明插着网线但是却提示无网络"><a href="#Trouble-2-安装的时候明明插着网线但是却提示无网络" class="headerlink" title="Trouble 2: 安装的时候明明插着网线但是却提示无网络"></a>Trouble 2: 安装的时候明明插着网线但是却提示无网络</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>进入安装界面之后，会有一个网络的选项，一直提示未连接，不管你怎么设置。无论是你拔插网线还是禁用启用都不行。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>这是因为 CentOS 默认的网络是不自动连接的，你可以在设置界面，选择 General ，也就是第一个标签页，把启动时自动连接网络的选项勾选，然后保存。然后就会自动去获取 ip 地址然后可以上网了。</p><p>这一点的设计实在是太 SB 了，不知道为啥要设计成这个样子。</p><h2 id="Trouble-3-CentOS-安装的时候一直卡死在设置安装源"><a href="#Trouble-3-CentOS-安装的时候一直卡死在设置安装源" class="headerlink" title="Trouble 3: CentOS 安装的时候一直卡死在设置安装源"></a>Trouble 3: CentOS 安装的时候一直卡死在设置安装源</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>当我们成功进入安装界面的时候，你会发现他的安装源是无效的，需要你自己去设置。<br>理论上来讲使用的是 DVD 的镜像，是自带了很多包的，不会出现这种情况。<br>而且出现这种情况的时候，是无法选择本地的安装源的，只能填写网络。<br>但是不管你填写的是官方的安装源还是阿里、网易的安装源，都会一直卡死在设置安装源这个环节。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>经过 Google，得知原因是因为刻录 U 盘的方式不对。<a href="http://blog.sina.com.cn/s/blog_757fc71d0102w7bb.html" target="_blank" rel="noopener">《CentOS7安装时的新问题》</a> 给出了原因和解决方案。</p><p>引用之</p><blockquote><p>绝望中，无意间看到 Centos 百科(<a href="https://wiki.centos.org/zh/HowTos/InstallFromUSBkey" target="_blank" rel="noopener">https://wiki.centos.org/zh/HowTos/InstallFromUSBkey</a>) 上的一段话：“由于 CentOS 7 安装程序的映像采用了特殊的分区，而截至 2014 年 7 月，大部份Windows 工具都不能正确地转移，因此利用 USB 存储器开机时会导致不能预知的结果。（暂时）已知不适用的工具包括 unetbootin 和 universal usb installler。已确定能正确运作的有 Rufus、Fedora LiveUSB Creator、Win32 Disk Imager、Rawrite32 及 dd for Windows。如果采用 Windows 7 以上的版本，请先卸下该 USB 存储器（其中一个方法是在执行工具程序前把存储器格式化），否则 indows 可能会拒绝写入该存储器，出现 can’t write to drive 错误及取消行动。”</p></blockquote><p>可以得知，CentOS 的 ISO 镜像的刻录方式比较特殊，大部分软件都无法很好的兼容，但是 dd 可以非常好的兼容，所以这里我切换了刻录软件，使用 <code>Rufus</code> 进行刻录，并且选择 DD 模式。</p><p>然后重启启动，哈哈哈，不仅仅这个问题解决了，还完美解决了 Trouble 1 无法找到启动盘的问题。</p><h2 id="安装完毕"><a href="#安装完毕" class="headerlink" title="安装完毕"></a>安装完毕</h2><p>记得之前安装的时候，也没有遇到这么多麻烦。这次既然遇到了就记录下来。</p><p>之后我就可以开心的玩耍了，装了 Docker，切换安装源到网易，安装 epel 等等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;blockquote&gt;
&lt;p&gt;自己家里有一台 Dell 服务器，之前一直跑着 FreeNAS，后来发现自己对 NAS 的需求并不是很高，所以我决定装回 Linux，之前用的 Debian，虽然 Debian 很好，但是没法只使用 root 用户，所以我
      
    
    </summary>
    
      <category term="CentOS" scheme="https://blog.xgheaven.com/categories/CentOS/"/>
    
    
      <category term="CentOS" scheme="https://blog.xgheaven.com/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>为什么我从 Npm 到 Yarn 再到 Npm?</title>
    <link href="https://blog.xgheaven.com/2018/05/03/npm-to-yarn-to-npm/"/>
    <id>https://blog.xgheaven.com/2018/05/03/npm-to-yarn-to-npm/</id>
    <published>2018-05-03T09:52:35.000Z</published>
    <updated>2023-09-16T15:48:05.164Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从接触到 node 环境来说，其中一个不可或缺的一部分便是 npm 包管理，但是由于官方的 npm 有各种各样的问题，于是催生了很多不同的版本，这其中的曲折也许只有过来人才知道。</p></blockquote><h2 id="放弃-npm"><a href="#放弃-npm" class="headerlink" title="放弃 npm?"></a>放弃 npm?</h2><h3 id="上古时代"><a href="#上古时代" class="headerlink" title="上古时代"></a>上古时代</h3><p>在上古版本(应该是 npm3 以前的版本，具体我也记不清了)，npm 的安装策略并不是扁平化的，也就是说比如你安装一个 <code>express</code>，那么你会在 <code>node_modules</code> 下面只找到一个 <code>express</code> 的文件夹。而 <code>express</code> 依赖的项目都放在其文件夹下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- app/</span><br><span class="line">  - package.json</span><br><span class="line">  - node_modules/</span><br><span class="line">    - express/</span><br><span class="line">      - index.js</span><br><span class="line">      - package.json</span><br><span class="line">      - node_modules/</span><br><span class="line">        - ...</span><br></pre></td></tr></table></figure><p>这个带来的问题或许 windows 用户深谙其痛，因为在这种安装环境下，会导致目录的层级特别高，而对于 windows 来说，最大的路径长度限制在 248 个字符(<a href="https://www.cnblogs.com/52cik/p/node-modules-del.html" title="Windows 路径长度" target="_blank" rel="noopener">更多请见此</a>)，再加上 <code>node_modules</code> 这个单词又特别长，所以你懂得，哈哈哈。解决方案啥的自己去搜索吧，反正估计现在也没人会用上古版本了。</p><p>除了 windows 用户出现的问题以外，还有一个更严重的问题，就是模块都是独立的，比如说位于 <code>express</code> 下面的 <code>path-to-regexp</code> 和 <code>connect</code> 下面的 <code>path-to-regexp</code> 的模块是两个不同的模块。<br>那么这个会带来什么影响呢？其实在使用上，并没有什么太大的影响，但是内存占用过大。因为很多相同模块位于不同模块下面就会导致有多个实例的出现(为什么会加载多个实例，请查看 <a href="https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js" title="Node 模块加载" target="_blank" rel="noopener">Node 模块加载</a>)。你想想，都是同样的功能，为什么要实例这么多次呢？不能就加载一次，复用实例么？</p><p>上古时代的 npm 的缺点可以说还是很多的：</p><ul><li>目录嵌套层级过深</li><li>模块实例无法共享</li><li>安装速度很慢，这其中有目录嵌套的原因，也有安装逻辑的问题。因为 npm 是请求完一个模块之后再去请求另一个模块，这就会导致同一个时刻，只有一个模块在下载、解析、安装。</li></ul><h3 id="软链时代"><a href="#软链时代" class="headerlink" title="软链时代"></a>软链时代</h3><p>后面，有人为了解决目录嵌套层次过高的问题，引入的软链接的方案。</p><p>简单来说，就是将所有的包都扁平化安装到一个位置，然后通过软链接(windows 快捷方式)的方式组合到 <code>node_modules</code> 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- app/</span><br><span class="line">- node_modules</span><br><span class="line">  - .modules/</span><br><span class="line">    - express@x.x.x/</span><br><span class="line">      - node_modules</span><br><span class="line">        - connect -&gt; ../../connect@x.x.x</span><br><span class="line">        - path-to-regexp -&gt; ../../path-to-regexp@x.x.x</span><br><span class="line">        - ... -&gt; ../../package-name@x.x.x</span><br><span class="line">    - connect@x.x.x/</span><br><span class="line">    - path-to-regexp@x.x.x/</span><br><span class="line">    - ...others</span><br><span class="line">  - express -&gt; ./.modules/express@x.x.x</span><br></pre></td></tr></table></figure><p>这样做的好处就是可以将整体的逻辑层级简化到很少的几层。而且对于 node 的模块解析来说，可以很好的解决相同模块不同位置导致的加载多个实例，进而导致内存占用的情况。</p><p>基于这种方案，有 <a href="https://www.npmjs.com/package/npminstall" target="_blank" rel="noopener">npminstall</a> 以及 pnpm 这个包实现了这种方案，其中 cnpm 使用的就是 npminstall，不过他们实现的方式和我上面讲的是有差异的，<a href="https://www.npmjs.com/package/npminstall#node_modules-directory" target="_blank" rel="noopener">具体请看</a>。简单来讲，他们没有 <code>.modules</code> 这一层。更多的内容，请看 npminstall 的 README。</p><p>总的来讲这种解决方案有还有以下几个好处：</p><ul><li>兼容性很好</li><li>在保证目录足够简洁的情况下，解决了上面的两个问题（目录嵌套和多实例加载）。</li><li>安装速度很快，因为采用了软连接的方式加上多线程请求，多个模块同时下载、解析、安装。</li></ul><p>那么缺点也是挺致命的：</p><ul><li>一般情况下都是第三方库实现这个功能，所以无法保证和 npm 完全一致的行为，所以遇到问题只能去找作者提交一下，然后等待修复。</li><li>无法和 npm 很方便的一起使用。最好是要么只用 npm，要么只用 cnpm/pnpm，两者混用可能会产生很奇葩的效果。</li></ul><h2 id="npm3-时代"><a href="#npm3-时代" class="headerlink" title="npm3 时代"></a>npm3 时代</h2><p>最大的改变就是将目录层级从嵌套变到扁平化，可以说很好的解决了上面嵌套层级过深以及实例不共享的问题。但是，npm3 在扁平化方案下，选择的并不是软连接的方式，而是说直接将所有模块都安装到 <code>node_modules</code> 下面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- app/</span><br><span class="line">- node_modules/</span><br><span class="line">  - express/</span><br><span class="line">  - connect/</span><br><span class="line">  - path-to-regexp/</span><br><span class="line">  - ...</span><br></pre></td></tr></table></figure><p>如果出现了不同版本的依赖，比如说 <code>package-a</code> 依赖 <a href="mailto:`package-c@0.x.x" target="_blank" rel="noopener">`package-c@0.x.x</a><code>的版本，而</code>package-b<code>依赖</code><a href="mailto:package-c@1.x.x" target="_blank" rel="noopener">package-c@1.x.x</a>` 版本，那么解决方案还是像之前的那种嵌套模式一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- app/</span><br><span class="line">- node_modules/</span><br><span class="line">  - package-a/</span><br><span class="line">  - package-c/</span><br><span class="line">    - // 0.x.x</span><br><span class="line">  - package-b/</span><br><span class="line">    - node_modules/</span><br><span class="line">      - package-c/</span><br><span class="line">        - // 1.x.x</span><br></pre></td></tr></table></figure><p>至于那个版本在外面，那个版本在里面，似乎是根据安装的先后顺序有关的，具体的我就不验证了。如果有人知道的话，欢迎告诉我。</p><p>在这个版本之后，解决了大部分问题，可以说 npm 跨入了一个新的世界。但是还要一个问题就是，他的安装速度依旧很慢，相比 cnpm 来说。所以他还有很多进步的空间。</p><h2 id="yarn-的诞生"><a href="#yarn-的诞生" class="headerlink" title="yarn 的诞生"></a>yarn 的诞生</h2><p>随着 Node 社区的越来越大，也有越来越多的人将 Node 应用到企业级项目。这也让 npm 暴露出很多问题：</p><ul><li>无法保证两次安装的版本是完全相同的。大家都知道 npm 通过语义化的版本号安装应用，你可以限制你安装模块的版本号，但是你无法限制你安装模块依赖的模块的版本号。即使有 shrinkwrap 的存在，但是很少有人会用。</li><li>安装速度慢。上文已经讲过，在一些大的项目当中，可能依赖了上千个包，甚至还包括了 C++ Addon，严重的话，安装可能要耗时 10 分钟甚至到达半个小时。这很明显是无法忍受的，尤其是配合上 CI/CD。</li><li>默认情况下，npm 是不支持离线模式的，但是在有些情况下，公司的网络可能不支持连接外网，这个时候利用缓存构建应用就是很方便的一件事情。而且可以大大减少网络请求。</li></ul><p>所以，此时 yarn 诞生了，为的就是解决上面几个问题。</p><ul><li>引入 yarn.lock 文件来管理依赖版本问题，保证每次安装都是一致的。</li><li>缓存加并行下载保证了安装速度</li></ul><p>那个时候我还在使用 cnpm，我特地比较了一下，发现还是 cnpm 比较快，于是我还是继续使用着 cnpm，因为对于我来说足够了。但是后面发现 yarn 真的越来越火，再加上 cnpm 长久不更新。我也尝试着去了用 yarn，在尝试之后，我彻底放弃了 cnpm。而且直到现在，似乎还没有加入 lock 的功能。</p><p>当然 yarn 还不只只有这么几个好处，在用户使用方面：</p><ul><li>提供了非常简洁的命令，将相关的命令进行分组，比如说 <code>yarn global</code> 下面都是与全局模块相关的命令。而且提示非常完全，一眼就能看明白是什么意思。不会像 npm 一样，<code>npm --help</code> 就是一坨字符串，还不讲解一下是什么用处，看着头疼。</li><li>默认情况安装会保存到 dependencies，不需要像 npm 一样手动添加 <code>-S</code> 参数</li><li>非常方便的 yarn run 命令，不仅仅会自动查看 package.json 中 scripts 下面的内容，还是查找 <code>node_modules/.bin</code> 下的可执行文件。这个是我用 yarn 最高的频率。比如你安装了 <code>yarn add mocha</code>，然后就可以通过 <code>yarn run mocha</code> 直接运行 <code>mocha</code>。而不需要 <code>./node_modules/.bin/mocha</code> 运行。是我最喜欢的一个功能</li><li>交互式的版本依赖更新。npm 你只能先通过 <code>npm outdated</code> 看看那些包需要更新，然后通过 <code>npm update [packages]</code> 更新指定的包。而在 yarn 当中，可以通过交互式的方式，来选择那些需要更新，那些不需要。</li><li>全局模块的管理。npm 管理全局模块的方式是通过直接在 <code>/usr/lib/node_modules</code> 下面安装，然后通过软连接连接到 <code>/usr/local/bin</code> 目录下。而 yarn 的做法是选择一个目录，这个目录就是全局模块安装的地方，然后将所有的全局模块当做一个项目，从而进行管理。这个好处就是，你可以直接备份这个目录当中的 package.json 和 yarn.lock 文件，从而可以很方便的在另一个地方还原你安装了那些全局模块。至于这个目录的问题，通过 <code>yarn global dir</code> 命令就可以找到，mac 下是在 <code>~/.config/yarn/global/</code>，linux 我没有测试过。</li></ul><p>可以说 yarn 用起来非常舒服，但是唯一的缺点就是不是 npm 官方出的，更新力度、兼容性都会差一些。但这也阻挡不住 yarn 在 Node 社区的火热程度。很快，大家纷纷从 npm 切换到 yarn 上面。</p><h2 id="重拾-npm-5"><a href="#重拾-npm-5" class="headerlink" title="重拾 npm 5"></a>重拾 npm 5</h2><p>在受到 yarn 的冲击之后，npm 官方也决定改进这几个缺点，于是发布了和 Yarn 对抗(这个词是我意淫的)的 npm5 版本。</p><ol><li>引入了 package-lock.json，并且默认就会添加，和 yarn.lock 是一样的作用，并且取代之前的 npm shrinkwrap。</li><li>默认情况下，安装会自动添加 dependencies，不需要手动书写 <code>-S</code> 参数</li><li>提升了安装速度，和之前有了很大的进步，但是和 yarn 相比，还是略微慢一些</li></ol><p>至此，yarn 和 npm 的差距已经非常非常小了，更多的差距体现在用户体验层面，我使用 yarn 的功能也只剩下全局模块管理、模块交互式更新和 <code>yarn run</code> 这个命令了。</p><p>但是后面推出的 npx 让我放弃了使用 <code>yarn run</code> 这个命令。不是说 npx 比 yarn 有多好，而是说 npm 集成了这个功能，也就没必要再去使用第三方的工具了。而且 npx 还支持临时安装模块，也就是那种只用一次的命令，用完就删掉了。</p><p>后面我又发现了 <code>npm-check</code> 这个工具，我用它来替代了 yarn 的交互式更新。</p><p>然而 npm6 的出现加入了缓存，并且又进一步提升了速度，可以说直逼 yarn。</p><p>于是 yarn 对我来说只剩下一个全局模块管理的功能了。我的整个开发流程以及从 yarn 切换回 npm 上面了。或许后面的日子我也会让 npm 来接管全局模块管理，从而放弃使用 yarn。但是我还是会装 yarn，毕竟有一些老项目还是用 yarn 的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我经历了从 npm -&gt; cnpm -&gt; yarn -&gt; (npm + npm-check + npx) 的一个循环，也见证了 npm 社区的一步步发展。而且 yarn 的更新频率也非常慢，可能一个月才更新一次，这也让我逐渐放弃使用 yarn。</p><p>有的时候感觉，第三方的终究是第三方，还是没有原生的好用和方便，而且用起来安心。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;从接触到 node 环境来说，其中一个不可或缺的一部分便是 npm 包管理，但是由于官方的 npm 有各种各样的问题，于是催生了很多不同的版本，这其中的曲折也许只有过来人才知道。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;放弃-npm&quot;&gt;
      
    
    </summary>
    
      <category term="Node.js" scheme="https://blog.xgheaven.com/categories/Node-js/"/>
    
    
      <category term="npm" scheme="https://blog.xgheaven.com/tags/npm/"/>
    
      <category term="yarn" scheme="https://blog.xgheaven.com/tags/yarn/"/>
    
      <category term="node" scheme="https://blog.xgheaven.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>Nest.js 入手以及企业化的思考</title>
    <link href="https://blog.xgheaven.com/2018/04/16/nest-js-try-first/"/>
    <id>https://blog.xgheaven.com/2018/04/16/nest-js-try-first/</id>
    <published>2018-04-15T17:18:00.000Z</published>
    <updated>2023-09-16T15:48:05.163Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本人是一名 Node.js 实习生，在进入大搜车之后，有幸见识到 Akyuu.js 这个框架。但是这个框架是使用 Express + Callback 的方式，我不是很喜欢。在我的推荐以及社区的发展下，组长决定用 TS + Async/Await 来试一试。于是我也去了解了一下 TS 的后端框架有哪些，结果经过别人推荐，找到了 Nest.js 这个想法几乎和我一模一样的框架。</p></blockquote><h2 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h2><p>因为我这个不是教程向，所以就不细讲，可以查看 <a href="https://nestjs.com/" target="_blank" rel="noopener">Nest.js</a> 官网。从我的感性角度来讲，简单说一下以下几个特点：</p><ul><li>去中心化路由。所有的路由通过装饰器与 Controller 绑定。简单、明了，学习成本低。</li><li>TypeScript/Rx.js 加持。智能补全，代码分析，静态类型等等优点。如果你只是个人用用的话，可能会觉得很全。但是放在企业当中使用，是非常大的优点。</li><li>依赖注入。从 Angular 那里学习而来，但是进行了一些简化，但是完全够用。比如说简化掉了 deps。</li><li>模块思想。Node 社区的后端框架，其实都被 Express 导向到了中间件的模式。而 Nest.js 却从 Angular 当中吸取到了模块的思想。不同的 Service、Controller、Component 组成不同的模块。模块之间可以相互依赖，也可以独立存在，这大大减少了测试和逻辑的复杂度。</li><li>易于扩展。以往的框架，你能做的就是编写业务逻辑，而其他的你都很难去做到。于是传统的后端框架不得不引入了一套插件机制来增强框架的扩展性。但是 Nest.js 将插件的功能直接内置到了框架当中。传统的插件在这里可以认为就是一个模块，通过加载不同的模块来添加不同的功能。</li><li>Express 基石。有人会说，不是现在 Koa 才是更好的模型么？洋葱模型可以解决更多复杂的问题。没错，我不反对这个言论。但是我想说的是，Express 还是最简单最通用的方式，因为他不赖 Generator/Promise，只需要你又一个 Node.js 运行环境，支持 Callback 就可以了。（话说应该没有不支持 Callback 的 Node.js 环境吧，哈哈哈）不管怎么样，Express 的覆盖面还是比 Koa 要广不少。</li><li>条条大路通罗马。那么有人就问了，那我要实现洋葱模型怎么办呢？我想说，办法总是会有的。而在 Nest.js 当中，通过 Interceptor ，可以很好的实现洋葱模型。也就是说你可以通过 Interceptor 来记录请求的耗时。</li><li>同步代码。这里所说的同步代码并不是单单指的是 async/await。在很多支持 async/await 的框架中，如果你想返回值，如果是 Express ，你还是需要调用 <code>resp.send(await getValue())</code>，而 koa 也是需要调用 <code>ctx.body = await getValue()</code>。但是在 Nest.js 中，只需要 <code>return await getValue()</code> 即可。实现真正的同步编写业务逻辑代码。</li><li>逻辑分层。其实很多功能，都是可以通过中间件来实现的。但是不同类型的功能有不同的需求，如果只是通过中间件来实现，势必会导致有一些重复的代码。于是 Nest.js 里面引入了 Pipe/Interceptor/Guard/ExceptionFilter 等逻辑层。不同的层里面处理相似的事情，比如说 Pipe 处理的是输入数据的转换。而 Interceptor 来实现洋葱模型。Guard 用于权限校验等拦截任务。ExceptionFilter 用来处理错误数据。这种分层带来的好处就是可以让代码更加清晰，主需要思考这个层需要做的事情，而不需要站在中间件的层面去考虑这个事情。</li><li>Validation。自带校验，而且和 TS 结合的非常完美，使用起来很舒服，请看<a href="https://docs.nestjs.com/pipes" target="_blank" rel="noopener">教程</a></li><li>输入参数的转换。这个其实是一个很方便的方面。有的时候你需要将输入的参数转换成一个类，这个时候你就可以通过 Validation 进行转换。你要是不想用自动转换，可以通过传统的手动转换的方式。</li><li>测试功能完美。由于采用了依赖注入，所以测试简直简单的不得了。而且官方也提供了一系列测试工具，也能很好的解决单元测试的问题。</li></ul><h2 id="Nest-js-企业化当中的问题"><a href="#Nest-js-企业化当中的问题" class="headerlink" title="Nest.js 企业化当中的问题"></a>Nest.js 企业化当中的问题</h2><ul><li>目录无约束。在企业当中，不对目录进行约束会导致代码越来越乱。从而降低了代码可维护性。</li><li>没有配置管理功能。在框架开发中，配置往往是一个很重要的功能。比如说配置数据库的连接，配置监听的端口。</li><li>没有进程管理。虽然有提供 <code>@nestjs/cli</code>，但是这个提供的仅仅是一个项目的创建的能力。</li><li>部分文档讲解不详细，会提高入门的门槛。</li></ul><p>不过总的来说，前面几点也正是 Nest.js 灵活性的保证。但是我们真正在开发当中，还是需要一种合理的约束来保证开发的统一。</p><h2 id="Nest-js-企业化的尝试"><a href="#Nest-js-企业化的尝试" class="headerlink" title="Nest.js 企业化的尝试"></a>Nest.js 企业化的尝试</h2><p>那么我们这里针对上面的几个问题，尝试采用一些方式来进行约束。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>我们对项目指定如下的规则：</p><ul><li>全部通过 TypeScript 书写，并且全部位于 <code>src</code> 目录下</li><li>入口文件是 <code>main.ts</code> 如果没有特殊情况，不动这个文件</li><li>配置放在 <code>src/config</code> 文件夹下</li><li>所有的 Service/Controller/Logic/Component 等都挂载到 <code>MainModule</code> 下。</li><li>其中 <code>module</code> 文件夹存放自定义的 Module，或者说希望独立成模块但是还没有完全独立出来的。其中目录结构和这个项目目录结构类似</li><li><code>boot</code> 文件夹是项目启动代码的时候执行的，这部分在 Nest.js 当中没有给出。我这里打算添加这个功能，但是还没有想好具体的实现形式，所以待定。</li><li><code>interface</code>/<code>enum</code> 等数据随着对应的 service 导出。不另做说明。比如说 <code>car.service.ts</code> 除了可以导出 <code>CarService</code> 类以外，还可以导出 <code>CarType</code> enum。</li><li><code>dest</code> 文件夹是编译之后的文件，可以直接输入 <code>node dest/main.js</code> 运行。</li><li>命名规则<ul><li>所有的文件除了 main.ts 和类文件以外，都要添加类型后缀，比如说 <code>user.model.ts</code> <code>car.controller.ts</code> <code>google.logic.ts</code>。但是比如说只是一个 <code>Car</code> 类，那么可以直接命名成 <code>car.ts</code></li><li>不允许通过 <code>export default</code> 导出数据。一方面是为了方便导入的时候保证命名的统一，另一方面可以随时导出 interface/enum 等内容。</li><li>所有的测试文件后缀名都以 <code>.spec.ts</code> 或 <code>.test.ts</code> 结尾。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">|-- dest</span><br><span class="line">    |--- ...</span><br><span class="line">|-- src</span><br><span class="line">    |-- config</span><br><span class="line">    |-- controller</span><br><span class="line">    |-- model</span><br><span class="line">    |-- service</span><br><span class="line">    |-- logic</span><br><span class="line">    |-- component</span><br><span class="line">    |-- boot</span><br><span class="line">    |-- module</span><br><span class="line">        |-- module-name</span><br><span class="line">            |-- config</span><br><span class="line">            |-- index.ts</span><br><span class="line">            |-- module-name.module.ts</span><br><span class="line">    |-- main.ts</span><br><span class="line">    |-- main.module.ts</span><br></pre></td></tr></table></figure><h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p>我目前初步的想法是通过提供一个 <code>ConfigModule</code> 暴露出一个 <code>ConfigService</code> 来提供配置的获取和查看。</p><p>在某些情况下，可能需要多级配置，模块级别的配置，应用级别的配置。那么 <code>ConfigService</code> 可以在获取配置的时候自动合并这些规则。</p><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>现在已经是 18 年了，不用 Docker 你真的对得起自己么？很明显是对不起的。所以进程管理这一块，我们就交给 Docker 来处理。包括启动、停止、重启、日志等，都交给 Docker。</p><p>于是启动命令就可以简化成 <code>node dest/main.js</code> 即可。</p><p>那么你可能会想到，如果一个 Docker 环境给你分配了两个 u，那岂不是会浪费一个 u。理论上是的，那么你就可以通过 pm2 啊啥的自己去管理吧，哈哈哈，不管。</p><h2 id="Iron-js"><a href="#Iron-js" class="headerlink" title="Iron.js"></a>Iron.js</h2><p>说了这么多，把上面的内容都沉淀下来，我得要给他取个名字，于是我就取成了 Iron。为啥叫 Iron 呢？因为 Iron Man。那为啥因为 Iron Man 呢？因为他制作的盔甲可以自由拆分，自动拼合。非常适合我们这个项目的形态。</p><p>不过这个项目什么时候能沉淀下来，看我心情了。不过定个时间线吧，就在 4 月底，争取搞定。</p><p>因为这里面最大的问题就是配置的问题，需要深入依赖注入，所以会麻烦一些。但是其他的方面更多的只是一种约束吧。</p><p>这就是我用 Nest.js 一周以来的心得。暂时就想到这么多，更多的内容等我后面再分析吧。</p><p>写完睡觉，答应女票了，啦啦啦~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本人是一名 Node.js 实习生，在进入大搜车之后，有幸见识到 Akyuu.js 这个框架。但是这个框架是使用 Express + Callback 的方式，我不是很喜欢。在我的推荐以及社区的发展下，组长决定用 TS + Async/Await 
      
    
    </summary>
    
    
      <category term="Node.js" scheme="https://blog.xgheaven.com/tags/Node-js/"/>
    
      <category term="Nest.js" scheme="https://blog.xgheaven.com/tags/Nest-js/"/>
    
      <category term="Express" scheme="https://blog.xgheaven.com/tags/Express/"/>
    
      <category term="TypeScript" scheme="https://blog.xgheaven.com/tags/TypeScript/"/>
    
      <category term="Docker" scheme="https://blog.xgheaven.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>2018 年终总结</title>
    <link href="https://blog.xgheaven.com/2018/02/16/summary-2018/"/>
    <id>https://blog.xgheaven.com/2018/02/16/summary-2018/</id>
    <published>2018-02-15T16:04:44.000Z</published>
    <updated>2023-09-16T15:48:05.163Z</updated>
    
    <content type="html"><![CDATA[<p>2017 年，有开心，也有失落。也不知道该从何说起，就随便写写了。高中语文就没学好过，所以可能写成流水账了。请各位看官多多包涵。</p><h2 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h2><p>如今步入大四，最大的心事就是找实习找 Offer 了。先后经历了两次阿里面试的失利，至于失利的过程，我之前有吐槽过，就不多说了，而且听说今年的面试难度提升到了社招，心痛。饿了么/七牛都有投递过，但是都没有进。如果各位看官想招 Node.js 或者 前端 的校招生的话，请联系我哦~ <code>请在各大社交媒体请搜索 XGHeaven 即可</code></p><p>终于在 CNode 上面找到了一家美国 AR 公司，Integem。</p><p>在里面主要是用 Electron 做客户端，技术栈就是 Vue 全家桶，不多说了。反正整体干下来的感觉其实和自己接了一个外包的感觉差不多，而且设计师设计的页面参差不齐。最可气的是，假设页面 A 和页面 B 相同的部分，没准一个就有边框，另一个就没有。没准一个字体是 12px，另一个可能就是 16px。真是受不了，一开始，我还是让他确认一下到底哪个设计图是对的，到最后，只能用我的佛系心态对待这个设计图，懒得问了。切个图，也是切的乱七八糟，我还是自己来好了。</p><p>在里面差不多干了 5 个月，再加上学校要求每个人都要去跟着导师完成一个实践项目，于是我就离开了。</p><p>再之后，我在逛实习的时候，突然发现大搜车在招 Node.js 实习生，而且标注的是有大牛带。大搜车……为啥听着这么耳熟啊，不管了，报了再说。于是我就去面试了。面试我的是一个胖胖的留着胡子的人（死月罪过，当时并不知道那是你），于是和他相聊甚欢，最后还记得，当时看到他的 15寸 macbook pro 后面贴着一个 bad apple 的一个贴纸。当时顺口就问了一句，这个是 bad apple 么？当时之所以会问这个，因为我还记得很早以前，看过一个人的博客，里面讲到了他在花瓣网工作，而且很详细的讲解了图片主题色的提取和 Node.js NAN API，感觉受益匪浅，于是我当时在想，这是哪个学校的大牛，竟然这么厉害。后来看到他已经在花瓣工作了。。。不过我记得他很喜欢二次元。。。于是面试的时候，我在想会不会是他，于是就问了句贴纸，以为他会聊起二次元，结果他随便应了一句就过去了。我见状就没再继续问下去了。后面安慰道自己说，没事，那个人应该不会在大搜车。面试我这个人感觉还是很厉害的~~至少有一点，我说我提过 issue 给 node，他能马上就打开 github 看。这一点让我很敬佩，因为大部分面试都是会听你描述，看简历上面写的，而不是当场去查看。举个例子，你跟面试官说你博客写了很多高品质的文章，大部分面试官会直接问你有什么，他不会自己去看。而好的面试官会一边问你，一边自己打开看。。。我是这么觉得的。反正不管当时是不是月老，我已经决定来这家公司了。</p><p>哈哈哈，后面等进大搜车之后，剧情反转。那个人其实就是死月。当时看到他在 QQ 群里面的时候，你知道我的心里有多么开心么！！但是，有一个噩耗，就是他在我去的前几周已经跳槽去蚂蚁金服了，哭 (((T____T))) 我的大牛啊，你怎么走了啊~啊~啊~啊~</p><p>不过还好，也认识了挺多大牛的，不过还是没见到过我心仪的 朴灵/不四/狼叔 -_-。</p><p>现在在大搜车呆了有两个月了吧，那就简单总结一下干了啥吧：</p><ul><li>完成了一个图片上传服务，里面包含了公共的图片上传，以及大风车的头像上传，真正的编码时间也就两个星期，但是真的发布上去，却花了一个月。</li><li>现在准备一个请求限制框架，讲道理这是很简单的一个工作，但是我看时间很充裕，于是我就想写大，看看能不能独立成一个库，开源骗 star。</li><li>期间还要各种小东西，修修补补。</li></ul><p>刚进大搜车，按理来说，带我的人应该是小山，但是那个时候他请了几天假，于是就鹏飞暂时带着我。让我看了 Akyuu.js 和帕秋莉网关。之后其实所有的时间都是跟着鹏飞，我师父小山感觉不喜欢多说话，平时也没有太多的共同语言。想平时打打游戏联络一下感情，但是看他很忙的样子，就放弃了。最近才发现，原来小山也看二次元，哈哈哈。反正就这样，和小山半亲近半陌生。和鹏飞一开始也聊的挺多，后面等公司的事情知道的差不多了，也交流的不多了。</p><p>而且由于我比较慢热，再加上我进入公司比较晚，没有参加过团建，和大家都不是很熟。就和组内的坐在旁边的外加组内的实习生比较熟。</p><p>说一下，我在大搜车实习的感受吧。</p><ul><li>代码层面<ul><li>更加理性的对待 callback 和 promise，因为在之前，我是极力反对使用 callback 的，所以当第一眼看到公司的代码的时候，我懵逼了，怎么全是 callback。于是经过和鹏飞的交流以及自己的领悟，终于放下执念。其实 callback+async 和 promise 没啥区别么，哈哈哈。</li><li>尝试先写文档，后写代码。我平时兴起的时候，直接就开始撸，从来不打草稿。小项目可以，但是当项目大了之后，就呵呵哒了。</li><li>了解了 Node 的 PR 流程。</li><li>其他的好像还真的没有了，什么代码规范，git flow，框架的使用等等，我基本都了解。但是又重新复习了并精进了一下。毕竟之前看时候只是看了几眼，大体明白了内容。正好趁着这次实习，运用一下，看看自己理解的哪里有问题。</li></ul></li><li>交际层面<ul><li>首先我是一个慢热的，也就是说我不是很擅长去找别人交流，但是别人来找我交流，我是很乐意的。所以说，我当初进入公司之前的幻想，就是大家都在交流着各种新技术，新框架，新事物，当一个人抛出问题的时候，大家会一起去解决研究。结果进来之后，我发现，好像群里半天都不会有任何消息。于是我就努力去带动气氛，有什么好玩的东东都尝试发到群里，结果还是很难带起氛围。不知道是大家太忙了，还是我发的信息太简单。</li><li>还记得在学校的时候，社团的技术群，可能一个人发现了新东西，于是群里的大佬一起去尝试，评论，总结。和群里的人撕逼那个语言好，撕逼什么框架好用。我们只追求方便好用，并不怎么在乎稳定性这种东西。哎，这种感觉好难在找回来了。不知道头哥能不能看到我写的，我不知道头哥你想的团队是不是我想的那样，但是感觉大家仅仅为了业务而工作，死气沉沉，不觉得失去了乐趣么？</li><li>再讲讲开源的东东，我不知道用我们大学生的思维来思考对不对。至少我会很讨厌所有的公司沉淀出来的产品，比如说阿里的 egg。怎么解释呢？你可以理解假设公司内部的开发版本按照 master 的一条线进行，如果开源了，我就从 master checkout 一个新的分支，然后做一些开源的修改。我为什么不喜欢这种呢？因为这种所有的功能的设计实现就是严重依赖业务的，他只能做到的是在这个业务的情况下尽可能去兼容其他的业务格式而抽离出来的核心。而我真正想要的是什么呢？是社区驱动，一个产品可以由一个公司来开发，但是设计一定还给社区。而且我也不喜欢所谓的二次封装的框架，二次封装的框架我建议内部使用，而不是开源。除非你的二次封装能够提供很多功能。</li></ul></li><li>反正总的来讲，我感觉从知识层面，我获取的很少，没获取到太多新的概念/知识。但是实践层面我获取的还是挺多的。不知道这是不是以后工作的常态。</li></ul><h2 id="大学"><a href="#大学" class="headerlink" title="大学"></a>大学</h2><p>这一年其实大学生活没有太多的东西，主要是在实习当中度过的。</p><p>正是因为如此，我也越发怀念当初的学习生活。回头看看学弟当中的大佬，不由自主的感叹自己好像虚度了大学生活。</p><p>不顾了，下学期就准备毕业设计了，希望自己能珍惜最后的时光吧。</p><h2 id="2018-展望"><a href="#2018-展望" class="headerlink" title="2018 展望"></a>2018 展望</h2><p>看过了死月的总结，我发现其实有一点挺好的，一年给自己定一些目标，来年看看目标有没有实现。</p><p>那我也来展望一下好了：</p><ul><li>学习<ul><li>争取研读 Node 源码，至少要把死月那本书给啃完</li><li>争取 Github 每周都有贡献，希望能长久的维护一个项目</li><li>争取写一些有意思，有难度的代码，比如说《如何写出一个 Babel》</li><li>坚持写文章吧（这个有点难），至少保证每两周一篇高质量的</li><li>了解一些其他方面的内容，下一年总结一下了解了啥。</li></ul></li><li>坚持锻炼身体，把体重控制在 65 以下，争取练出胸肌（其实我有，只不过有点萎缩了）腹肌二头肌（当然，这些都练出来之后我就不限制体重了）。</li><li>争取学会做几个菜（当然指的是在实习期间了），暂时只考虑用电饭煲来做。</li><li>Minecraft 开新坑，等 1.13 发布~如果有小伙伴想入坑的请联系我，最好有正版，因为我是想单人开坑的。</li><li>不知道为啥，自从实习之后，感觉有点思春。。。特别想找人聊聊非技术方面的事情。。没妹子陪，我都不想去电影院看电影了。。。所以，不求找女票，感觉自己现在还不是很适合去当男票，其实是找不到合适的，哈哈哈。只求可以找到有空可以出去看个电影，聊个天，而且臭味相投的妹子就好了。不过目测是完不成这个目标了。</li><li>既然没有女票，那就多花一些时间在学习上。但是不要死学习，做程序员路上的书呆子。</li><li>恶习<ul><li>争取改掉拖沓的毛病，有任务赶紧去做，有事情提前安排</li><li>争取每天刷牙洗脸（也就是让自己早起，哈哈哈）</li></ul></li></ul><p>先这么多吧，看看 2019 年，我完成了哪些。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2017 年，有开心，也有失落。也不知道该从何说起，就随便写写了。高中语文就没学好过，所以可能写成流水账了。请各位看官多多包涵。&lt;/p&gt;
&lt;h2 id=&quot;实习&quot;&gt;&lt;a href=&quot;#实习&quot; class=&quot;headerlink&quot; title=&quot;实习&quot;&gt;&lt;/a&gt;实习&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="年终总结" scheme="https://blog.xgheaven.com/categories/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="年终总结" scheme="https://blog.xgheaven.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Reflect-Metadata 详解</title>
    <link href="https://blog.xgheaven.com/2017/12/30/Reflect-metadata/"/>
    <id>https://blog.xgheaven.com/2017/12/30/Reflect-metadata/</id>
    <published>2017-12-30T14:44:07.000Z</published>
    <updated>2023-09-16T15:48:05.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在 ES6 的规范当中，就已经存在 <code>Reflect</code> API 了。简单来说这个 API 的作用就是可以实现对变量操作的函数化，也就是反射。具体的关于这个 API 的内容，可以查看这个<a href="http://es6.ruanyifeng.com/#docs/reflect" target="_blank" rel="noopener">教程</a></p><p>然而我们在这里讲到的，却是 <code>Reflect</code> 里面还没有的一个规范，那么就是 <code>Reflect Metadata</code>。</p><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><p>想必对于其他语言的 Coder 来说，比如说 Java 或者 C#，Metadata 是很熟悉的。最简单的莫过于通过反射来获取类属性上面的批注（在 JS 当中，也就是所谓的装饰器）。从而可以更加优雅的对代码进行控制。</p><p>而 JS 现在有<a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="noopener">装饰器</a>，虽然现在还在 <code>Stage2</code> 阶段。但是 JS 的装饰器更多的是存在于对函数或者属性进行一些操作，比如修改他们的值，代理变量，自动绑定 this 等等功能。</p><blockquote><p>所以，后文当中我就使用 TypeScript 来进行讲解，因为 TypeScript 已经完整的实现了装饰器。<br>虽然 Babel 也可以，但是需要各种配置，人懒，不想配置那么多。</p></blockquote><p>但是却无法实现通过反射来获取究竟有哪些装饰器添加到这个类/方法上。</p><p>于是 <code>Reflect Metadata</code> 应运而生。</p><h2 id="Reflect-Metadata"><a href="#Reflect-Metadata" class="headerlink" title="Reflect Metadata"></a>Reflect Metadata</h2><p>Relfect Metadata，简单来说，你可以通过装饰器来给类添加一些自定义的信息。然后通过反射将这些信息提取出来。当然你也可以通过反射来添加这些信息。 就像是下面这个例子所示。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Reflect</span>.metadata(<span class="string">'name'</span>, <span class="string">'A'</span>)</span><br><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line">  <span class="meta">@Reflect</span>.metadata(<span class="string">'hello'</span>, <span class="string">'world'</span>)</span><br><span class="line">  <span class="keyword">public</span> hello(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reflect.getMetadata(<span class="string">'name'</span>, A) <span class="comment">// 'A'</span></span><br><span class="line">Reflect.getMetadata(<span class="string">'hello'</span>, <span class="keyword">new</span> A()) <span class="comment">// 'world'</span></span><br><span class="line"><span class="comment">// 这里为什么要用 new A()，用 A 不行么？后文会讲到</span></span><br></pre></td></tr></table></figure><p>是不是很简单，那么我简单来介绍一下~</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>首先，在这里有四个概念要区分一下：</p><ol><li><code>Metadata Key</code> {Any} 后文简写 <code>k</code>。元数据的 Key，对于一个对象来说，他可以有很多元数据，每一个元数据都对应有一个 Key。一个很简单的例子就是说，你可以在一个对象上面设置一个叫做 <code>&#39;name&#39;</code> 的 Key 用来设置他的名字，用一个 <code>&#39;created time&#39;</code> 的 Key 来表示他创建的时间。这个 Key 可以是任意类型。在后面会讲到内部本质就是一个 <code>Map</code> 对象。</li><li><code>Metadata Value</code> {Any} 后文简写 <code>v</code>。元数据的类型，任意类型都行。</li><li><code>Target</code> {Object} 后文简写 <code>o</code>。表示要在这个对象上面添加元数据</li><li><code>Property</code> {String|Symbol} 后文简写 <code>p</code>。用于设置在那个属性上面添加元数据。大家可能会想，这个是干什么用的，不是可以在对象上面添加元数据了么？其实不仅仅可以在对象上面添加元数据，甚至还可以在对象的属性上面添加元数据。其实大家可以这样理解，当你给一个对象定义元数据的时候，相当于你是默认指定了 <code>undefined</code> 作为 Property。 下面有一个例子大家可以看一下。</li></ol><p>大家明白了上面的概念之后，我之前给的那个例子就很简单了~不用我多说了。</p><h3 id="安装-使用"><a href="#安装-使用" class="headerlink" title="安装/使用"></a>安装/使用</h3><p>下面不如正题，我们怎么开始使用 <code>Reflect Metadata</code> 呢？<br>首先，你需要安装 <code>reflect-metadata</code> polyfill，然后引入之后就可以看到在 <code>Reflect</code> 对象下面有很多关于 Metadata 的函数了。因为这个还没有进入正式的协议，所以需要安装垫片使用。</p><blockquote><p>啥，Reflect 是啥，一个全局变量而已。</p></blockquote><p>你不需要担心这个垫片的质量，因为连 Angular 都在使用呢，你怕啥。</p><p>之后你就可以安装我上面写的示例，在 TypeScript 当中去跑了。</p><h3 id="类-属性-方法-装饰器"><a href="#类-属性-方法-装饰器" class="headerlink" title="类/属性/方法 装饰器"></a>类/属性/方法 装饰器</h3><p>看这个例子。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Reflect</span>.metadata(<span class="string">'name'</span>, <span class="string">'A'</span>)</span><br><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line">  <span class="meta">@Reflect</span>.metadata(<span class="string">'name'</span>, <span class="string">'hello'</span>)</span><br><span class="line">  hello() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objs = [A, <span class="keyword">new</span> A, A.prototype]</span><br><span class="line"><span class="keyword">const</span> res = objs.map(<span class="function"><span class="params">obj</span> =&gt;</span> [</span><br><span class="line">  Reflect.getMetadata(<span class="string">'name'</span>, obj),</span><br><span class="line">  Reflect.getMetadata(<span class="string">'name'</span>, obj, <span class="string">'hello'</span>),</span><br><span class="line">  Reflect.getOwnMetadata(<span class="string">'name'</span>, obj),</span><br><span class="line">  Reflect.getOwnMetadata(<span class="string">'name'</span>, obj ,<span class="string">'hello'</span>)</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 大家猜测一下 res 的值会是多少？</span></span><br></pre></td></tr></table></figure><blockquote><p>想好了么？再给你 10 秒钟</p></blockquote><blockquote><p>10<br>9<br>8<br>7<br>6<br>5<br>4<br>3<br>2<br>1</p></blockquote><p>res</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="string">'A'</span>, <span class="literal">undefined</span>, <span class="string">'A'</span>, <span class="literal">undefined</span>],</span><br><span class="line">  [<span class="literal">undefined</span>, <span class="string">'hello'</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>],</span><br><span class="line">  [<span class="literal">undefined</span>, <span class="string">'hello'</span>, <span class="literal">undefined</span>, <span class="string">'hello'</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>那么我来解释一下为什么回是这样的结果。</p><p>首先所有的对类的修饰，都是定义在类这个对象上面的，而所有的对类的属性或者方法的修饰，都是定义在类的原型上面的，并且以属性或者方法的 key 作为 property，这也就是为什么 <code>getMetadata</code> 会产生这样的效果了。</p><p>那么带 <code>Own</code> 的又是什么情况呢？</p><p>这就要从元数据的查找规则开始讲起了</p><h3 id="原型链查找"><a href="#原型链查找" class="headerlink" title="原型链查找"></a>原型链查找</h3><p>类似于类的继承，查找元数据的方式也是通过原型链进行的。</p><p>就像是上面那个例子，我实例化了一个 <code>new A()</code>，但是我依旧可以找到他原型链上的元数据。</p><p>举个例子</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line">  <span class="meta">@Reflect</span>.metadata(<span class="string">'name'</span>, <span class="string">'hello'</span>)</span><br><span class="line">  hello() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t1 = <span class="keyword">new</span> A()</span><br><span class="line"><span class="keyword">const</span> t2 = <span class="keyword">new</span> A()</span><br><span class="line">Reflect.defineMetadata(<span class="string">'otherName'</span>, <span class="string">'world'</span>, t2, <span class="string">'hello'</span>)</span><br><span class="line">Reflect.getMetadata(<span class="string">'name'</span>, t1, <span class="string">'hello'</span>) <span class="comment">// 'hello'</span></span><br><span class="line">Reflect.getMetadata(<span class="string">'name'</span>, t2, <span class="string">'hello'</span>) <span class="comment">// 'hello'</span></span><br><span class="line">Reflect.getMetadata(<span class="string">'otherName'</span>, t2, <span class="string">'hello'</span>) <span class="comment">// 'world'</span></span><br><span class="line"></span><br><span class="line">Reflect.getOwnMetadata(<span class="string">'name'</span>, t2, <span class="string">'hello'</span>) <span class="comment">// undefined</span></span><br><span class="line">Reflect.getOwnMetadata(<span class="string">'otherName'</span>, t2, <span class="string">'hello'</span>) <span class="comment">// 'world'</span></span><br></pre></td></tr></table></figure><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>其实所有的用途都是一个目的，给对象添加额外的信息，但是不影响对象的结构。这一点很重要，当你给对象添加了一个原信息的时候，对象是不会有任何的变化的，不会多 property，也不会有的 property 被修改了。<br>但是可以衍生出很多其他的用途。</p><ul><li>Anuglar 中对特殊字段进行修饰 (Input)，从而提升代码的可读性。</li><li>可以让装饰器拥有真正装饰对象而不改变对象的能力。让对象拥有更多语义上的功能。</li></ul><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Reflect &#123;</span><br><span class="line">  <span class="comment">// 用于装饰器</span></span><br><span class="line">  metadata(k, v): <span class="function">(<span class="params">target, property?</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 在对象上面定义元数据</span></span><br><span class="line">  defineMetadata(k, v, o, p?): <span class="built_in">void</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 是否存在元数据</span></span><br><span class="line">  hasMetadata(k, o, p?): <span class="built_in">boolean</span></span><br><span class="line">  hasOwnMetadata(k, o, p?): <span class="built_in">boolean</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取元数据</span></span><br><span class="line">  getMetadata(k, o, p?): <span class="built_in">any</span></span><br><span class="line">  getOwnMetadata(k, o, p?): <span class="built_in">any</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取所有元数据的 Key</span></span><br><span class="line">  getMetadataKeys(o, p?): <span class="built_in">any</span>[]</span><br><span class="line">  getOwnMetadataKeys(o, p?): <span class="built_in">any</span>[]</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 删除元数据</span></span><br><span class="line">  deleteMetadata(k, o, p?): <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>大家可能注意到，针对某些操作，会有 <code>Own</code> 的函数。这是因为有的操作是可以通过原型链进行操作的。这个后文讲解。</p></blockquote><h2 id="深入-Reflect-Metadata"><a href="#深入-Reflect-Metadata" class="headerlink" title="深入 Reflect Metadata"></a>深入 Reflect Metadata</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>如果你去翻看官网的文档，他会和你说，所有的元数据都是存在于对象下面的 <code>[[Metadata]]</code> 属性下面。一开始我也是这样认为的，新建一个 <code>Symbol(&#39;Metadata&#39;)</code>，然后将元数据放到这个 Symbol 对应的 Property 当中。直到我看了源码才发现并不是这样。请看例子</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Reflect</span>.metadata(<span class="string">'name'</span>, <span class="string">'A'</span>)</span><br><span class="line"><span class="keyword">class</span> A &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(A) <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>哈哈，并没有所谓的 Symbol，那么这些元数据都存在在哪里呢？</p><p>其实是内部的一个 WeakMap 中。他正是利用了 WeakMap 不增加引用计数的特点，将对象作为 Key，元数据集合作为 Value，存到 WeakMap 中去。</p><p>如果你认真探寻的话，你会发现其内部的数据结构其实是这样的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakMap&lt;<span class="built_in">any</span>, Map&lt;<span class="built_in">any</span>, Map&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>是不是超级绕，但是我们从调用的角度来思考，这就一点都不绕了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weakMap.get(o).get(p).get(k)</span><br></pre></td></tr></table></figure><p>先根据对象获取，然后在根据属性，最后根据元数据的 Key 获取最终要的数据。</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>因为 Reflect Metadata 实在是比较简单，这里就不多讲解了。更多内容请查看 <a href="https://rbuckton.github.io/reflect-metadata" target="_blank" rel="noopener">Spec</a></p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>其实看了源码之后还是挺惊讶的，按照一般的套路，很多 polyfill 会让你提供一些前置的 polyfill 之后，当前的 polyfill 才能使用。但是 <code>reflect-metadata</code> 竟然内部自己实现了很多的 polyfill 和算法。比如 Map, Set, WeakMap, UUID。最惊讶的莫过于 WeakMap 了。不是很仔细的阅读了一下，好像还是会增加引用计数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在 ES6 的规范当中，就已经存在 &lt;code&gt;Reflect&lt;/code&gt; API 了。简单来说这个 API 的作用就是可以实现对变量操作
      
    
    </summary>
    
      <category term="Jacascript" scheme="https://blog.xgheaven.com/categories/Jacascript/"/>
    
    
      <category term="Javascript" scheme="https://blog.xgheaven.com/tags/Javascript/"/>
    
      <category term="Reflect Metadata" scheme="https://blog.xgheaven.com/tags/Reflect-Metadata/"/>
    
  </entry>
  
  <entry>
    <title>Boostnote 一个专门为程序员设计的笔记应用</title>
    <link href="https://blog.xgheaven.com/2017/09/09/boostnote-is-an-open-source-note-taking-app-designed-for-programmers/"/>
    <id>https://blog.xgheaven.com/2017/09/09/boostnote-is-an-open-source-note-taking-app-designed-for-programmers/</id>
    <published>2017-09-09T14:40:27.000Z</published>
    <updated>2023-09-16T15:51:09.747Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Boostnote 是一款通过 Electron 构建的桌面笔记应用。它支持离线存储，无需注册、Markdown 编辑、像 Github Gist 的代码片段的管理等等内容。全球 198 个国家和地区的程序员们在使用这款应用。</p></blockquote><p><a href="https://boostnote.io/" target="_blank" rel="noopener">Boostnote</a> 就如同器名字一般，最主要的一个用途便是 Markdown 笔记编辑器。你所有的 Markdown 笔记拥有自动保存的功能，并且支持多种展示格式。拥有半实时的预览，所以你可以及时的检查最后的格式是否是和你所输入的一致。</p><p>Latex 公式编辑器也内置在 Boostnote 当中，你可以很轻松的插入各种公式在你的笔记中。</p><p>不管是笔记还是代码片段都可以通过标签的方式进行管理。</p><p>对于代码片段来说，他支持高达 100 多种语言的高亮，其中包括 JavaScript, Python, HTML 和 CSS。当然你也可以在一份代码片段当中存储多段代码，比如说你可以同时存储 HTML，CSS，JS 代码在一份当中。而且不管你是用什么样子的缩进（tab/空格）或者缩进的程度（2个字符，4个字符，8个字符）都可以在文档中进行配置。</p><p>最后，将笔记导出成普通文本（.txt） 或者 Markdown(.md) 也是支持的功能。</p><h2 id="外观（UI）"><a href="#外观（UI）" class="headerlink" title="外观（UI）"></a>外观（UI）</h2><p>丰富的快捷键可以让你让更快的浏览、搜索笔记，以及更快的执行一些重要操作。</p><p>对于 Boostnote 的外观来说，你有很多种不同的主题可以选择。当然，编辑器的高亮也是有很多种可以选择的，你可以根据你自己的喜好自由搭配。你可以在 <code>Preferences</code> &gt; <code>UI</code> &gt; <code>Theme</code> 查看支持的主题。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>Boostnote 目前是开源的，你可以通过<a href="https://boostnote.io/#download" target="_blank" rel="noopener">官网</a>下载。不过要注意的是，存储使用的是亚马逊的 s3，所以你需要能够翻墙，否则无法下载。</p><p>它目前是支持全平台（Windows, MacOS, Linux，IOS，Android）</p>]]></content>
    
    <summary type="html">
    
      
      
        
&lt;blockquote&gt;
&lt;p&gt;Boostnote 是一款通过 Electron 构建的桌面笔记应用。它支持离线存储，无需注册、Markdown 编辑、像 Github Gist 的代码片段的管理等等内容。全球 198 个国家和地区的程序员们在使用这款应用。&lt;/p&gt;
&lt;/blo
      
    
    </summary>
    
      <category term="Software" scheme="https://blog.xgheaven.com/categories/Software/"/>
    
    
      <category term="Boostnote" scheme="https://blog.xgheaven.com/tags/Boostnote/"/>
    
      <category term="Markdown" scheme="https://blog.xgheaven.com/tags/Markdown/"/>
    
      <category term="Programer" scheme="https://blog.xgheaven.com/tags/Programer/"/>
    
  </entry>
  
  <entry>
    <title>Vue-Lever 一个使用装饰器模式的插件帮你管理 True/false 状态</title>
    <link href="https://blog.xgheaven.com/2017/08/17/vue-lever-a-plugin-help-you-to-manager-true-false-state/"/>
    <id>https://blog.xgheaven.com/2017/08/17/vue-lever-a-plugin-help-you-to-manager-true-false-state/</id>
    <published>2017-08-17T03:01:14.000Z</published>
    <updated>2023-09-16T15:48:05.162Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>vue-lever 是一个使用装饰器模式的插件来帮你管理 true/false 状态</p></blockquote><p>最近一直在写 vue 相关的东西，因为毕竟是前端，所以经常会遇到一种情况就是说，我需要维护一个 true/false 状态，比如说：当按钮点击的时候，显示加载字样，然后等加载完毕之后完成显示。</p><p>首先我们考虑出现这种情况的时候，如果我们一行一行的书写，那将是非常麻烦的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">loading</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        asyncAction() &#123;</span><br><span class="line">            <span class="keyword">this</span>.loading = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">this</span>.$http.doing() <span class="comment">// return a promise</span></span><br><span class="line">                .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.loading = <span class="literal">false</span>)</span><br><span class="line">                .catch(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.loading = <span class="literal">false</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们需要在每一个退出的情况下将 loading 状态设置为 false，这至少意味着你要写 3 遍，非常冗余。而且很容易忘记。</p><p>我们可以抽象出来，可以发现每当这种函数运行的时候，首先将相关的变量设置成 true，然后等待异步操作完成或者失败之后，再将变量设置回之前的值。</p><p>完成这个操作最简单的方式就是代理，在用户的函数调用之前设置相应的变量，在用户的函数调用完成之后，或者如果函数是异步操作，那么通过返回一个 promise 来表示异步操作。</p><p>既然讲到了代理模式，那么在 JS 中有很多，不过我们在这里通过一个 ES6 的新语法，装饰器。</p><p>话不多说，上代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Lever <span class="keyword">from</span> <span class="string">'vue-lever'</span></span><br><span class="line"><span class="comment">// import others</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        @Lever.Lever(<span class="string">'loading'</span>)</span><br><span class="line">        asyncAction() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.$http.doing() <span class="comment">// return a promise</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个功能和上面的那段代码是一模一样的，是不是感觉用了装饰器之后就变得特别简单了呢？</p><p>不过这里有一点需要注意的是，为了方便和隔离，我将所有的变量全都放在 <code>levers</code> 这个变量下面，也就是说你需要通过 <code>levers.loading</code> 来使用，而不是 <code>loading</code></p><p>不过现在暂时没有支持回调函数的方式，也就是你必须要返回一个 promise，否则是不行的。</p><p>其次我们这里还有手动模式，也就是如果你不想用装饰器的话，你可以通过 <code>this.$lever(name, value)</code>，来更改状态，其中 <code>name</code> 为变量名，<code>value</code> 为 true/false 值。当然这里也提供两个 alias，<code>this.$lever.t(name)</code> 和 <code>this.$lever.f(name)</code>。方便设置变量为 true/false。</p><p>还有一些其他的参数，大家可以去 <a href="https://github.com/XGHeaven/vue-lever" target="_blank" rel="noopener">Github</a> 网站查看。这篇文章就写到这里。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;vue-lever 是一个使用装饰器模式的插件来帮你管理 true/false 状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近一直在写 vue 相关的东西，因为毕竟是前端，所以经常会遇到一种情况就是说，我需要维护一个 true/false 状
      
    
    </summary>
    
      <category term="Vue.js" scheme="https://blog.xgheaven.com/categories/Vue-js/"/>
    
    
      <category term="Frontend" scheme="https://blog.xgheaven.com/tags/Frontend/"/>
    
      <category term="Vue" scheme="https://blog.xgheaven.com/tags/Vue/"/>
    
      <category term="vue-lever" scheme="https://blog.xgheaven.com/tags/vue-lever/"/>
    
  </entry>
  
  <entry>
    <title>A New V8 Is Coming node.js Performance Is Changeing</title>
    <link href="https://blog.xgheaven.com/2017/08/12/a-new-v8-is-coming-node-js-performance-is-changeing/"/>
    <id>https://blog.xgheaven.com/2017/08/12/a-new-v8-is-coming-node-js-performance-is-changeing/</id>
    <published>2017-08-12T07:07:22.000Z</published>
    <updated>2023-09-16T15:48:05.162Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
