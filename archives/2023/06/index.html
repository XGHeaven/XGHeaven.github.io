
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="XGHeaven&#39;s Blog">
    <title>归档: 2023/6 - XGHeaven&#39;s Blog</title>
    <meta name="author" content="XGHeaven">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta property="og:type" content="blog">
<meta property="og:title" content="XGHeaven&#39;s Blog">
<meta property="og:url" content="https://blog.xgheaven.com/archives/2023/06/index.html">
<meta property="og:site_name" content="XGHeaven&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="XGHeaven">
<meta name="twitter:card" content="summary">
<meta name="twitter:creator" content="@XGHeaven">
    
    
        
    
    
        <meta property="og:image" content="https://www.gravatar.com/avatar/f34474afe04544ffbe944a804f0ae762?s=640"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-mhhgzztqkaub4zd4cl8bd83f7mgh9j6njnhilft4hamhrjsliqyzwo2cfzdk.min.css">

    <!--STYLES END-->
    
    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-71388235-1']);
        _gaq.push(['_trackPageview']);
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>

    
    <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?9894361f828b64144ac1f2ac0c58c300";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/%20">XGHeaven&#39;s Blog</a>
    </h1>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="https://www.gravatar.com/avatar/f34474afe04544ffbe944a804f0ae762?s=90"/>
        
        </a>
    
</header>
            <!-- Define author's picture -->


    

<nav id="sidebar" data-behavior="1">
    
        <div class="sidebar-profile">
            <a href="/#about">
                    <img class="sidebar-profile-picture" src="https://www.gravatar.com/avatar/f34474afe04544ffbe944a804f0ae762?s=110"/>
            </a>
            <span class="sidebar-profile-name">XGHeaven</span>
        </div>
    
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/%20"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                    <span class="sidebar-button-desc">首页</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-categories"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                    <span class="sidebar-button-desc">分类</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-tags"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                    <span class="sidebar-button-desc">标签</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-archives"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                    <span class="sidebar-button-desc">归档</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="#about"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                    <span class="sidebar-button-desc">关于</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/friend-link"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-link"></i>
                    <span class="sidebar-button-desc">友情链接</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://github.com/XGHeaven" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                    <span class="sidebar-button-desc">GitHub</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://twitter.com/xgheaven" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-twitter"></i>
                    <span class="sidebar-button-desc">Twitter</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://facebook.com/xgheaven" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-facebook"></i>
                    <span class="sidebar-button-desc">Facebook</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://www.linkedin.com/xgheaven/" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-linkedin"></i>
                    <span class="sidebar-button-desc">LinkedIn</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="mailto:xgheaven@gmail.com" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                    <span class="sidebar-button-desc">邮箱</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/atom.xml"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                    <span class="sidebar-button-desc">RSS</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/changelog"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-line-chart"></i>
                    <span class="sidebar-button-desc">Changelog</span>
                </a>
        </li>
        
    </ul>
    
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    

<section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2023/06/14/use-dom-to-improve-double-performance-in-mini-program/">
                            返璞归真「DOM」兼容接口的引入让飞书小程序性能获得 2 倍以上的提升
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" content="Wed Jun 14 2023 00:00:00 GMT+0800">
	
		    6月 14, 2023
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">小程序</a>


    
</div>
            </div>
            
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>小程序，作为新一代的应用开发方式，虽然在业务上已经证明了巨大的价值，但是在开发者友好性上却非常的差，例如框架难用，调试困难，跨平台兼容性差。本文便是在尝试提高针对视图的开发者友好性和兼容性，同时进一步提升性能。</p>
<p>为了能够更好的理解本文，需要您最好了解以下内容：</p>
<ul>
<li><p>有小程序相关的经验，能够理解基本小程序的架构、基本的框架使用方式、主流的跨端三方框架等</p>
</li>
<li><p>有前端相关的经验，能够理解什么是 DOM 接口，以及如何操作 DOM 接口</p>
</li>
</ul>
<p>本文将不再赘述过多的基础概念内容。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>目前本人任职飞书开放平台小程序组，负责小程序相关的运行时的工作内容。由于飞书对小程序有着一些特殊的需求：</p>
<ol>
<li><p>飞书大量官方应用都是通过小程序承载的，这些应用对运行体验和开发效率有着远比外界更高的要求。而且由于是官方应用，且只服务于飞书，所以他们对于小程序的跨端兼容性要求并不高。这也给了我们更大的灵活性去设计更好的方案。</p>
</li>
<li><p>飞书是一个面向全球 B 端的市场，先不论国内是否每个 B 端企业都能有精力去开发小程序，单论海外市场对小程序的认知就非常浅薄。所以如何尽可能的降低小程序的认知学习门槛，降低接入成本，就显得尤为重要。在国内可以通过类似于 Taro 的框架，但是海外这部分的学习成本依旧很高，所以需要有新的方式去降低这部分的成本。</p>
</li>
</ol>
<p>正是因为如此，我们这边决定不再以兼容社区小程序的方案为首要目标，而是转为提高开发者的开发体验和运行性能为主目标去进行设计和优化。</p>
<h1 id="现有架构的「病区」"><a href="#现有架构的「病区」" class="headerlink" title="现有架构的「病区」"></a>现有架构的「病区」</h1><p>小程序在诞生之后，其实做了很多的设定，有的设定是合适的，但更多的设定在逐渐的发展过程中变得不再合适，而后人却依旧沿着这个思路和方向去做。接下来，让我们重新思考一下这些设定：</p>
<h2 id="为什么会诞生-XXML-的视图开发方案？"><a href="#为什么会诞生-XXML-的视图开发方案？" class="headerlink" title="为什么会诞生 XXML 的视图开发方案？"></a>为什么会诞生 XXML 的视图开发方案？</h2><blockquote>
<p><code>XXML</code> 在这里是对通过模板开发小程序的一种开发范式（也可以叫开发框架或者 DSL）的统称。因为不同宿主内对应的模板文件的后缀不同，但都有 <code>ML</code> 而因此得名。例如微信是 <code>.wxml</code> ，支付宝是 <code>.axml</code>，而飞书和抖音则为 <code>.ttml</code>。</p>
</blockquote>
<p>在我的认知中，小程序最开始并不是为资深的前端开发而设计的，相反，他是为了客户端乃至一些没有开发经验的人所设计。</p>
<p>所以借鉴了 Vue 这类非常容易入门的社区框架，再结合上小程序自身的需求所定制了一套 DSL。这套 DSL 针对从来没有写过前端的人来说，确实算是非常友好的，几乎不需要学习就可以上手。</p>
<p>其实让开发者更容易的入门上手算是小程序最开始的目标。例如，一开始是不提供 CLI 工具只提供了可视化的 IDE。如果小程序的受众是不懂开发的人，那其实没问题。</p>
<p>但最终事与愿违，开发小程序最多的人其实就是资深的前端开发，在前端开发的视角来看，这套 DSL 可以用一坨屎来形容。而小程序又必须要要用这套 DSL 去开发，就导致每一个写过小程序的人必须吃一次这个屎。</p>
<h2 id="XXML-会带来什么问题？"><a href="#XXML-会带来什么问题？" class="headerlink" title="XXML 会带来什么问题？"></a>XXML 会带来什么问题？</h2><p>虽然以微信为首的厂商做了很多能力去补救，尽可能在保证较低入手门槛的情况下，不断丰富能力，提高对前端开发人员的友好程度。但最开始的设计就不是面向这部分人群，即使后面修补的再多也无济于事了。这其中所带来的的问题随着小程序的发展而愈发严重：</p>
<ul>
<li><p>由于这套框架的实现是内置在基础库内，其能力和功能的实现必然有滞后性，同时灵活度差。一旦框架概念落后，开发者将不得不继续咬牙学习落后内容。</p>
</li>
<li><p>虽然最开始借鉴自 JS 和 Web，但最终却无法的很好的利用开源社区的能力，几乎所有都要重造轮子。国内已经发展了这么多年，社区才将将都造完稳定的轮子，如果将这一套推向海外，那成本根本无法估量。</p>
</li>
<li><p>规范缺乏一致性。由于 XXML 本身其实是一个业务开发框架，但又作为唯一开发方式，非常容易变得越来越臃肿和随意，可能一个实习生随便定出的接口都将会影响整个社区，能力的实现也缺乏一致性。例如 <code>Page</code> 和 <code>Component</code> 的生命周期就非常不一样。</p>
</li>
<li><p>为了解决 XXML 这些问题，降低开发者的开发成本，在社区中诞生了许许多多的三方跨端框架。导致开发小程序的人不仅仅要懂得如何写原生的 XXML，更要懂得如何使用这些跨端框架，学习成本陡增。</p>
</li>
<li><p>Taro 这类模拟一套 DOM 接口来嫁接社区框架的做法，最终会让运行架构变成 <code>React =&gt; Taro DOM =&gt; TTML =&gt; DOM</code> 这种有点脱裤子放屁的方式。</p>
</li>
</ul>
<h2 id="小程序的视图开发一定要使用-XXML-么？"><a href="#小程序的视图开发一定要使用-XXML-么？" class="headerlink" title="小程序的视图开发一定要使用 XXML 么？"></a>小程序的视图开发一定要使用 XXML 么？</h2><p>一个支持通用应用的宿主，可以提供一套它认为合适的模板 DSL 去生成渲染树，但一定也需要提供一套更加灵活的方式去生成渲染树。例如：</p>
<ul>
<li><p>安卓默认使用 XML 作为模板，去渲染内容。但如果不满足使用，同时可以使用命令的操作方式去构建一个渲染树。iOS 也是用类似的逻辑</p>
</li>
<li><p>Flutter 定义了一套类似于 React 的 Weight 渲染框架。但依旧暴露了底层的 RenderObject 方便开发者绕过 Weight 直接去构建渲染树。</p>
</li>
</ul>
<p>而小程序，却选择了只提供 XXML，并没有提供其他的方式。如果小程序面向的特定需求场景，这倒也无可厚非，可实际上小程序面向的却是通用需求场景。</p>
<p>于是飞书内部在思考，如果我们一定要再提供一套通用的 DSL，会是什么？React、Vue 这类前端框架么？如果提供了，又会面临和 XXML 类似的局面。</p>
<p>其实在 Web 领域中，早就给出了答案，那么就是 DOM。不管是 React 还是 Vue 还是其他的框架，底层都是基于 DOM 接口所存在的。如果我们能够在小程序提供一套底层的 DOM 接口，那么 XXML 所带来的问题是不是就全都迎刃而解了呢？</p>
<h2 id="为什么之前不提供-DOM-接口？"><a href="#为什么之前不提供-DOM-接口？" class="headerlink" title="为什么之前不提供 DOM 接口？"></a>为什么之前不提供 DOM 接口？</h2><p>当我们想明白这个点之后，其实就会更加好奇，为什么这么简单的想法为啥一开始乃至后续的人都没做过呢？</p>
<p>我猜测最开始不这么做的原因有这么几个，但我觉得都不是很成立，或者说在飞书的场景中很难成立（如果大家有不同的想法和意见，随时可以和我沟通交流）。</p>
<blockquote>
<p>Q: 无法完整实现，成本高。<br>双线程无法实现完整的 DOM 接口，且在逻辑层实现一套 DOM 接口的成本过高。</p>
</blockquote>
<p>确实，如果想要一比一的复刻 DOM 接口，有些依赖渲染能力的接口确实无法实现。但如果只是实现一套子集，能够满足主流框架的使用，那么成本和难度并不高。比如 Taro 就是这么做的，社区也证明了其可行性。</p>
<blockquote>
<p>Q: 首屏性能差。<br>如果实现 DOM 接口，就必须要等待逻辑层完整渲染并操作完 DOM 接口之后，渲染层才能渲染，那么将失去双线程逻辑层和渲染层并行运行的优势。</p>
</blockquote>
<p>我觉得这个是一个屁股决定脑袋的事情。在 90% 的场景中，渲染层就是需要等待逻辑层计算完毕之后才能渲染的。就像是你不能说为了前端页面首屏速度快，要求所有网站都用 SSR 吧。</p>
<p>另外，首屏其实分为 FP 和 TTI 的，和 SSR 场景类似，XXML 可以做到 FP 快，但是 TTI 并不如 DOM 快的。飞书场景更在乎的是 TTI 而非 FP，所以影响不大。</p>
<p>再说，用了 DOM 接口之后自然是有对应的优化策略和方式的。</p>
<blockquote>
<p>Q: DOM 指令的通讯压力大。<br>如果采用 DOM 接口，那么逻辑层往渲染层发送的将是 DOM 指令，如果我要渲染 100 个普通的 view，这部分体积明显比直接发送 data 要大。</p>
</blockquote>
<p>没错，某些场景下，DOM 指令的数量确实是会比 data 体积大。</p>
<p>但是在飞书的业务场景中，通常都会有着重度的逻辑以及大量国际化文案，这部分会导致 data 的体积飞涨。而且并不是所有的开发都有合理使用 data 的能力的，有些人就喜欢啥都往 data 里面塞，这更加会加剧其体积的膨胀。</p>
<p>所以对于飞书来说，这个的影响其实并不大。</p>
<blockquote>
<p>Q: 觉得 TTML 就够用了</p>
</blockquote>
<p>懂的都懂，不多说了</p>
<blockquote>
<p>Q: 不希望对外认知上小程序就是前端，所以在一定程度上屏蔽了前端所用的东西。</p>
</blockquote>
<p>我觉得这其实是微信小程序的烟雾弹，让大家觉得小程序技术很厉害，它底层是 Native 实现，只是借鉴了前端的一些概念而已。</p>
<p>但实际上缺恰恰相反，从设计开始，就是在 Web 上面打补丁实现的，只是借鉴了一点点 Native 中的概念。</p>
<p>所以如果相信了这个烟雾弹，那么才是将自己埋入深坑。</p>
<blockquote>
<p>Q: 不希望利用 DOM 接口实现太多灵活的动态更新能力。<br>例如审核之后通过 API 更改 UI 界面。</p>
</blockquote>
<p>这个也是我见过最多的说法了，也是最站不住脚的说法。<br>XXML 本身就无法避免动态更新，更别说 DOM 了。</p>
<blockquote>
<p>Q: DOM 接口就不会有实现上的兼容问题了么？</p>
</blockquote>
<p>这是个好问题，虽然 DOM 接口本身是有标准的，但实现上其实各家都会遇见的不一样。</p>
<p>这个自然没有完美的解决方案，但是我觉得以兼容主流框架而不是提供完整兼容的 DOM 接口为目标是更加合理的。不管各家接口实现成什么样子，只要能兼容前端框架就是对的。</p>
<p>至此，其实我们可以看到，DOM 接口本身的引入并不存在什么实质性的阻碍。</p>
<p>而且最重要的事，DOM 本身是作为 XXML 的一种补充开发能力所引入的，每个开发者可以根据自己的架构特点选择 XXML 甚至的 DOM 来作为开发方式。</p>
<h2 id="提供-DOM-接口能带来哪些好处？"><a href="#提供-DOM-接口能带来哪些好处？" class="headerlink" title="提供 DOM 接口能带来哪些好处？"></a>提供 DOM 接口能带来哪些好处？</h2><p>最后的最后，我们其实要明白，如果要提供 DOM 接口，将会带来那些好处呢？</p>
<ul>
<li><p>能够几乎无缝的兼容市面上主流的前端框架，目前测试下来支持的有 <code>Vue</code> <code>Svelte</code> <code>React18</code>。极大的降低开发者的学习和开发成本。</p>
</li>
<li><p>可以提供极致的性能优化，做到非常细粒度的组件更新。</p>
</li>
<li><p>和前端主流开发方式对齐，不再分割与割裂，提高开发效率和降低接入成本。</p>
</li>
<li><p>针对三方的跨端框架，可以降低其兼容难度和运行时的体积，提高执行效率。</p>
</li>
</ul>
<p>最关键最关键的是，终于可以抛弃掉 XXML 这套恶心的东西了。没有难用的数据绑定，支持传递函数，不需要考虑 data 内数据是否是视图需要的，自定义组件之间的时序能够得到天然的保障，能够支持 CSS-In-JS 等等。</p>
<p>社区中很多优秀的方案都可以拿来使用，总之，就是优雅，优雅，还是优雅。</p>
<h1 id="全新架构"><a href="#全新架构" class="headerlink" title="全新架构"></a>全新架构</h1><p>在理解了上文所讲述的内容之后，就该讲解下我们为了实现上面的功能所做的全新架构了：</p>
<img src="/2023/06/14/use-dom-to-improve-double-performance-in-mini-program/2810ea5d-ab90-4fb8-8f26-fa101d2b26b8.png" class="">
<p>最简单的理解，就是在新架构中，渲染层和逻辑层之间的通讯不再发送 data 了，而是通过逻辑层实现的一套 DOM 接口，将其转换成 DOM 的操作指令。</p>
<p>如果说渲染的操作是 <code>fn(data)</code> 的过程，那么以前这个过程是在渲染层完成，而新架构下，这个操作将在逻辑层完成。</p>
<p>在新架构中，依旧保留了对原先 XXML 的兼容性，开发者可以通过 <code>renderingModel</code> 控制。控制以 Page 为粒度，保证在开发中可以做到渐进式迁移。另外，DOM 接口与 XXML 只能二选一，两者无法在一个 Page 上同时开启。</p>
<blockquote>
<p>我并不认为提供 Page 级别的控制在技术设计上是一个好方案，但这个方案确实是可以最大程度上提供更好的兼容性，方便开发者渐进式的替换。</p>
</blockquote>
<h2 id="Document-结构"><a href="#Document-结构" class="headerlink" title="Document 结构"></a>Document 结构</h2><p>当开启 DOM 的渲染模型之后，整个小程序的文档模型都将与 Web 有着极其类似的结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> <span class="comment">&lt;!-- document.documentElement 一般不会用到这个 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="comment">&lt;!-- document.head --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 可以在这里利用 meta 标签配置一些全局内容 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span> <span class="comment">&lt;!-- document.body --&gt;</span></span><br><span class="line">	  <span class="tag">&lt;<span class="name">page</span> <span class="attr">route</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span> <span class="comment">&lt;!-- Page 实例所对应的渲染节点 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">view</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">page</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">page</span> <span class="attr">route</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">page</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>例如每一个 Page 都对应着 <code>document.body</code> 内的一个 <code>&lt;page/&gt;</code> 元素。页面栈也与 <code>document.body.childNodes</code> 保持一致，页面栈的进出相当于 page 元素的插入和剥离。</p>
<p>当然，这里只是一个类比，实际上会有些许的不同，本文不再展开（其实就是我还没设计好，这是个预期模型）。</p>
<h2 id="小程序内置组件"><a href="#小程序内置组件" class="headerlink" title="小程序内置组件"></a>小程序内置组件</h2><p>小程序内置组件在 DOM 接口下名字、属性、使用方式依旧保持不变，并且遵守 Web 的通用规范。提供了对应的 DOM Interface 方便开发者直接操作和使用。例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tagName 都是和 XXML 内保持一致</span></span><br><span class="line"><span class="keyword">const</span> view = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;view&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> picker = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;picker&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> pickerView = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;picker-view&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性名字也与原先的保持一致，只不过当用作属性的时候，需要将其转换成驼峰的格式。</span></span><br><span class="line">button.<span class="property">openType</span> = <span class="string">&#x27;share&#x27;</span></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">button.<span class="title function_">setAttribute</span>(<span class="string">&#x27;open-type&#x27;</span>, <span class="string">&#x27;share&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原先组件的使用方式依旧不变，例如 picker-view 下面需要插入 picker-view-column</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">	pickerView.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;picker-view-column&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当需要赋值非字符串类型的值的时候，尽量使用 property 的方式</span></span><br><span class="line">picker.<span class="property">range</span> = [[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], [<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 attribute 可能会得到预期以外的行为，不推荐使用</span></span><br><span class="line">picker.<span class="title function_">setAttribute</span>(<span class="string">&#x27;range&#x27;</span>, [...])</span><br></pre></td></tr></table></figure>
<p>或许有人会问，为什么使用了 DOM 接口缺不能使用前端的组件呢？</p>
<p>这是因为小程序的组件体系确实是比较特殊的，目前暂时没有很好的办法去兼容。但是在未来，可能会选择开放部分 Web 的组件，例如 <code>div</code> <code>span</code> <code>svg</code> 等。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><blockquote>
<p>目前该方案还在内部开发阶段，外部没有全量发布。下文中提到的所有接口都属于不稳定接口，在没有正式对外前，只能作为参考。</p>
</blockquote>
<p>可能看完上面之后大家依旧会是一头雾水，我这里通过一个简单的 DEMO 来让大家有更加清晰的认识。</p>
<ol>
<li>打开飞书开发者工具中的新框架开关</li>
</ol>
<img src="/2023/06/14/use-dom-to-improve-double-performance-in-mini-program/81901ab6-dc9d-4c37-be46-4185af09f593.png" class="">
<ol>
<li>在要开启 DOM 接口的 Page 所对应的 JSON 中添加 <code>renderingModel</code> 为 <code>dom</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;renderingModel&quot;</span>: <span class="string">&quot;dom&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>此时可以在 Page 的 <code>onLoad</code> 生命周期内通过 <code>this.pageElement</code> 获取到 Page 的元素实例了，可以将其理解为前端开发中的 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code> 元素。后续就可以按照前端开发流程去操作这个元素了</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="title function_">onLoad</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> root = <span class="variable language_">this</span>.<span class="property">pageElement</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以直接控制页面渲染</span></span><br><span class="line">    <span class="keyword">const</span> view = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;view&#x27;</span>) <span class="comment">// 这里不能使用 Web 组件，只能使用小程序组件</span></span><br><span class="line">    view.<span class="property">style</span> = <span class="string">&#x27;color: blue;&#x27;</span> <span class="comment">// style 只能设置不能读取，读取到的值是不准确的</span></span><br><span class="line">    view.<span class="property">className</span> = <span class="string">&#x27;root&#x27;</span></span><br><span class="line">    view.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&#x27;Hello world&#x27;</span>))</span><br><span class="line">    root.<span class="title function_">appendChild</span>(view)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者使用主流前端框架进行渲染</span></span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">createRoot</span>(root).<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>) <span class="comment">// JSX 小程序不支持，需要进行转换，这里只是举例</span></span><br><span class="line">    <span class="comment">// 或</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>(root)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li>其他的例如样式、API 等与普通小程序无异。样式依旧通过 XXSS 使用，API 则继续可以使用 <code>tt</code> 如果在飞书内的话。</li>
</ol>
<h1 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h1><p>性能自然是为什么要引入 DOM 最重要的一个因素了，让我们来看一下性能对比测试</p>
<h2 id="测试方式"><a href="#测试方式" class="headerlink" title="测试方式"></a>测试方式</h2><p>仓库：<a target="_blank" rel="noopener" href="https://github.com/XGHeaven/perf-gadget-dom-vs-framework">https://github.com/XGHeaven/perf-gadget-dom-vs-framework</a></p>
<p>使用 Vue3 的框架，Demo 使用 <a target="_blank" rel="noopener" href="https://github.com/mdn/todo-vue">mdn/todo-vue</a>，在此基础上使用了 Taro 将代码分别编译到飞书、微信、支付宝。</p>
<ul>
<li><p><code>taro-wx</code> Taro 编译到微信，微信版本为 <code>8.0.35</code></p>
</li>
<li><p><code>taro-alipay</code> Taro 编译到支付宝，开启 2.0 lib，支付宝版本为 <code>10.3.80</code></p>
</li>
<li><p><code>taro-tt</code> Taro 编译到抖音(Tiktok)，抖音版本为 <code>25.5.0</code></p>
</li>
<li><p><code>taro-lark</code> Taro 编译到飞书，飞书版本为 <code>6.5.3</code></p>
</li>
<li><p><code>dom-lark</code> Vue 源码直接编译到飞书新架构 DOM 接口上，飞书版本为 <code>6.5.3</code></p>
</li>
</ul>
<p>每一个测试项目，有 5 次的预热运行，之后会再运行 10 次，取其平均值。同时每次运行之间都会相隔一段时间，保证系统有时机去做别的事情，从而尽可能避免影响到测试结果。</p>
<blockquote>
<p>之所以选择 Taro 而非 XXML 原生写法或者其他跨端框架，其一是因为更加接近于开发者的使用体验，因为不可能有人会选择直接去操作 DOM。其二是因为 Taro 已经是最快的跨端框架了，再比较其他的没有什么太多的意义。</p>
</blockquote>
<p>除此以外，其他的内容基本一致：</p>
<ul>
<li><p>测试设备为华为 P40 Pro，麒麟 990 处理器，鸿蒙 OS 3.0 系统。</p>
</li>
<li><p>Taro 框架统一经过 build:xx 命令后运行，Vue 直接通过 Vite 编译后运行</p>
</li>
<li><p>运行方式都是打开对应平台的开发者工具并上传之后，在后台生成对应的二维码扫码预览，避免被认为是开发状态从而添加对结果有影响的能力。</p>
</li>
</ul>
<p>由于 Taro 框架以及飞书新架构的情况下，组件的 <code>mounted</code> 生命周期只能保证在逻辑层侧完成了渲染，不能保证此时组件更新指令已经发送到渲染层，我们需要寻找一个全新的方式去衡量什么时候组件真正渲染上屏。</p>
<p>幸运的是，<code>image</code> 组件有一个特性，当图片被渲染出来并成功加载之后，会触发 <code>load</code> 事件，当此事件触发的时候，可以认为组件已经正确被渲染到屏幕上了。此时，我们只需要在某次更新组件的最后一个组件内，插入一个高宽为 0 的 <code>image</code> 组件作为渲染标记，当事件被触发时，就可以测量出整体的渲染时间。</p>
<p>虽然图片加载会占用一定的时间，但资源本身就是离线保存在代码包内，加载速度很快，且这并不影响最终结果的相对大小。</p>
<blockquote>
<p>Taro 默认关闭资源内联功能，避免 Taro 将小资源文件内联成 base64 字符串从而增大通讯成本。</p>
</blockquote>
<h2 id="测试内容"><a href="#测试内容" class="headerlink" title="测试内容"></a>测试内容</h2><p>这里还需要再补充几点：</p>
<ul>
<li><p>不测试应用首屏的性能，由于首屏开始的时间点不同宿主下测量会是不一样的，所以我只在私下里在飞书上通过录屏测试过 Uniapp 对比 DOM，差不多 DOM 可以快 300ms。如果采用 Taro 理论上差距会缩小，但是依旧是快的。</p>
</li>
<li><p>而且首屏性能主要由 JS Parse 和 Execution 的时间组成，这两部分分别由包体积和渲染性能决定，可以分别对比这两项测试从而大体可以得出首屏的性能。</p>
</li>
<li><p>不包含纯静态内容，因为测试使用的是 Taro 框架，其会在逻辑层搞一套虚拟 DOM，会导致最终发送给渲染层的数据量其实基本一致，测试的意义不大。如果有需要，后续可以对比 DOM 和 XXML 的在纯静态内容上的速度差异。</p>
</li>
</ul>
<h3 id="列表组件渲染"><a href="#列表组件渲染" class="headerlink" title="列表组件渲染"></a>列表组件渲染</h3><p>渲染 100 个 Todo 项，记录对应的耗时</p>
<ul>
<li><p>mounted 耗时，指从组件 created 到 mounted 所花费的时间</p>
</li>
<li><p>完整渲染耗时，指从组件 created 到渲染层上屏渲染完毕（图片 onload 触发）所花费的时间</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>目标</th>
<th>mounted 耗时</th>
<th>完整渲染耗时</th>
</tr>
</thead>
<tbody>
<tr>
<td>taro-wx</td>
<td>141.3 (156%)</td>
<td>1457.4 (443%)</td>
</tr>
<tr>
<td>taro-alipay</td>
<td>141.1 (156%)</td>
<td>387.2 (177%)</td>
</tr>
<tr>
<td>taro-tt</td>
<td>148.5 (165%)</td>
<td>608.7 (185%)</td>
</tr>
<tr>
<td>taro-lark</td>
<td>140.8 (156%)</td>
<td>620.6 (188%)</td>
</tr>
<tr>
<td>dom-lark</td>
<td>89.9 (100%)</td>
<td>328.9 (100%)</td>
</tr>
</tbody>
</table>
<h3 id="列表组件内部更新"><a href="#列表组件内部更新" class="headerlink" title="列表组件内部更新"></a>列表组件内部更新</h3><p>将 Todo 项内的每一个 checked 进行反转，记录耗时</p>
<table>
<thead>
<tr>
<th>目标</th>
<th>完整渲染耗时</th>
</tr>
</thead>
<tbody>
<tr>
<td>taro-wx</td>
<td>1374.5 (2220%)</td>
</tr>
<tr>
<td>taro-alipay</td>
<td>138.7 (224%)</td>
</tr>
<tr>
<td>taro-tt</td>
<td>205.3 (331%)</td>
</tr>
<tr>
<td>taro-lark</td>
<td>231.7 (374%)</td>
</tr>
<tr>
<td>dom-lark</td>
<td>61.9 (100%)</td>
</tr>
</tbody>
</table>
<h3 id="体积比较"><a href="#体积比较" class="headerlink" title="体积比较"></a>体积比较</h3><ul>
<li><p>核心逻辑，只包含样式、JS、XXML、SJS 的大小，不包含图片文件，json 等</p>
</li>
<li><p>整包大小，包含图片资源、JS、CSS等整个包的大小</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>目标</th>
<th>核心逻辑</th>
<th>整包大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>taro-wx</td>
<td>308K (452%)</td>
<td>336K (323%)</td>
</tr>
<tr>
<td>taro-alipay</td>
<td>256K (376%)</td>
<td>276K (265%)</td>
</tr>
<tr>
<td>taro-tt</td>
<td>248K (364%)</td>
<td>272K (261%)</td>
</tr>
<tr>
<td>taro-lark</td>
<td>248K (364%)</td>
<td>272K (261%)</td>
</tr>
<tr>
<td>dom-lark</td>
<td>68K (100%)</td>
<td>104K (100%)</td>
</tr>
</tbody>
</table>
<h3 id="测试解读"><a href="#测试解读" class="headerlink" title="测试解读"></a>测试解读</h3><ul>
<li><p>微信不知为何，性能表现非常差，我也不再倾向于继续和它进行对比，否则数据会非常夸张。</p>
</li>
<li><p>采用 DOM 接口的开发方式，可以简化掉繁重的 Taro runtime 的实现，从而在速度和体积上获取一定的优势。</p>
</li>
<li><p>相比飞书自身，各种情况下速度至少可以提高一倍以上，体积可以降低到原先的 30%。</p>
</li>
<li><p>相比支付宝，体积上依旧保持优势，渲染速度上的优势略低一些，平均不超过 50% 的提升。但这个问题主要是飞书对内置组件（<code>checkbox</code>、<code>button</code>）实现的性能较差，如果飞书对这部分进行优化后，相信可以获得更好的优势。</p>
</li>
</ul>
<h1 id="新框架会面临那些问题"><a href="#新框架会面临那些问题" class="headerlink" title="新框架会面临那些问题"></a>新框架会面临那些问题</h1><p>虽然新架构的 DOM 接口在上面的测试和预期中会带来很多的优势，但这并不意味着一点问题都没有。</p>
<ul>
<li><p>新架构虽然保留了对 XXML 的兼容性，但依旧会产生一定的 Break Chagne，具体可以看<a target="_blank" rel="noopener" href="https://open.feishu.cn/document/uYjL24iN/uEjMuEjMuEjM/new-framework/breaking-changes">飞书官方文档</a>。</p>
</li>
<li><p>由于双线程的架构，在逻辑层模拟的那一层 DOM 无法实现任何和渲染结果相关的 API，例如 <code>getComutedStyle</code> 。还包括 querySelector 依旧要通过原先的异步方式获取。</p>
</li>
<li><p>由于 DOM 接口某些能力实现难度较高，例如 <code>innerHTML</code> <code>css parser</code> 等，目前与这些相关的能力只有写入没有读取的能力，如果一定要读取，将无法保证一致性。</p>
</li>
<li><p>目前样式还不支持动态插入，后续会支持在 <code>&lt;page&gt;</code> 或者 <code>&lt;head&gt;</code> 内动态插入 <code>&lt;style&gt;</code> 标签来实现。</p>
</li>
<li><p>首屏性能。这个上文也说过，后续会有很多办法去优化和实现的，但优先级不高</p>
</li>
</ul>
<p>对我来说，我觉得整体瑕不掩瑜，未来可期。</p>
<h1 id="未来规划与设计"><a href="#未来规划与设计" class="headerlink" title="未来规划与设计"></a>未来规划与设计</h1><ul>
<li><p>目前新框架能力的开启和 DOM 接口的使用还在内测状态，对外的时间暂时无法确定</p>
</li>
<li><p>未来 DOM 接口还有许多的优化方向，例如如何降低 DOM 指令的数量，降低一些重复字符串的发送等等</p>
</li>
<li><p>由于 DOM 接口在一些非 Web 标准组件中和前端框架有一些冲突，例如 React 无法很好的支持 <code>picker</code> 这类需要针对某些属性设置一个对象的情况。后续会推出一些兼容手段去解决这些问题。</p>
</li>
<li><p>主流的前端组件组（例如 antd/element/ud）都无法很好的运行在这个上面。一方面是因为这些组件库多多少少都依赖了前端的一些接口，而小程序没有；另一方面，组件库使用的也都是 Web 的标签元素，而不是小程序的组件。后续会尝试推出一定的解决方案去处理这个问题，能够让社区做较少的修改就可以兼容。</p>
</li>
<li><p>会考虑以飞书官方的身份推出一套适配于 DOM 接口的主流前端组件库，根据情况会选择是否需要添加 WebComponent 能力的支持。</p>
</li>
<li><p>未来飞书小程序的规划都是尽可能的向前端标准实现，未来可能会逐渐添加例如 <code>fetch</code> <code>navigator</code> 在内的 BOM 接口能力支持。</p>
</li>
</ul>
<h1 id="为什么要写这篇文章"><a href="#为什么要写这篇文章" class="headerlink" title="为什么要写这篇文章"></a>为什么要写这篇文章</h1><ul>
<li><p>希望能促进小程序的前进。<br>小程序业务上的成功并不是其可以恶心开发者的理由，也不应该放弃对其优化的决心。我希望我这一篇有点颠覆传统小程序风格的优化文章，能够探索更多的思路和想法。</p>
</li>
<li><p>寻求合作。<br>由于 DOM 接口的特性，需要更多社区的配合才能将这个发挥到极致，例如 Taro/Uniapp 等三方框架，Vant 等小程序原生组件库等等。</p>
</li>
<li><p>沟通交流，拓展思路。<br>希望能够得到更多人对这件事情的想法和思路，也希望能够得到更多的输入。</p>
</li>
</ul>

                    
                        

                    
                    
                        <p>
                            <a href="/2023/06/14/use-dom-to-improve-double-performance-in-mini-program/#post-footer" class="postShorten-excerpt_link link">
                                注释和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">第 1 页 共 1 页</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2024 XGHeaven. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="https://www.gravatar.com/avatar/f34474afe04544ffbe944a804f0ae762?s=110"/>
        
            <h4 id="about-card-name">XGHeaven</h4>
        
            <h5 id="about-card-bio"><p>一个弱弱的码农</p>
</h5>
        
        
            <h5 id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>杭州电子科技大学学生一枚</p>

            </h5>
        
        
            <h5 id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                Weifang Shandong, China
            </h5>
        
    </div>
</div>

        
<div id="cover" style="background-image:url('/static/images/20170217-TombRaider.jpg');"></div>
    </body>
    <!--SCRIPTS-->

<script src="/assets/js/scrip-z6xcdnzggiy56kzp83ux5nnbwra1acrauxruz3kdi3u5xladb6jh4n3ylebm.min.js"></script>

<!--SCRIPTS END-->



</html>
